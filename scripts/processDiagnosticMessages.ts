import fs from "fs";
import path from "path";

interface DiagnosticDetails {
    category: string;
    code: number;
    reportsUnnecessary?: Record<string, unknown>;
    reportsDeprecated?: Record<string, unknown>;
    isEarly?: boolean;
    elidedInCompatabilityPyramid?: boolean;
}

type InputDiagnosticMessageTable = Map<string, DiagnosticDetails>;

async function main(): Promise<void> {
    if (process.argv.length < 3) {
        console.log("Usage:");
        console.log("\tnode processDiagnosticMessages.mjs <diagnostic-json-input-file>");
        return;
    }

    async function writeFile(fileName: string, contents: string): Promise<void> {
        const filePath = path.join(path.dirname(inputFilePath), fileName);
        try {
            const existingContents = await fs.promises.readFile(filePath, "utf-8");
            if (existingContents === contents) {
                return;
            }
        } catch {
            // Just write the file.
        }

        await fs.promises.writeFile(filePath, contents, { encoding: "utf-8" });
    }

    const inputFilePath = process.argv[2].replace(/\\/g, "/");
    console.log(`Reading diagnostics from ${inputFilePath}`);
    const inputStr = await fs.promises.readFile(inputFilePath, { encoding: "utf-8" });

    const diagnosticMessagesJson: Record<string, DiagnosticDetails> = JSON.parse(inputStr);

    const diagnosticMessages: InputDiagnosticMessageTable = new Map();
    for (const key in diagnosticMessagesJson) {
        if (Object.hasOwnProperty.call(diagnosticMessagesJson, key)) {
            diagnosticMessages.set(key, diagnosticMessagesJson[key]);
        }
    }

    const infoFileOutput = buildInfoFileOutput(diagnosticMessages, inputFilePath);
    checkForUniqueCodes(diagnosticMessages);
    await writeFile("diagnostic_information_map_generated.rs", infoFileOutput);

    const messageOutput = buildDiagnosticMessageOutput(diagnosticMessages);
    await writeFile("diagnosticMessages.generated.json", messageOutput);
}

function checkForUniqueCodes(diagnosticTable: InputDiagnosticMessageTable): void {
    const allCodes: Record<number, boolean> = {};
    diagnosticTable.forEach(({ code }) => {
        if (allCodes[code]) {
            throw new Error(`Diagnostic code ${code} appears more than once.`);
        }
        allCodes[code] = true;
    });
}

function buildInfoFileOutput(messageTable: InputDiagnosticMessageTable, inputFilePathRel: string): string {
    const result = [
        "// <auto-generated />",
        `// generated from '${inputFilePathRel}'`,
        "",
        "use crate::compiler::types::{DiagnosticCategory, DiagnosticMessage};",
        "",
        "fn diag(code: i32, category: DiagnosticCategory, key: String, message: String, reports_unnecessary: Option<bool>, elided_in_compatibility_pyramid: Option<bool>, reports_deprecated: Option<bool>) -> DiagnosticMessage {",
        "    DiagnosticMessage { code, category, key, message, reports_unnecessary, elided_in_compatibility_pyramid, reports_deprecated }",
        "}",
        "",
        "pub struct Diagnostics;",
        "",
        "#[rustfmt::skip]",
        "impl Diagnostics {",
    ];

    messageTable.forEach(
        ({ code, category, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated }, name) => {
            const propName = convertPropertyName(name);
            const rustCategory = `DiagnosticCategory::${category.charAt(0).toUpperCase() + category.slice(1)}`;
            result.push(
                `    pub fn ${propName}() -> DiagnosticMessage { diag(${code}, ${rustCategory}, String::from("${createKey(
                    propName,
                    code
                )}"), String::from(${JSON.stringify(name)}), ${reportsUnnecessary ? "Some(true)" : "None"}, ${
                    elidedInCompatabilityPyramid ? "Some(true)" : "None"
                }, ${reportsDeprecated ? "Some(true)" : "None"}) }`
            );
        }
    );

    result.push("}");

    return result.join("\n");
}

function buildDiagnosticMessageOutput(messageTable: InputDiagnosticMessageTable): string {
    const result: Record<string, string> = {};

    messageTable.forEach(({ code }, name) => {
        const propName = convertPropertyName(name);
        result[createKey(propName, code)] = name;
    });

    return JSON.stringify(result, undefined, 2).replace(/\r?\n/g, "\r\n");
}

function createKey(name: string, code: number): string {
    return name.slice(0, 100) + "_" + code;
}

function convertPropertyName(origName: string): string {
    let result = origName
        .split("")
        .map((char) => {
            if (char === "*") return "_asterisk";
            if (char === "/") return "_slash";
            if (char === ":") return "_colon";
            return /\w/.test(char) ? char : "_";
        })
        .join("");

    // get rid of all multi-underscores
    result = result.replace(/_+/g, "_");

    // remove any leading underscore, unless it is followed by a number
    result = result.replace(/^_(\D)/, "$1");

    // get rid of all trailing underscores
    result = result.replace(/_$/, "");

    return result;
}

main();
