// <auto-generated />
// generated from 'src/compiler/diagnosticMessages.json'

use crate::compiler::types::{DiagnosticCategory, DiagnosticMessage};

fn diag(code: i32, category: DiagnosticCategory, key: String, message: String, reports_unnecessary: Option<bool>, elided_in_compatibility_pyramid: Option<bool>, reports_deprecated: Option<bool>) -> DiagnosticMessage {
    DiagnosticMessage { code, category, key, message, reports_unnecessary, elided_in_compatibility_pyramid, reports_deprecated }
}

pub struct Diagnostics;

#[rustfmt::skip]
impl Diagnostics {
    pub fn unterminated_string_literal() -> DiagnosticMessage { diag(1002, DiagnosticCategory::Error, String::from("Unterminated_string_literal_1002"), String::from("Unterminated string literal."), None, None, None) }
    pub fn identifier_expected() -> DiagnosticMessage { diag(1003, DiagnosticCategory::Error, String::from("Identifier_expected_1003"), String::from("Identifier expected."), None, None, None) }
    pub fn _0_expected() -> DiagnosticMessage { diag(1005, DiagnosticCategory::Error, String::from("_0_expected_1005"), String::from("'{0}' expected."), None, None, None) }
    pub fn a_file_cannot_have_a_reference_to_itself() -> DiagnosticMessage { diag(1006, DiagnosticCategory::Error, String::from("A_file_cannot_have_a_reference_to_itself_1006"), String::from("A file cannot have a reference to itself."), None, None, None) }
    pub fn the_parser_expected_to_find_a_1_to_match_the_0_token_here() -> DiagnosticMessage { diag(1007, DiagnosticCategory::Error, String::from("The_parser_expected_to_find_a_1_to_match_the_0_token_here_1007"), String::from("The parser expected to find a '{1}' to match the '{0}' token here."), None, None, None) }
    pub fn trailing_comma_not_allowed() -> DiagnosticMessage { diag(1009, DiagnosticCategory::Error, String::from("Trailing_comma_not_allowed_1009"), String::from("Trailing comma not allowed."), None, None, None) }
    pub fn asterisk_slash_expected() -> DiagnosticMessage { diag(1010, DiagnosticCategory::Error, String::from("asterisk_slash_expected_1010"), String::from("'*/' expected."), None, None, None) }
    pub fn an_element_access_expression_should_take_an_argument() -> DiagnosticMessage { diag(1011, DiagnosticCategory::Error, String::from("An_element_access_expression_should_take_an_argument_1011"), String::from("An element access expression should take an argument."), None, None, None) }
    pub fn unexpected_token() -> DiagnosticMessage { diag(1012, DiagnosticCategory::Error, String::from("Unexpected_token_1012"), String::from("Unexpected token."), None, None, None) }
    pub fn a_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma() -> DiagnosticMessage { diag(1013, DiagnosticCategory::Error, String::from("A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma_1013"), String::from("A rest parameter or binding pattern may not have a trailing comma."), None, None, None) }
    pub fn a_rest_parameter_must_be_last_in_a_parameter_list() -> DiagnosticMessage { diag(1014, DiagnosticCategory::Error, String::from("A_rest_parameter_must_be_last_in_a_parameter_list_1014"), String::from("A rest parameter must be last in a parameter list."), None, None, None) }
    pub fn parameter_cannot_have_question_mark_and_initializer() -> DiagnosticMessage { diag(1015, DiagnosticCategory::Error, String::from("Parameter_cannot_have_question_mark_and_initializer_1015"), String::from("Parameter cannot have question mark and initializer."), None, None, None) }
    pub fn a_required_parameter_cannot_follow_an_optional_parameter() -> DiagnosticMessage { diag(1016, DiagnosticCategory::Error, String::from("A_required_parameter_cannot_follow_an_optional_parameter_1016"), String::from("A required parameter cannot follow an optional parameter."), None, None, None) }
    pub fn an_index_signature_cannot_have_a_rest_parameter() -> DiagnosticMessage { diag(1017, DiagnosticCategory::Error, String::from("An_index_signature_cannot_have_a_rest_parameter_1017"), String::from("An index signature cannot have a rest parameter."), None, None, None) }
    pub fn an_index_signature_parameter_cannot_have_an_accessibility_modifier() -> DiagnosticMessage { diag(1018, DiagnosticCategory::Error, String::from("An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018"), String::from("An index signature parameter cannot have an accessibility modifier."), None, None, None) }
    pub fn an_index_signature_parameter_cannot_have_a_question_mark() -> DiagnosticMessage { diag(1019, DiagnosticCategory::Error, String::from("An_index_signature_parameter_cannot_have_a_question_mark_1019"), String::from("An index signature parameter cannot have a question mark."), None, None, None) }
    pub fn an_index_signature_parameter_cannot_have_an_initializer() -> DiagnosticMessage { diag(1020, DiagnosticCategory::Error, String::from("An_index_signature_parameter_cannot_have_an_initializer_1020"), String::from("An index signature parameter cannot have an initializer."), None, None, None) }
    pub fn an_index_signature_must_have_a_type_annotation() -> DiagnosticMessage { diag(1021, DiagnosticCategory::Error, String::from("An_index_signature_must_have_a_type_annotation_1021"), String::from("An index signature must have a type annotation."), None, None, None) }
    pub fn an_index_signature_parameter_must_have_a_type_annotation() -> DiagnosticMessage { diag(1022, DiagnosticCategory::Error, String::from("An_index_signature_parameter_must_have_a_type_annotation_1022"), String::from("An index signature parameter must have a type annotation."), None, None, None) }
    pub fn readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature() -> DiagnosticMessage { diag(1024, DiagnosticCategory::Error, String::from("readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024"), String::from("'readonly' modifier can only appear on a property declaration or index signature."), None, None, None) }
    pub fn an_index_signature_cannot_have_a_trailing_comma() -> DiagnosticMessage { diag(1025, DiagnosticCategory::Error, String::from("An_index_signature_cannot_have_a_trailing_comma_1025"), String::from("An index signature cannot have a trailing comma."), None, None, None) }
    pub fn accessibility_modifier_already_seen() -> DiagnosticMessage { diag(1028, DiagnosticCategory::Error, String::from("Accessibility_modifier_already_seen_1028"), String::from("Accessibility modifier already seen."), None, None, None) }
    pub fn _0_modifier_must_precede_1_modifier() -> DiagnosticMessage { diag(1029, DiagnosticCategory::Error, String::from("_0_modifier_must_precede_1_modifier_1029"), String::from("'{0}' modifier must precede '{1}' modifier."), None, None, None) }
    pub fn _0_modifier_already_seen() -> DiagnosticMessage { diag(1030, DiagnosticCategory::Error, String::from("_0_modifier_already_seen_1030"), String::from("'{0}' modifier already seen."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_class_elements_of_this_kind() -> DiagnosticMessage { diag(1031, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_class_elements_of_this_kind_1031"), String::from("'{0}' modifier cannot appear on class elements of this kind."), None, None, None) }
    pub fn super_must_be_followed_by_an_argument_list_or_member_access() -> DiagnosticMessage { diag(1034, DiagnosticCategory::Error, String::from("super_must_be_followed_by_an_argument_list_or_member_access_1034"), String::from("'super' must be followed by an argument list or member access."), None, None, None) }
    pub fn only_ambient_modules_can_use_quoted_names() -> DiagnosticMessage { diag(1035, DiagnosticCategory::Error, String::from("Only_ambient_modules_can_use_quoted_names_1035"), String::from("Only ambient modules can use quoted names."), None, None, None) }
    pub fn statements_are_not_allowed_in_ambient_contexts() -> DiagnosticMessage { diag(1036, DiagnosticCategory::Error, String::from("Statements_are_not_allowed_in_ambient_contexts_1036"), String::from("Statements are not allowed in ambient contexts."), None, None, None) }
    pub fn a_declare_modifier_cannot_be_used_in_an_already_ambient_context() -> DiagnosticMessage { diag(1038, DiagnosticCategory::Error, String::from("A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038"), String::from("A 'declare' modifier cannot be used in an already ambient context."), None, None, None) }
    pub fn initializers_are_not_allowed_in_ambient_contexts() -> DiagnosticMessage { diag(1039, DiagnosticCategory::Error, String::from("Initializers_are_not_allowed_in_ambient_contexts_1039"), String::from("Initializers are not allowed in ambient contexts."), None, None, None) }
    pub fn _0_modifier_cannot_be_used_in_an_ambient_context() -> DiagnosticMessage { diag(1040, DiagnosticCategory::Error, String::from("_0_modifier_cannot_be_used_in_an_ambient_context_1040"), String::from("'{0}' modifier cannot be used in an ambient context."), None, None, None) }
    pub fn _0_modifier_cannot_be_used_here() -> DiagnosticMessage { diag(1042, DiagnosticCategory::Error, String::from("_0_modifier_cannot_be_used_here_1042"), String::from("'{0}' modifier cannot be used here."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_a_module_or_namespace_element() -> DiagnosticMessage { diag(1044, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044"), String::from("'{0}' modifier cannot appear on a module or namespace element."), None, None, None) }
    pub fn top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier() -> DiagnosticMessage { diag(1046, DiagnosticCategory::Error, String::from("Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier_1046"), String::from("Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier."), None, None, None) }
    pub fn a_rest_parameter_cannot_be_optional() -> DiagnosticMessage { diag(1047, DiagnosticCategory::Error, String::from("A_rest_parameter_cannot_be_optional_1047"), String::from("A rest parameter cannot be optional."), None, None, None) }
    pub fn a_rest_parameter_cannot_have_an_initializer() -> DiagnosticMessage { diag(1048, DiagnosticCategory::Error, String::from("A_rest_parameter_cannot_have_an_initializer_1048"), String::from("A rest parameter cannot have an initializer."), None, None, None) }
    pub fn a_set_accessor_must_have_exactly_one_parameter() -> DiagnosticMessage { diag(1049, DiagnosticCategory::Error, String::from("A_set_accessor_must_have_exactly_one_parameter_1049"), String::from("A 'set' accessor must have exactly one parameter."), None, None, None) }
    pub fn a_set_accessor_cannot_have_an_optional_parameter() -> DiagnosticMessage { diag(1051, DiagnosticCategory::Error, String::from("A_set_accessor_cannot_have_an_optional_parameter_1051"), String::from("A 'set' accessor cannot have an optional parameter."), None, None, None) }
    pub fn a_set_accessor_parameter_cannot_have_an_initializer() -> DiagnosticMessage { diag(1052, DiagnosticCategory::Error, String::from("A_set_accessor_parameter_cannot_have_an_initializer_1052"), String::from("A 'set' accessor parameter cannot have an initializer."), None, None, None) }
    pub fn a_set_accessor_cannot_have_rest_parameter() -> DiagnosticMessage { diag(1053, DiagnosticCategory::Error, String::from("A_set_accessor_cannot_have_rest_parameter_1053"), String::from("A 'set' accessor cannot have rest parameter."), None, None, None) }
    pub fn a_get_accessor_cannot_have_parameters() -> DiagnosticMessage { diag(1054, DiagnosticCategory::Error, String::from("A_get_accessor_cannot_have_parameters_1054"), String::from("A 'get' accessor cannot have parameters."), None, None, None) }
    pub fn type_0_is_not_a_valid_async_function_return_type_in_es5_because_it_does_not_refer_to_a_promise_compatible_constructor_value() -> DiagnosticMessage { diag(1055, DiagnosticCategory::Error, String::from("Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compa_1055"), String::from("Type '{0}' is not a valid async function return type in ES5 because it does not refer to a Promise-compatible constructor value."), None, None, None) }
    pub fn accessors_are_only_available_when_targeting_ecmascript_5_and_higher() -> DiagnosticMessage { diag(1056, DiagnosticCategory::Error, String::from("Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056"), String::from("Accessors are only available when targeting ECMAScript 5 and higher."), None, None, None) }
    pub fn the_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member() -> DiagnosticMessage { diag(1058, DiagnosticCategory::Error, String::from("The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058"), String::from("The return type of an async function must either be a valid promise or must not contain a callable 'then' member."), None, None, None) }
    pub fn a_promise_must_have_a_then_method() -> DiagnosticMessage { diag(1059, DiagnosticCategory::Error, String::from("A_promise_must_have_a_then_method_1059"), String::from("A promise must have a 'then' method."), None, None, None) }
    pub fn the_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback() -> DiagnosticMessage { diag(1060, DiagnosticCategory::Error, String::from("The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060"), String::from("The first parameter of the 'then' method of a promise must be a callback."), None, None, None) }
    pub fn enum_member_must_have_initializer() -> DiagnosticMessage { diag(1061, DiagnosticCategory::Error, String::from("Enum_member_must_have_initializer_1061"), String::from("Enum member must have initializer."), None, None, None) }
    pub fn type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method() -> DiagnosticMessage { diag(1062, DiagnosticCategory::Error, String::from("Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062"), String::from("Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method."), None, None, None) }
    pub fn an_export_assignment_cannot_be_used_in_a_namespace() -> DiagnosticMessage { diag(1063, DiagnosticCategory::Error, String::from("An_export_assignment_cannot_be_used_in_a_namespace_1063"), String::from("An export assignment cannot be used in a namespace."), None, None, None) }
    pub fn the_return_type_of_an_async_function_or_method_must_be_the_global_promise_t_type_did_you_mean_to_write_promise_0() -> DiagnosticMessage { diag(1064, DiagnosticCategory::Error, String::from("The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_wri_1064"), String::from("The return type of an async function or method must be the global Promise<T> type. Did you mean to write 'Promise<{0}>'?"), None, None, None) }
    pub fn the_return_type_of_an_async_function_or_method_must_be_the_global_promise_t_type() -> DiagnosticMessage { diag(1065, DiagnosticCategory::Error, String::from("The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_1065"), String::from("The return type of an async function or method must be the global Promise<T> type."), None, None, None) }
    pub fn in_ambient_enum_declarations_member_initializer_must_be_constant_expression() -> DiagnosticMessage { diag(1066, DiagnosticCategory::Error, String::from("In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066"), String::from("In ambient enum declarations member initializer must be constant expression."), None, None, None) }
    pub fn unexpected_token_a_constructor_method_accessor_or_property_was_expected() -> DiagnosticMessage { diag(1068, DiagnosticCategory::Error, String::from("Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068"), String::from("Unexpected token. A constructor, method, accessor, or property was expected."), None, None, None) }
    pub fn unexpected_token_a_type_parameter_name_was_expected_without_curly_braces() -> DiagnosticMessage { diag(1069, DiagnosticCategory::Error, String::from("Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces_1069"), String::from("Unexpected token. A type parameter name was expected without curly braces."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_a_type_member() -> DiagnosticMessage { diag(1070, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_a_type_member_1070"), String::from("'{0}' modifier cannot appear on a type member."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_an_index_signature() -> DiagnosticMessage { diag(1071, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_an_index_signature_1071"), String::from("'{0}' modifier cannot appear on an index signature."), None, None, None) }
    pub fn a_0_modifier_cannot_be_used_with_an_import_declaration() -> DiagnosticMessage { diag(1079, DiagnosticCategory::Error, String::from("A_0_modifier_cannot_be_used_with_an_import_declaration_1079"), String::from("A '{0}' modifier cannot be used with an import declaration."), None, None, None) }
    pub fn invalid_reference_directive_syntax() -> DiagnosticMessage { diag(1084, DiagnosticCategory::Error, String::from("Invalid_reference_directive_syntax_1084"), String::from("Invalid 'reference' directive syntax."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_a_constructor_declaration() -> DiagnosticMessage { diag(1089, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_a_constructor_declaration_1089"), String::from("'{0}' modifier cannot appear on a constructor declaration."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_a_parameter() -> DiagnosticMessage { diag(1090, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_a_parameter_1090"), String::from("'{0}' modifier cannot appear on a parameter."), None, None, None) }
    pub fn only_a_single_variable_declaration_is_allowed_in_a_for_in_statement() -> DiagnosticMessage { diag(1091, DiagnosticCategory::Error, String::from("Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091"), String::from("Only a single variable declaration is allowed in a 'for...in' statement."), None, None, None) }
    pub fn type_parameters_cannot_appear_on_a_constructor_declaration() -> DiagnosticMessage { diag(1092, DiagnosticCategory::Error, String::from("Type_parameters_cannot_appear_on_a_constructor_declaration_1092"), String::from("Type parameters cannot appear on a constructor declaration."), None, None, None) }
    pub fn type_annotation_cannot_appear_on_a_constructor_declaration() -> DiagnosticMessage { diag(1093, DiagnosticCategory::Error, String::from("Type_annotation_cannot_appear_on_a_constructor_declaration_1093"), String::from("Type annotation cannot appear on a constructor declaration."), None, None, None) }
    pub fn an_accessor_cannot_have_type_parameters() -> DiagnosticMessage { diag(1094, DiagnosticCategory::Error, String::from("An_accessor_cannot_have_type_parameters_1094"), String::from("An accessor cannot have type parameters."), None, None, None) }
    pub fn a_set_accessor_cannot_have_a_return_type_annotation() -> DiagnosticMessage { diag(1095, DiagnosticCategory::Error, String::from("A_set_accessor_cannot_have_a_return_type_annotation_1095"), String::from("A 'set' accessor cannot have a return type annotation."), None, None, None) }
    pub fn an_index_signature_must_have_exactly_one_parameter() -> DiagnosticMessage { diag(1096, DiagnosticCategory::Error, String::from("An_index_signature_must_have_exactly_one_parameter_1096"), String::from("An index signature must have exactly one parameter."), None, None, None) }
    pub fn _0_list_cannot_be_empty() -> DiagnosticMessage { diag(1097, DiagnosticCategory::Error, String::from("_0_list_cannot_be_empty_1097"), String::from("'{0}' list cannot be empty."), None, None, None) }
    pub fn type_parameter_list_cannot_be_empty() -> DiagnosticMessage { diag(1098, DiagnosticCategory::Error, String::from("Type_parameter_list_cannot_be_empty_1098"), String::from("Type parameter list cannot be empty."), None, None, None) }
    pub fn type_argument_list_cannot_be_empty() -> DiagnosticMessage { diag(1099, DiagnosticCategory::Error, String::from("Type_argument_list_cannot_be_empty_1099"), String::from("Type argument list cannot be empty."), None, None, None) }
    pub fn invalid_use_of_0_in_strict_mode() -> DiagnosticMessage { diag(1100, DiagnosticCategory::Error, String::from("Invalid_use_of_0_in_strict_mode_1100"), String::from("Invalid use of '{0}' in strict mode."), None, None, None) }
    pub fn with_statements_are_not_allowed_in_strict_mode() -> DiagnosticMessage { diag(1101, DiagnosticCategory::Error, String::from("with_statements_are_not_allowed_in_strict_mode_1101"), String::from("'with' statements are not allowed in strict mode."), None, None, None) }
    pub fn delete_cannot_be_called_on_an_identifier_in_strict_mode() -> DiagnosticMessage { diag(1102, DiagnosticCategory::Error, String::from("delete_cannot_be_called_on_an_identifier_in_strict_mode_1102"), String::from("'delete' cannot be called on an identifier in strict mode."), None, None, None) }
    pub fn for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules() -> DiagnosticMessage { diag(1103, DiagnosticCategory::Error, String::from("for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1103"), String::from("'for await' loops are only allowed within async functions and at the top levels of modules."), None, None, None) }
    pub fn a_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement() -> DiagnosticMessage { diag(1104, DiagnosticCategory::Error, String::from("A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104"), String::from("A 'continue' statement can only be used within an enclosing iteration statement."), None, None, None) }
    pub fn a_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement() -> DiagnosticMessage { diag(1105, DiagnosticCategory::Error, String::from("A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105"), String::from("A 'break' statement can only be used within an enclosing iteration or switch statement."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_of_statement_may_not_be_async() -> DiagnosticMessage { diag(1106, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_of_statement_may_not_be_async_1106"), String::from("The left-hand side of a 'for...of' statement may not be 'async'."), None, None, None) }
    pub fn jump_target_cannot_cross_function_boundary() -> DiagnosticMessage { diag(1107, DiagnosticCategory::Error, String::from("Jump_target_cannot_cross_function_boundary_1107"), String::from("Jump target cannot cross function boundary."), None, None, None) }
    pub fn a_return_statement_can_only_be_used_within_a_function_body() -> DiagnosticMessage { diag(1108, DiagnosticCategory::Error, String::from("A_return_statement_can_only_be_used_within_a_function_body_1108"), String::from("A 'return' statement can only be used within a function body."), None, None, None) }
    pub fn expression_expected() -> DiagnosticMessage { diag(1109, DiagnosticCategory::Error, String::from("Expression_expected_1109"), String::from("Expression expected."), None, None, None) }
    pub fn type_expected() -> DiagnosticMessage { diag(1110, DiagnosticCategory::Error, String::from("Type_expected_1110"), String::from("Type expected."), None, None, None) }
    pub fn private_field_0_must_be_declared_in_an_enclosing_class() -> DiagnosticMessage { diag(1111, DiagnosticCategory::Error, String::from("Private_field_0_must_be_declared_in_an_enclosing_class_1111"), String::from("Private field '{0}' must be declared in an enclosing class."), None, None, None) }
    pub fn a_default_clause_cannot_appear_more_than_once_in_a_switch_statement() -> DiagnosticMessage { diag(1113, DiagnosticCategory::Error, String::from("A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113"), String::from("A 'default' clause cannot appear more than once in a 'switch' statement."), None, None, None) }
    pub fn duplicate_label_0() -> DiagnosticMessage { diag(1114, DiagnosticCategory::Error, String::from("Duplicate_label_0_1114"), String::from("Duplicate label '{0}'."), None, None, None) }
    pub fn a_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement() -> DiagnosticMessage { diag(1115, DiagnosticCategory::Error, String::from("A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115"), String::from("A 'continue' statement can only jump to a label of an enclosing iteration statement."), None, None, None) }
    pub fn a_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement() -> DiagnosticMessage { diag(1116, DiagnosticCategory::Error, String::from("A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116"), String::from("A 'break' statement can only jump to a label of an enclosing statement."), None, None, None) }
    pub fn an_object_literal_cannot_have_multiple_properties_with_the_same_name() -> DiagnosticMessage { diag(1117, DiagnosticCategory::Error, String::from("An_object_literal_cannot_have_multiple_properties_with_the_same_name_1117"), String::from("An object literal cannot have multiple properties with the same name."), None, None, None) }
    pub fn an_object_literal_cannot_have_multiple_get_slashset_accessors_with_the_same_name() -> DiagnosticMessage { diag(1118, DiagnosticCategory::Error, String::from("An_object_literal_cannot_have_multiple_get_slashset_accessors_with_the_same_name_1118"), String::from("An object literal cannot have multiple get/set accessors with the same name."), None, None, None) }
    pub fn an_object_literal_cannot_have_property_and_accessor_with_the_same_name() -> DiagnosticMessage { diag(1119, DiagnosticCategory::Error, String::from("An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119"), String::from("An object literal cannot have property and accessor with the same name."), None, None, None) }
    pub fn an_export_assignment_cannot_have_modifiers() -> DiagnosticMessage { diag(1120, DiagnosticCategory::Error, String::from("An_export_assignment_cannot_have_modifiers_1120"), String::from("An export assignment cannot have modifiers."), None, None, None) }
    pub fn octal_literals_are_not_allowed_use_the_syntax_0() -> DiagnosticMessage { diag(1121, DiagnosticCategory::Error, String::from("Octal_literals_are_not_allowed_Use_the_syntax_0_1121"), String::from("Octal literals are not allowed. Use the syntax '{0}'."), None, None, None) }
    pub fn variable_declaration_list_cannot_be_empty() -> DiagnosticMessage { diag(1123, DiagnosticCategory::Error, String::from("Variable_declaration_list_cannot_be_empty_1123"), String::from("Variable declaration list cannot be empty."), None, None, None) }
    pub fn digit_expected() -> DiagnosticMessage { diag(1124, DiagnosticCategory::Error, String::from("Digit_expected_1124"), String::from("Digit expected."), None, None, None) }
    pub fn hexadecimal_digit_expected() -> DiagnosticMessage { diag(1125, DiagnosticCategory::Error, String::from("Hexadecimal_digit_expected_1125"), String::from("Hexadecimal digit expected."), None, None, None) }
    pub fn unexpected_end_of_text() -> DiagnosticMessage { diag(1126, DiagnosticCategory::Error, String::from("Unexpected_end_of_text_1126"), String::from("Unexpected end of text."), None, None, None) }
    pub fn invalid_character() -> DiagnosticMessage { diag(1127, DiagnosticCategory::Error, String::from("Invalid_character_1127"), String::from("Invalid character."), None, None, None) }
    pub fn declaration_or_statement_expected() -> DiagnosticMessage { diag(1128, DiagnosticCategory::Error, String::from("Declaration_or_statement_expected_1128"), String::from("Declaration or statement expected."), None, None, None) }
    pub fn statement_expected() -> DiagnosticMessage { diag(1129, DiagnosticCategory::Error, String::from("Statement_expected_1129"), String::from("Statement expected."), None, None, None) }
    pub fn case_or_default_expected() -> DiagnosticMessage { diag(1130, DiagnosticCategory::Error, String::from("case_or_default_expected_1130"), String::from("'case' or 'default' expected."), None, None, None) }
    pub fn property_or_signature_expected() -> DiagnosticMessage { diag(1131, DiagnosticCategory::Error, String::from("Property_or_signature_expected_1131"), String::from("Property or signature expected."), None, None, None) }
    pub fn enum_member_expected() -> DiagnosticMessage { diag(1132, DiagnosticCategory::Error, String::from("Enum_member_expected_1132"), String::from("Enum member expected."), None, None, None) }
    pub fn variable_declaration_expected() -> DiagnosticMessage { diag(1134, DiagnosticCategory::Error, String::from("Variable_declaration_expected_1134"), String::from("Variable declaration expected."), None, None, None) }
    pub fn argument_expression_expected() -> DiagnosticMessage { diag(1135, DiagnosticCategory::Error, String::from("Argument_expression_expected_1135"), String::from("Argument expression expected."), None, None, None) }
    pub fn property_assignment_expected() -> DiagnosticMessage { diag(1136, DiagnosticCategory::Error, String::from("Property_assignment_expected_1136"), String::from("Property assignment expected."), None, None, None) }
    pub fn expression_or_comma_expected() -> DiagnosticMessage { diag(1137, DiagnosticCategory::Error, String::from("Expression_or_comma_expected_1137"), String::from("Expression or comma expected."), None, None, None) }
    pub fn parameter_declaration_expected() -> DiagnosticMessage { diag(1138, DiagnosticCategory::Error, String::from("Parameter_declaration_expected_1138"), String::from("Parameter declaration expected."), None, None, None) }
    pub fn type_parameter_declaration_expected() -> DiagnosticMessage { diag(1139, DiagnosticCategory::Error, String::from("Type_parameter_declaration_expected_1139"), String::from("Type parameter declaration expected."), None, None, None) }
    pub fn type_argument_expected() -> DiagnosticMessage { diag(1140, DiagnosticCategory::Error, String::from("Type_argument_expected_1140"), String::from("Type argument expected."), None, None, None) }
    pub fn string_literal_expected() -> DiagnosticMessage { diag(1141, DiagnosticCategory::Error, String::from("String_literal_expected_1141"), String::from("String literal expected."), None, None, None) }
    pub fn line_break_not_permitted_here() -> DiagnosticMessage { diag(1142, DiagnosticCategory::Error, String::from("Line_break_not_permitted_here_1142"), String::from("Line break not permitted here."), None, None, None) }
    pub fn or_expected() -> DiagnosticMessage { diag(1144, DiagnosticCategory::Error, String::from("or_expected_1144"), String::from("'{' or ';' expected."), None, None, None) }
    pub fn or_jsx_element_expected() -> DiagnosticMessage { diag(1145, DiagnosticCategory::Error, String::from("or_JSX_element_expected_1145"), String::from("'{' or JSX element expected."), None, None, None) }
    pub fn declaration_expected() -> DiagnosticMessage { diag(1146, DiagnosticCategory::Error, String::from("Declaration_expected_1146"), String::from("Declaration expected."), None, None, None) }
    pub fn import_declarations_in_a_namespace_cannot_reference_a_module() -> DiagnosticMessage { diag(1147, DiagnosticCategory::Error, String::from("Import_declarations_in_a_namespace_cannot_reference_a_module_1147"), String::from("Import declarations in a namespace cannot reference a module."), None, None, None) }
    pub fn cannot_use_imports_exports_or_module_augmentations_when_module_is_none() -> DiagnosticMessage { diag(1148, DiagnosticCategory::Error, String::from("Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148"), String::from("Cannot use imports, exports, or module augmentations when '--module' is 'none'."), None, None, None) }
    pub fn file_name_0_differs_from_already_included_file_name_1_only_in_casing() -> DiagnosticMessage { diag(1149, DiagnosticCategory::Error, String::from("File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149"), String::from("File name '{0}' differs from already included file name '{1}' only in casing."), None, None, None) }
    pub fn _0_declarations_must_be_initialized() -> DiagnosticMessage { diag(1155, DiagnosticCategory::Error, String::from("_0_declarations_must_be_initialized_1155"), String::from("'{0}' declarations must be initialized."), None, None, None) }
    pub fn _0_declarations_can_only_be_declared_inside_a_block() -> DiagnosticMessage { diag(1156, DiagnosticCategory::Error, String::from("_0_declarations_can_only_be_declared_inside_a_block_1156"), String::from("'{0}' declarations can only be declared inside a block."), None, None, None) }
    pub fn unterminated_template_literal() -> DiagnosticMessage { diag(1160, DiagnosticCategory::Error, String::from("Unterminated_template_literal_1160"), String::from("Unterminated template literal."), None, None, None) }
    pub fn unterminated_regular_expression_literal() -> DiagnosticMessage { diag(1161, DiagnosticCategory::Error, String::from("Unterminated_regular_expression_literal_1161"), String::from("Unterminated regular expression literal."), None, None, None) }
    pub fn an_object_member_cannot_be_declared_optional() -> DiagnosticMessage { diag(1162, DiagnosticCategory::Error, String::from("An_object_member_cannot_be_declared_optional_1162"), String::from("An object member cannot be declared optional."), None, None, None) }
    pub fn a_yield_expression_is_only_allowed_in_a_generator_body() -> DiagnosticMessage { diag(1163, DiagnosticCategory::Error, String::from("A_yield_expression_is_only_allowed_in_a_generator_body_1163"), String::from("A 'yield' expression is only allowed in a generator body."), None, None, None) }
    pub fn computed_property_names_are_not_allowed_in_enums() -> DiagnosticMessage { diag(1164, DiagnosticCategory::Error, String::from("Computed_property_names_are_not_allowed_in_enums_1164"), String::from("Computed property names are not allowed in enums."), None, None, None) }
    pub fn a_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type() -> DiagnosticMessage { diag(1165, DiagnosticCategory::Error, String::from("A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_t_1165"), String::from("A computed property name in an ambient context must refer to an expression whose type is a literal type or a 'unique symbol' type."), None, None, None) }
    pub fn a_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type() -> DiagnosticMessage { diag(1166, DiagnosticCategory::Error, String::from("A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_1166"), String::from("A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type."), None, None, None) }
    pub fn a_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type() -> DiagnosticMessage { diag(1168, DiagnosticCategory::Error, String::from("A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_ty_1168"), String::from("A computed property name in a method overload must refer to an expression whose type is a literal type or a 'unique symbol' type."), None, None, None) }
    pub fn a_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type() -> DiagnosticMessage { diag(1169, DiagnosticCategory::Error, String::from("A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_1169"), String::from("A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type."), None, None, None) }
    pub fn a_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type() -> DiagnosticMessage { diag(1170, DiagnosticCategory::Error, String::from("A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type__1170"), String::from("A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type."), None, None, None) }
    pub fn a_comma_expression_is_not_allowed_in_a_computed_property_name() -> DiagnosticMessage { diag(1171, DiagnosticCategory::Error, String::from("A_comma_expression_is_not_allowed_in_a_computed_property_name_1171"), String::from("A comma expression is not allowed in a computed property name."), None, None, None) }
    pub fn extends_clause_already_seen() -> DiagnosticMessage { diag(1172, DiagnosticCategory::Error, String::from("extends_clause_already_seen_1172"), String::from("'extends' clause already seen."), None, None, None) }
    pub fn extends_clause_must_precede_implements_clause() -> DiagnosticMessage { diag(1173, DiagnosticCategory::Error, String::from("extends_clause_must_precede_implements_clause_1173"), String::from("'extends' clause must precede 'implements' clause."), None, None, None) }
    pub fn classes_can_only_extend_a_single_class() -> DiagnosticMessage { diag(1174, DiagnosticCategory::Error, String::from("Classes_can_only_extend_a_single_class_1174"), String::from("Classes can only extend a single class."), None, None, None) }
    pub fn implements_clause_already_seen() -> DiagnosticMessage { diag(1175, DiagnosticCategory::Error, String::from("implements_clause_already_seen_1175"), String::from("'implements' clause already seen."), None, None, None) }
    pub fn interface_declaration_cannot_have_implements_clause() -> DiagnosticMessage { diag(1176, DiagnosticCategory::Error, String::from("Interface_declaration_cannot_have_implements_clause_1176"), String::from("Interface declaration cannot have 'implements' clause."), None, None, None) }
    pub fn binary_digit_expected() -> DiagnosticMessage { diag(1177, DiagnosticCategory::Error, String::from("Binary_digit_expected_1177"), String::from("Binary digit expected."), None, None, None) }
    pub fn octal_digit_expected() -> DiagnosticMessage { diag(1178, DiagnosticCategory::Error, String::from("Octal_digit_expected_1178"), String::from("Octal digit expected."), None, None, None) }
    pub fn unexpected_token_expected() -> DiagnosticMessage { diag(1179, DiagnosticCategory::Error, String::from("Unexpected_token_expected_1179"), String::from("Unexpected token. '{' expected."), None, None, None) }
    pub fn property_destructuring_pattern_expected() -> DiagnosticMessage { diag(1180, DiagnosticCategory::Error, String::from("Property_destructuring_pattern_expected_1180"), String::from("Property destructuring pattern expected."), None, None, None) }
    pub fn array_element_destructuring_pattern_expected() -> DiagnosticMessage { diag(1181, DiagnosticCategory::Error, String::from("Array_element_destructuring_pattern_expected_1181"), String::from("Array element destructuring pattern expected."), None, None, None) }
    pub fn a_destructuring_declaration_must_have_an_initializer() -> DiagnosticMessage { diag(1182, DiagnosticCategory::Error, String::from("A_destructuring_declaration_must_have_an_initializer_1182"), String::from("A destructuring declaration must have an initializer."), None, None, None) }
    pub fn an_implementation_cannot_be_declared_in_ambient_contexts() -> DiagnosticMessage { diag(1183, DiagnosticCategory::Error, String::from("An_implementation_cannot_be_declared_in_ambient_contexts_1183"), String::from("An implementation cannot be declared in ambient contexts."), None, None, None) }
    pub fn modifiers_cannot_appear_here() -> DiagnosticMessage { diag(1184, DiagnosticCategory::Error, String::from("Modifiers_cannot_appear_here_1184"), String::from("Modifiers cannot appear here."), None, None, None) }
    pub fn merge_conflict_marker_encountered() -> DiagnosticMessage { diag(1185, DiagnosticCategory::Error, String::from("Merge_conflict_marker_encountered_1185"), String::from("Merge conflict marker encountered."), None, None, None) }
    pub fn a_rest_element_cannot_have_an_initializer() -> DiagnosticMessage { diag(1186, DiagnosticCategory::Error, String::from("A_rest_element_cannot_have_an_initializer_1186"), String::from("A rest element cannot have an initializer."), None, None, None) }
    pub fn a_parameter_property_may_not_be_declared_using_a_binding_pattern() -> DiagnosticMessage { diag(1187, DiagnosticCategory::Error, String::from("A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187"), String::from("A parameter property may not be declared using a binding pattern."), None, None, None) }
    pub fn only_a_single_variable_declaration_is_allowed_in_a_for_of_statement() -> DiagnosticMessage { diag(1188, DiagnosticCategory::Error, String::from("Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188"), String::from("Only a single variable declaration is allowed in a 'for...of' statement."), None, None, None) }
    pub fn the_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer() -> DiagnosticMessage { diag(1189, DiagnosticCategory::Error, String::from("The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189"), String::from("The variable declaration of a 'for...in' statement cannot have an initializer."), None, None, None) }
    pub fn the_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer() -> DiagnosticMessage { diag(1190, DiagnosticCategory::Error, String::from("The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190"), String::from("The variable declaration of a 'for...of' statement cannot have an initializer."), None, None, None) }
    pub fn an_import_declaration_cannot_have_modifiers() -> DiagnosticMessage { diag(1191, DiagnosticCategory::Error, String::from("An_import_declaration_cannot_have_modifiers_1191"), String::from("An import declaration cannot have modifiers."), None, None, None) }
    pub fn module_0_has_no_default_export() -> DiagnosticMessage { diag(1192, DiagnosticCategory::Error, String::from("Module_0_has_no_default_export_1192"), String::from("Module '{0}' has no default export."), None, None, None) }
    pub fn an_export_declaration_cannot_have_modifiers() -> DiagnosticMessage { diag(1193, DiagnosticCategory::Error, String::from("An_export_declaration_cannot_have_modifiers_1193"), String::from("An export declaration cannot have modifiers."), None, None, None) }
    pub fn export_declarations_are_not_permitted_in_a_namespace() -> DiagnosticMessage { diag(1194, DiagnosticCategory::Error, String::from("Export_declarations_are_not_permitted_in_a_namespace_1194"), String::from("Export declarations are not permitted in a namespace."), None, None, None) }
    pub fn export_asterisk_does_not_re_export_a_default() -> DiagnosticMessage { diag(1195, DiagnosticCategory::Error, String::from("export_asterisk_does_not_re_export_a_default_1195"), String::from("'export *' does not re-export a default."), None, None, None) }
    pub fn catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified() -> DiagnosticMessage { diag(1196, DiagnosticCategory::Error, String::from("Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified_1196"), String::from("Catch clause variable type annotation must be 'any' or 'unknown' if specified."), None, None, None) }
    pub fn catch_clause_variable_cannot_have_an_initializer() -> DiagnosticMessage { diag(1197, DiagnosticCategory::Error, String::from("Catch_clause_variable_cannot_have_an_initializer_1197"), String::from("Catch clause variable cannot have an initializer."), None, None, None) }
    pub fn an_extended_unicode_escape_value_must_be_between_0x0_and_0x10ffff_inclusive() -> DiagnosticMessage { diag(1198, DiagnosticCategory::Error, String::from("An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198"), String::from("An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive."), None, None, None) }
    pub fn unterminated_unicode_escape_sequence() -> DiagnosticMessage { diag(1199, DiagnosticCategory::Error, String::from("Unterminated_Unicode_escape_sequence_1199"), String::from("Unterminated Unicode escape sequence."), None, None, None) }
    pub fn line_terminator_not_permitted_before_arrow() -> DiagnosticMessage { diag(1200, DiagnosticCategory::Error, String::from("Line_terminator_not_permitted_before_arrow_1200"), String::from("Line terminator not permitted before arrow."), None, None, None) }
    pub fn import_assignment_cannot_be_used_when_targeting_ecmascript_modules_consider_using_import_asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead() -> DiagnosticMessage { diag(1202, DiagnosticCategory::Error, String::from("Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_asterisk_as_1202"), String::from("Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"', 'import d from \"mod\"', or another module format instead."), None, None, None) }
    pub fn export_assignment_cannot_be_used_when_targeting_ecmascript_modules_consider_using_export_default_or_another_module_format_instead() -> DiagnosticMessage { diag(1203, DiagnosticCategory::Error, String::from("Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203"), String::from("Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead."), None, None, None) }
    pub fn re_exporting_a_type_when_0_is_enabled_requires_using_export_type() -> DiagnosticMessage { diag(1205, DiagnosticCategory::Error, String::from("Re_exporting_a_type_when_0_is_enabled_requires_using_export_type_1205"), String::from("Re-exporting a type when '{0}' is enabled requires using 'export type'."), None, None, None) }
    pub fn decorators_are_not_valid_here() -> DiagnosticMessage { diag(1206, DiagnosticCategory::Error, String::from("Decorators_are_not_valid_here_1206"), String::from("Decorators are not valid here."), None, None, None) }
    pub fn decorators_cannot_be_applied_to_multiple_get_slashset_accessors_of_the_same_name() -> DiagnosticMessage { diag(1207, DiagnosticCategory::Error, String::from("Decorators_cannot_be_applied_to_multiple_get_slashset_accessors_of_the_same_name_1207"), String::from("Decorators cannot be applied to multiple get/set accessors of the same name."), None, None, None) }
    pub fn invalid_optional_chain_from_new_expression_did_you_mean_to_call_0() -> DiagnosticMessage { diag(1209, DiagnosticCategory::Error, String::from("Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0_1209"), String::from("Invalid optional chain from new expression. Did you mean to call '{0}()'?"), None, None, None) }
    pub fn code_contained_in_a_class_is_evaluated_in_javascript_s_strict_mode_which_does_not_allow_this_use_of_0_for_more_information_see_https_colon_slash_slashdeveloper_mozilla_org_slashen_us_slashdocs_slashweb_slashjavascript_slashreference_slashstrict_mode() -> DiagnosticMessage { diag(1210, DiagnosticCategory::Error, String::from("Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of__1210"), String::from("Code contained in a class is evaluated in JavaScript's strict mode which does not allow this use of '{0}'. For more information, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode."), None, None, None) }
    pub fn a_class_declaration_without_the_default_modifier_must_have_a_name() -> DiagnosticMessage { diag(1211, DiagnosticCategory::Error, String::from("A_class_declaration_without_the_default_modifier_must_have_a_name_1211"), String::from("A class declaration without the 'default' modifier must have a name."), None, None, None) }
    pub fn identifier_expected_0_is_a_reserved_word_in_strict_mode() -> DiagnosticMessage { diag(1212, DiagnosticCategory::Error, String::from("Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212"), String::from("Identifier expected. '{0}' is a reserved word in strict mode."), None, None, None) }
    pub fn identifier_expected_0_is_a_reserved_word_in_strict_mode_class_definitions_are_automatically_in_strict_mode() -> DiagnosticMessage { diag(1213, DiagnosticCategory::Error, String::from("Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213"), String::from("Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode."), None, None, None) }
    pub fn identifier_expected_0_is_a_reserved_word_in_strict_mode_modules_are_automatically_in_strict_mode() -> DiagnosticMessage { diag(1214, DiagnosticCategory::Error, String::from("Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214"), String::from("Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode."), None, None, None) }
    pub fn invalid_use_of_0_modules_are_automatically_in_strict_mode() -> DiagnosticMessage { diag(1215, DiagnosticCategory::Error, String::from("Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215"), String::from("Invalid use of '{0}'. Modules are automatically in strict mode."), None, None, None) }
    pub fn identifier_expected_esmodule_is_reserved_as_an_exported_marker_when_transforming_ecmascript_modules() -> DiagnosticMessage { diag(1216, DiagnosticCategory::Error, String::from("Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216"), String::from("Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules."), None, None, None) }
    pub fn export_assignment_is_not_supported_when_module_flag_is_system() -> DiagnosticMessage { diag(1218, DiagnosticCategory::Error, String::from("Export_assignment_is_not_supported_when_module_flag_is_system_1218"), String::from("Export assignment is not supported when '--module' flag is 'system'."), None, None, None) }
    pub fn generators_are_not_allowed_in_an_ambient_context() -> DiagnosticMessage { diag(1221, DiagnosticCategory::Error, String::from("Generators_are_not_allowed_in_an_ambient_context_1221"), String::from("Generators are not allowed in an ambient context."), None, None, None) }
    pub fn an_overload_signature_cannot_be_declared_as_a_generator() -> DiagnosticMessage { diag(1222, DiagnosticCategory::Error, String::from("An_overload_signature_cannot_be_declared_as_a_generator_1222"), String::from("An overload signature cannot be declared as a generator."), None, None, None) }
    pub fn _0_tag_already_specified() -> DiagnosticMessage { diag(1223, DiagnosticCategory::Error, String::from("_0_tag_already_specified_1223"), String::from("'{0}' tag already specified."), None, None, None) }
    pub fn signature_0_must_be_a_type_predicate() -> DiagnosticMessage { diag(1224, DiagnosticCategory::Error, String::from("Signature_0_must_be_a_type_predicate_1224"), String::from("Signature '{0}' must be a type predicate."), None, None, None) }
    pub fn cannot_find_parameter_0() -> DiagnosticMessage { diag(1225, DiagnosticCategory::Error, String::from("Cannot_find_parameter_0_1225"), String::from("Cannot find parameter '{0}'."), None, None, None) }
    pub fn type_predicate_0_is_not_assignable_to_1() -> DiagnosticMessage { diag(1226, DiagnosticCategory::Error, String::from("Type_predicate_0_is_not_assignable_to_1_1226"), String::from("Type predicate '{0}' is not assignable to '{1}'."), None, None, None) }
    pub fn parameter_0_is_not_in_the_same_position_as_parameter_1() -> DiagnosticMessage { diag(1227, DiagnosticCategory::Error, String::from("Parameter_0_is_not_in_the_same_position_as_parameter_1_1227"), String::from("Parameter '{0}' is not in the same position as parameter '{1}'."), None, None, None) }
    pub fn a_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods() -> DiagnosticMessage { diag(1228, DiagnosticCategory::Error, String::from("A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228"), String::from("A type predicate is only allowed in return type position for functions and methods."), None, None, None) }
    pub fn a_type_predicate_cannot_reference_a_rest_parameter() -> DiagnosticMessage { diag(1229, DiagnosticCategory::Error, String::from("A_type_predicate_cannot_reference_a_rest_parameter_1229"), String::from("A type predicate cannot reference a rest parameter."), None, None, None) }
    pub fn a_type_predicate_cannot_reference_element_0_in_a_binding_pattern() -> DiagnosticMessage { diag(1230, DiagnosticCategory::Error, String::from("A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230"), String::from("A type predicate cannot reference element '{0}' in a binding pattern."), None, None, None) }
    pub fn an_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration() -> DiagnosticMessage { diag(1231, DiagnosticCategory::Error, String::from("An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration_1231"), String::from("An export assignment must be at the top level of a file or module declaration."), None, None, None) }
    pub fn an_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module() -> DiagnosticMessage { diag(1232, DiagnosticCategory::Error, String::from("An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1232"), String::from("An import declaration can only be used at the top level of a namespace or module."), None, None, None) }
    pub fn an_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module() -> DiagnosticMessage { diag(1233, DiagnosticCategory::Error, String::from("An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1233"), String::from("An export declaration can only be used at the top level of a namespace or module."), None, None, None) }
    pub fn an_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file() -> DiagnosticMessage { diag(1234, DiagnosticCategory::Error, String::from("An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234"), String::from("An ambient module declaration is only allowed at the top level in a file."), None, None, None) }
    pub fn a_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module() -> DiagnosticMessage { diag(1235, DiagnosticCategory::Error, String::from("A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module_1235"), String::from("A namespace declaration is only allowed at the top level of a namespace or module."), None, None, None) }
    pub fn the_return_type_of_a_property_decorator_function_must_be_either_void_or_any() -> DiagnosticMessage { diag(1236, DiagnosticCategory::Error, String::from("The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236"), String::from("The return type of a property decorator function must be either 'void' or 'any'."), None, None, None) }
    pub fn the_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any() -> DiagnosticMessage { diag(1237, DiagnosticCategory::Error, String::from("The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237"), String::from("The return type of a parameter decorator function must be either 'void' or 'any'."), None, None, None) }
    pub fn unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression() -> DiagnosticMessage { diag(1238, DiagnosticCategory::Error, String::from("Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238"), String::from("Unable to resolve signature of class decorator when called as an expression."), None, None, None) }
    pub fn unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression() -> DiagnosticMessage { diag(1239, DiagnosticCategory::Error, String::from("Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239"), String::from("Unable to resolve signature of parameter decorator when called as an expression."), None, None, None) }
    pub fn unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression() -> DiagnosticMessage { diag(1240, DiagnosticCategory::Error, String::from("Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240"), String::from("Unable to resolve signature of property decorator when called as an expression."), None, None, None) }
    pub fn unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression() -> DiagnosticMessage { diag(1241, DiagnosticCategory::Error, String::from("Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241"), String::from("Unable to resolve signature of method decorator when called as an expression."), None, None, None) }
    pub fn abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration() -> DiagnosticMessage { diag(1242, DiagnosticCategory::Error, String::from("abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242"), String::from("'abstract' modifier can only appear on a class, method, or property declaration."), None, None, None) }
    pub fn _0_modifier_cannot_be_used_with_1_modifier() -> DiagnosticMessage { diag(1243, DiagnosticCategory::Error, String::from("_0_modifier_cannot_be_used_with_1_modifier_1243"), String::from("'{0}' modifier cannot be used with '{1}' modifier."), None, None, None) }
    pub fn abstract_methods_can_only_appear_within_an_abstract_class() -> DiagnosticMessage { diag(1244, DiagnosticCategory::Error, String::from("Abstract_methods_can_only_appear_within_an_abstract_class_1244"), String::from("Abstract methods can only appear within an abstract class."), None, None, None) }
    pub fn method_0_cannot_have_an_implementation_because_it_is_marked_abstract() -> DiagnosticMessage { diag(1245, DiagnosticCategory::Error, String::from("Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245"), String::from("Method '{0}' cannot have an implementation because it is marked abstract."), None, None, None) }
    pub fn an_interface_property_cannot_have_an_initializer() -> DiagnosticMessage { diag(1246, DiagnosticCategory::Error, String::from("An_interface_property_cannot_have_an_initializer_1246"), String::from("An interface property cannot have an initializer."), None, None, None) }
    pub fn a_type_literal_property_cannot_have_an_initializer() -> DiagnosticMessage { diag(1247, DiagnosticCategory::Error, String::from("A_type_literal_property_cannot_have_an_initializer_1247"), String::from("A type literal property cannot have an initializer."), None, None, None) }
    pub fn a_class_member_cannot_have_the_0_keyword() -> DiagnosticMessage { diag(1248, DiagnosticCategory::Error, String::from("A_class_member_cannot_have_the_0_keyword_1248"), String::from("A class member cannot have the '{0}' keyword."), None, None, None) }
    pub fn a_decorator_can_only_decorate_a_method_implementation_not_an_overload() -> DiagnosticMessage { diag(1249, DiagnosticCategory::Error, String::from("A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249"), String::from("A decorator can only decorate a method implementation, not an overload."), None, None, None) }
    pub fn function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_es5() -> DiagnosticMessage { diag(1250, DiagnosticCategory::Error, String::from("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_1250"), String::from("Function declarations are not allowed inside blocks in strict mode when targeting 'ES5'."), None, None, None) }
    pub fn function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_es5_class_definitions_are_automatically_in_strict_mode() -> DiagnosticMessage { diag(1251, DiagnosticCategory::Error, String::from("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_Class_definiti_1251"), String::from("Function declarations are not allowed inside blocks in strict mode when targeting 'ES5'. Class definitions are automatically in strict mode."), None, None, None) }
    pub fn function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_es5_modules_are_automatically_in_strict_mode() -> DiagnosticMessage { diag(1252, DiagnosticCategory::Error, String::from("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_Modules_are_au_1252"), String::from("Function declarations are not allowed inside blocks in strict mode when targeting 'ES5'. Modules are automatically in strict mode."), None, None, None) }
    pub fn abstract_properties_can_only_appear_within_an_abstract_class() -> DiagnosticMessage { diag(1253, DiagnosticCategory::Error, String::from("Abstract_properties_can_only_appear_within_an_abstract_class_1253"), String::from("Abstract properties can only appear within an abstract class."), None, None, None) }
    pub fn a_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference() -> DiagnosticMessage { diag(1254, DiagnosticCategory::Error, String::from("A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_refere_1254"), String::from("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."), None, None, None) }
    pub fn a_definite_assignment_assertion_is_not_permitted_in_this_context() -> DiagnosticMessage { diag(1255, DiagnosticCategory::Error, String::from("A_definite_assignment_assertion_is_not_permitted_in_this_context_1255"), String::from("A definite assignment assertion '!' is not permitted in this context."), None, None, None) }
    pub fn a_required_element_cannot_follow_an_optional_element() -> DiagnosticMessage { diag(1257, DiagnosticCategory::Error, String::from("A_required_element_cannot_follow_an_optional_element_1257"), String::from("A required element cannot follow an optional element."), None, None, None) }
    pub fn a_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration() -> DiagnosticMessage { diag(1258, DiagnosticCategory::Error, String::from("A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration_1258"), String::from("A default export must be at the top level of a file or module declaration."), None, None, None) }
    pub fn module_0_can_only_be_default_imported_using_the_1_flag() -> DiagnosticMessage { diag(1259, DiagnosticCategory::Error, String::from("Module_0_can_only_be_default_imported_using_the_1_flag_1259"), String::from("Module '{0}' can only be default-imported using the '{1}' flag"), None, None, None) }
    pub fn keywords_cannot_contain_escape_characters() -> DiagnosticMessage { diag(1260, DiagnosticCategory::Error, String::from("Keywords_cannot_contain_escape_characters_1260"), String::from("Keywords cannot contain escape characters."), None, None, None) }
    pub fn already_included_file_name_0_differs_from_file_name_1_only_in_casing() -> DiagnosticMessage { diag(1261, DiagnosticCategory::Error, String::from("Already_included_file_name_0_differs_from_file_name_1_only_in_casing_1261"), String::from("Already included file name '{0}' differs from file name '{1}' only in casing."), None, None, None) }
    pub fn identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module() -> DiagnosticMessage { diag(1262, DiagnosticCategory::Error, String::from("Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module_1262"), String::from("Identifier expected. '{0}' is a reserved word at the top-level of a module."), None, None, None) }
    pub fn declarations_with_initializers_cannot_also_have_definite_assignment_assertions() -> DiagnosticMessage { diag(1263, DiagnosticCategory::Error, String::from("Declarations_with_initializers_cannot_also_have_definite_assignment_assertions_1263"), String::from("Declarations with initializers cannot also have definite assignment assertions."), None, None, None) }
    pub fn declarations_with_definite_assignment_assertions_must_also_have_type_annotations() -> DiagnosticMessage { diag(1264, DiagnosticCategory::Error, String::from("Declarations_with_definite_assignment_assertions_must_also_have_type_annotations_1264"), String::from("Declarations with definite assignment assertions must also have type annotations."), None, None, None) }
    pub fn a_rest_element_cannot_follow_another_rest_element() -> DiagnosticMessage { diag(1265, DiagnosticCategory::Error, String::from("A_rest_element_cannot_follow_another_rest_element_1265"), String::from("A rest element cannot follow another rest element."), None, None, None) }
    pub fn an_optional_element_cannot_follow_a_rest_element() -> DiagnosticMessage { diag(1266, DiagnosticCategory::Error, String::from("An_optional_element_cannot_follow_a_rest_element_1266"), String::from("An optional element cannot follow a rest element."), None, None, None) }
    pub fn property_0_cannot_have_an_initializer_because_it_is_marked_abstract() -> DiagnosticMessage { diag(1267, DiagnosticCategory::Error, String::from("Property_0_cannot_have_an_initializer_because_it_is_marked_abstract_1267"), String::from("Property '{0}' cannot have an initializer because it is marked abstract."), None, None, None) }
    pub fn an_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type() -> DiagnosticMessage { diag(1268, DiagnosticCategory::Error, String::from("An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type_1268"), String::from("An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type."), None, None, None) }
    pub fn cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled() -> DiagnosticMessage { diag(1269, DiagnosticCategory::Error, String::from("Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled_1269"), String::from("Cannot use 'export import' on a type or type-only namespace when '{0}' is enabled."), None, None, None) }
    pub fn decorator_function_return_type_0_is_not_assignable_to_type_1() -> DiagnosticMessage { diag(1270, DiagnosticCategory::Error, String::from("Decorator_function_return_type_0_is_not_assignable_to_type_1_1270"), String::from("Decorator function return type '{0}' is not assignable to type '{1}'."), None, None, None) }
    pub fn decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any() -> DiagnosticMessage { diag(1271, DiagnosticCategory::Error, String::from("Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any_1271"), String::from("Decorator function return type is '{0}' but is expected to be 'void' or 'any'."), None, None, None) }
    pub fn a_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedmodules_and_emitdecoratormetadata_are_enabled() -> DiagnosticMessage { diag(1272, DiagnosticCategory::Error, String::from("A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_w_1272"), String::from("A type referenced in a decorated signature must be imported with 'import type' or a namespace import when 'isolatedModules' and 'emitDecoratorMetadata' are enabled."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_a_type_parameter() -> DiagnosticMessage { diag(1273, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_a_type_parameter_1273"), String::from("'{0}' modifier cannot appear on a type parameter"), None, None, None) }
    pub fn _0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias() -> DiagnosticMessage { diag(1274, DiagnosticCategory::Error, String::from("_0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias_1274"), String::from("'{0}' modifier can only appear on a type parameter of a class, interface or type alias"), None, None, None) }
    pub fn accessor_modifier_can_only_appear_on_a_property_declaration() -> DiagnosticMessage { diag(1275, DiagnosticCategory::Error, String::from("accessor_modifier_can_only_appear_on_a_property_declaration_1275"), String::from("'accessor' modifier can only appear on a property declaration."), None, None, None) }
    pub fn an_accessor_property_cannot_be_declared_optional() -> DiagnosticMessage { diag(1276, DiagnosticCategory::Error, String::from("An_accessor_property_cannot_be_declared_optional_1276"), String::from("An 'accessor' property cannot be declared optional."), None, None, None) }
    pub fn _0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class() -> DiagnosticMessage { diag(1277, DiagnosticCategory::Error, String::from("_0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class_1277"), String::from("'{0}' modifier can only appear on a type parameter of a function, method or class"), None, None, None) }
    pub fn the_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0() -> DiagnosticMessage { diag(1278, DiagnosticCategory::Error, String::from("The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0_1278"), String::from("The runtime will invoke the decorator with {1} arguments, but the decorator expects {0}."), None, None, None) }
    pub fn the_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0() -> DiagnosticMessage { diag(1279, DiagnosticCategory::Error, String::from("The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0_1279"), String::from("The runtime will invoke the decorator with {1} arguments, but the decorator expects at least {0}."), None, None, None) }
    pub fn namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_if_this_file_is_not_intended_to_be_a_global_script_set_moduledetection_to_force_or_add_an_empty_export_statement() -> DiagnosticMessage { diag(1280, DiagnosticCategory::Error, String::from("Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to__1280"), String::from("Namespaces are not allowed in global script files when '{0}' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement."), None, None, None) }
    pub fn cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_use_2_instead() -> DiagnosticMessage { diag(1281, DiagnosticCategory::Error, String::from("Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead_1281"), String::from("Cannot access '{0}' from another file without qualification when '{1}' is enabled. Use '{2}' instead."), None, None, None) }
    pub fn an_export_declaration_must_reference_a_value_when_verbatimmodulesyntax_is_enabled_but_0_only_refers_to_a_type() -> DiagnosticMessage { diag(1282, DiagnosticCategory::Error, String::from("An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers__1282"), String::from("An 'export =' declaration must reference a value when 'verbatimModuleSyntax' is enabled, but '{0}' only refers to a type."), None, None, None) }
    pub fn an_export_declaration_must_reference_a_real_value_when_verbatimmodulesyntax_is_enabled_but_0_resolves_to_a_type_only_declaration() -> DiagnosticMessage { diag(1283, DiagnosticCategory::Error, String::from("An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolve_1283"), String::from("An 'export =' declaration must reference a real value when 'verbatimModuleSyntax' is enabled, but '{0}' resolves to a type-only declaration."), None, None, None) }
    pub fn an_export_default_must_reference_a_value_when_verbatimmodulesyntax_is_enabled_but_0_only_refers_to_a_type() -> DiagnosticMessage { diag(1284, DiagnosticCategory::Error, String::from("An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_1284"), String::from("An 'export default' must reference a value when 'verbatimModuleSyntax' is enabled, but '{0}' only refers to a type."), None, None, None) }
    pub fn an_export_default_must_reference_a_real_value_when_verbatimmodulesyntax_is_enabled_but_0_resolves_to_a_type_only_declaration() -> DiagnosticMessage { diag(1285, DiagnosticCategory::Error, String::from("An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_1285"), String::from("An 'export default' must reference a real value when 'verbatimModuleSyntax' is enabled, but '{0}' resolves to a type-only declaration."), None, None, None) }
    pub fn esm_syntax_is_not_allowed_in_a_commonjs_module_when_verbatimmodulesyntax_is_enabled() -> DiagnosticMessage { diag(1286, DiagnosticCategory::Error, String::from("ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled_1286"), String::from("ESM syntax is not allowed in a CommonJS module when 'verbatimModuleSyntax' is enabled."), None, None, None) }
    pub fn a_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_commonjs_module_when_verbatimmodulesyntax_is_enabled() -> DiagnosticMessage { diag(1287, DiagnosticCategory::Error, String::from("A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimM_1287"), String::from("A top-level 'export' modifier cannot be used on value declarations in a CommonJS module when 'verbatimModuleSyntax' is enabled."), None, None, None) }
    pub fn an_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimmodulesyntax_is_enabled() -> DiagnosticMessage { diag(1288, DiagnosticCategory::Error, String::from("An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabl_1288"), String::from("An import alias cannot resolve to a type or type-only declaration when 'verbatimModuleSyntax' is enabled."), None, None, None) }
    pub fn _0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_consider_using_import_type_where_0_is_imported() -> DiagnosticMessage { diag(1289, DiagnosticCategory::Error, String::from("_0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_1289"), String::from("'{0}' resolves to a type-only declaration and must be marked type-only in this file before re-exporting when '{1}' is enabled. Consider using 'import type' where '{0}' is imported."), None, None, None) }
    pub fn _0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_consider_using_export_type_0_as_default() -> DiagnosticMessage { diag(1290, DiagnosticCategory::Error, String::from("_0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_1290"), String::from("'{0}' resolves to a type-only declaration and must be marked type-only in this file before re-exporting when '{1}' is enabled. Consider using 'export type { {0} as default }'."), None, None, None) }
    pub fn _0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_consider_using_import_type_where_0_is_imported() -> DiagnosticMessage { diag(1291, DiagnosticCategory::Error, String::from("_0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enable_1291"), String::from("'{0}' resolves to a type and must be marked type-only in this file before re-exporting when '{1}' is enabled. Consider using 'import type' where '{0}' is imported."), None, None, None) }
    pub fn _0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_consider_using_export_type_0_as_default() -> DiagnosticMessage { diag(1292, DiagnosticCategory::Error, String::from("_0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enable_1292"), String::from("'{0}' resolves to a type and must be marked type-only in this file before re-exporting when '{1}' is enabled. Consider using 'export type { {0} as default }'."), None, None, None) }
    pub fn esm_syntax_is_not_allowed_in_a_commonjs_module_when_module_is_set_to_preserve() -> DiagnosticMessage { diag(1293, DiagnosticCategory::Error, String::from("ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve_1293"), String::from("ESM syntax is not allowed in a CommonJS module when 'module' is set to 'preserve'."), None, None, None) }
    pub fn with_statements_are_not_allowed_in_an_async_function_block() -> DiagnosticMessage { diag(1300, DiagnosticCategory::Error, String::from("with_statements_are_not_allowed_in_an_async_function_block_1300"), String::from("'with' statements are not allowed in an async function block."), None, None, None) }
    pub fn await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules() -> DiagnosticMessage { diag(1308, DiagnosticCategory::Error, String::from("await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1308"), String::from("'await' expressions are only allowed within async functions and at the top levels of modules."), None, None, None) }
    pub fn the_current_file_is_a_commonjs_module_and_cannot_use_await_at_the_top_level() -> DiagnosticMessage { diag(1309, DiagnosticCategory::Error, String::from("The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level_1309"), String::from("The current file is a CommonJS module and cannot use 'await' at the top level."), None, None, None) }
    pub fn did_you_mean_to_use_a_colon_an_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern() -> DiagnosticMessage { diag(1312, DiagnosticCategory::Error, String::from("Did_you_mean_to_use_a_colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_1312"), String::from("Did you mean to use a ':'? An '=' can only follow a property name when the containing object literal is part of a destructuring pattern."), None, None, None) }
    pub fn the_body_of_an_if_statement_cannot_be_the_empty_statement() -> DiagnosticMessage { diag(1313, DiagnosticCategory::Error, String::from("The_body_of_an_if_statement_cannot_be_the_empty_statement_1313"), String::from("The body of an 'if' statement cannot be the empty statement."), None, None, None) }
    pub fn global_module_exports_may_only_appear_in_module_files() -> DiagnosticMessage { diag(1314, DiagnosticCategory::Error, String::from("Global_module_exports_may_only_appear_in_module_files_1314"), String::from("Global module exports may only appear in module files."), None, None, None) }
    pub fn global_module_exports_may_only_appear_in_declaration_files() -> DiagnosticMessage { diag(1315, DiagnosticCategory::Error, String::from("Global_module_exports_may_only_appear_in_declaration_files_1315"), String::from("Global module exports may only appear in declaration files."), None, None, None) }
    pub fn global_module_exports_may_only_appear_at_top_level() -> DiagnosticMessage { diag(1316, DiagnosticCategory::Error, String::from("Global_module_exports_may_only_appear_at_top_level_1316"), String::from("Global module exports may only appear at top level."), None, None, None) }
    pub fn a_parameter_property_cannot_be_declared_using_a_rest_parameter() -> DiagnosticMessage { diag(1317, DiagnosticCategory::Error, String::from("A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317"), String::from("A parameter property cannot be declared using a rest parameter."), None, None, None) }
    pub fn an_abstract_accessor_cannot_have_an_implementation() -> DiagnosticMessage { diag(1318, DiagnosticCategory::Error, String::from("An_abstract_accessor_cannot_have_an_implementation_1318"), String::from("An abstract accessor cannot have an implementation."), None, None, None) }
    pub fn a_default_export_can_only_be_used_in_an_ecmascript_style_module() -> DiagnosticMessage { diag(1319, DiagnosticCategory::Error, String::from("A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319"), String::from("A default export can only be used in an ECMAScript-style module."), None, None, None) }
    pub fn type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member() -> DiagnosticMessage { diag(1320, DiagnosticCategory::Error, String::from("Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320"), String::from("Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member."), None, None, None) }
    pub fn type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member() -> DiagnosticMessage { diag(1321, DiagnosticCategory::Error, String::from("Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321"), String::from("Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member."), None, None, None) }
    pub fn type_of_iterated_elements_of_a_yield_asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member() -> DiagnosticMessage { diag(1322, DiagnosticCategory::Error, String::from("Type_of_iterated_elements_of_a_yield_asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322"), String::from("Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member."), None, None, None) }
    pub fn dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext() -> DiagnosticMessage { diag(1323, DiagnosticCategory::Error, String::from("Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd__1323"), String::from("Dynamic imports are only supported when the '--module' flag is set to 'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', or 'nodenext'."), None, None, None) }
    pub fn dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodenext_or_preserve() -> DiagnosticMessage { diag(1324, DiagnosticCategory::Error, String::from("Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodene_1324"), String::from("Dynamic imports only support a second argument when the '--module' option is set to 'esnext', 'node16', 'nodenext', or 'preserve'."), None, None, None) }
    pub fn argument_of_dynamic_import_cannot_be_spread_element() -> DiagnosticMessage { diag(1325, DiagnosticCategory::Error, String::from("Argument_of_dynamic_import_cannot_be_spread_element_1325"), String::from("Argument of dynamic import cannot be spread element."), None, None, None) }
    pub fn this_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments() -> DiagnosticMessage { diag(1326, DiagnosticCategory::Error, String::from("This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot__1326"), String::from("This use of 'import' is invalid. 'import()' calls can be written, but they must have parentheses and cannot have type arguments."), None, None, None) }
    pub fn string_literal_with_double_quotes_expected() -> DiagnosticMessage { diag(1327, DiagnosticCategory::Error, String::from("String_literal_with_double_quotes_expected_1327"), String::from("String literal with double quotes expected."), None, None, None) }
    pub fn property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal() -> DiagnosticMessage { diag(1328, DiagnosticCategory::Error, String::from("Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328"), String::from("Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal."), None, None, None) }
    pub fn _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_did_you_mean_to_call_it_first_and_write_0() -> DiagnosticMessage { diag(1329, DiagnosticCategory::Error, String::from("_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329"), String::from("'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?"), None, None, None) }
    pub fn a_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly() -> DiagnosticMessage { diag(1330, DiagnosticCategory::Error, String::from("A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly_1330"), String::from("A property of an interface or type literal whose type is a 'unique symbol' type must be 'readonly'."), None, None, None) }
    pub fn a_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly() -> DiagnosticMessage { diag(1331, DiagnosticCategory::Error, String::from("A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly_1331"), String::from("A property of a class whose type is a 'unique symbol' type must be both 'static' and 'readonly'."), None, None, None) }
    pub fn a_variable_whose_type_is_a_unique_symbol_type_must_be_const() -> DiagnosticMessage { diag(1332, DiagnosticCategory::Error, String::from("A_variable_whose_type_is_a_unique_symbol_type_must_be_const_1332"), String::from("A variable whose type is a 'unique symbol' type must be 'const'."), None, None, None) }
    pub fn unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name() -> DiagnosticMessage { diag(1333, DiagnosticCategory::Error, String::from("unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333"), String::from("'unique symbol' types may not be used on a variable declaration with a binding name."), None, None, None) }
    pub fn unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement() -> DiagnosticMessage { diag(1334, DiagnosticCategory::Error, String::from("unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334"), String::from("'unique symbol' types are only allowed on variables in a variable statement."), None, None, None) }
    pub fn unique_symbol_types_are_not_allowed_here() -> DiagnosticMessage { diag(1335, DiagnosticCategory::Error, String::from("unique_symbol_types_are_not_allowed_here_1335"), String::from("'unique symbol' types are not allowed here."), None, None, None) }
    pub fn an_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_consider_using_a_mapped_object_type_instead() -> DiagnosticMessage { diag(1337, DiagnosticCategory::Error, String::from("An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_o_1337"), String::from("An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead."), None, None, None) }
    pub fn infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type() -> DiagnosticMessage { diag(1338, DiagnosticCategory::Error, String::from("infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338"), String::from("'infer' declarations are only permitted in the 'extends' clause of a conditional type."), None, None, None) }
    pub fn module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here() -> DiagnosticMessage { diag(1339, DiagnosticCategory::Error, String::from("Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here_1339"), String::from("Module '{0}' does not refer to a value, but is used as a value here."), None, None, None) }
    pub fn module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_did_you_mean_typeof_import_0() -> DiagnosticMessage { diag(1340, DiagnosticCategory::Error, String::from("Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0_1340"), String::from("Module '{0}' does not refer to a type, but is used as a type here. Did you mean 'typeof import('{0}')'?"), None, None, None) }
    pub fn class_constructor_may_not_be_an_accessor() -> DiagnosticMessage { diag(1341, DiagnosticCategory::Error, String::from("Class_constructor_may_not_be_an_accessor_1341"), String::from("Class constructor may not be an accessor."), None, None, None) }
    pub fn the_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext() -> DiagnosticMessage { diag(1343, DiagnosticCategory::Error, String::from("The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system__1343"), String::from("The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', or 'nodenext'."), None, None, None) }
    pub fn a_label_is_not_allowed_here() -> DiagnosticMessage { diag(1344, DiagnosticCategory::Error, String::from("A_label_is_not_allowed_here_1344"), String::from("'A label is not allowed here."), None, None, None) }
    pub fn an_expression_of_type_void_cannot_be_tested_for_truthiness() -> DiagnosticMessage { diag(1345, DiagnosticCategory::Error, String::from("An_expression_of_type_void_cannot_be_tested_for_truthiness_1345"), String::from("An expression of type 'void' cannot be tested for truthiness."), None, None, None) }
    pub fn this_parameter_is_not_allowed_with_use_strict_directive() -> DiagnosticMessage { diag(1346, DiagnosticCategory::Error, String::from("This_parameter_is_not_allowed_with_use_strict_directive_1346"), String::from("This parameter is not allowed with 'use strict' directive."), None, None, None) }
    pub fn use_strict_directive_cannot_be_used_with_non_simple_parameter_list() -> DiagnosticMessage { diag(1347, DiagnosticCategory::Error, String::from("use_strict_directive_cannot_be_used_with_non_simple_parameter_list_1347"), String::from("'use strict' directive cannot be used with non-simple parameter list."), None, None, None) }
    pub fn non_simple_parameter_declared_here() -> DiagnosticMessage { diag(1348, DiagnosticCategory::Error, String::from("Non_simple_parameter_declared_here_1348"), String::from("Non-simple parameter declared here."), None, None, None) }
    pub fn use_strict_directive_used_here() -> DiagnosticMessage { diag(1349, DiagnosticCategory::Error, String::from("use_strict_directive_used_here_1349"), String::from("'use strict' directive used here."), None, None, None) }
    pub fn print_the_final_configuration_instead_of_building() -> DiagnosticMessage { diag(1350, DiagnosticCategory::Message, String::from("Print_the_final_configuration_instead_of_building_1350"), String::from("Print the final configuration instead of building."), None, None, None) }
    pub fn an_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal() -> DiagnosticMessage { diag(1351, DiagnosticCategory::Error, String::from("An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal_1351"), String::from("An identifier or keyword cannot immediately follow a numeric literal."), None, None, None) }
    pub fn a_bigint_literal_cannot_use_exponential_notation() -> DiagnosticMessage { diag(1352, DiagnosticCategory::Error, String::from("A_bigint_literal_cannot_use_exponential_notation_1352"), String::from("A bigint literal cannot use exponential notation."), None, None, None) }
    pub fn a_bigint_literal_must_be_an_integer() -> DiagnosticMessage { diag(1353, DiagnosticCategory::Error, String::from("A_bigint_literal_must_be_an_integer_1353"), String::from("A bigint literal must be an integer."), None, None, None) }
    pub fn readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types() -> DiagnosticMessage { diag(1354, DiagnosticCategory::Error, String::from("readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types_1354"), String::from("'readonly' type modifier is only permitted on array and tuple literal types."), None, None, None) }
    pub fn a_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals() -> DiagnosticMessage { diag(1355, DiagnosticCategory::Error, String::from("A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array__1355"), String::from("A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals."), None, None, None) }
    pub fn did_you_mean_to_mark_this_function_as_async() -> DiagnosticMessage { diag(1356, DiagnosticCategory::Error, String::from("Did_you_mean_to_mark_this_function_as_async_1356"), String::from("Did you mean to mark this function as 'async'?"), None, None, None) }
    pub fn an_enum_member_name_must_be_followed_by_a_or() -> DiagnosticMessage { diag(1357, DiagnosticCategory::Error, String::from("An_enum_member_name_must_be_followed_by_a_or_1357"), String::from("An enum member name must be followed by a ',', '=', or '}'."), None, None, None) }
    pub fn tagged_template_expressions_are_not_permitted_in_an_optional_chain() -> DiagnosticMessage { diag(1358, DiagnosticCategory::Error, String::from("Tagged_template_expressions_are_not_permitted_in_an_optional_chain_1358"), String::from("Tagged template expressions are not permitted in an optional chain."), None, None, None) }
    pub fn identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here() -> DiagnosticMessage { diag(1359, DiagnosticCategory::Error, String::from("Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here_1359"), String::from("Identifier expected. '{0}' is a reserved word that cannot be used here."), None, None, None) }
    pub fn type_0_does_not_satisfy_the_expected_type_1() -> DiagnosticMessage { diag(1360, DiagnosticCategory::Error, String::from("Type_0_does_not_satisfy_the_expected_type_1_1360"), String::from("Type '{0}' does not satisfy the expected type '{1}'."), None, None, None) }
    pub fn _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type() -> DiagnosticMessage { diag(1361, DiagnosticCategory::Error, String::from("_0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type_1361"), String::from("'{0}' cannot be used as a value because it was imported using 'import type'."), None, None, None) }
    pub fn _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type() -> DiagnosticMessage { diag(1362, DiagnosticCategory::Error, String::from("_0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type_1362"), String::from("'{0}' cannot be used as a value because it was exported using 'export type'."), None, None, None) }
    pub fn a_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both() -> DiagnosticMessage { diag(1363, DiagnosticCategory::Error, String::from("A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both_1363"), String::from("A type-only import can specify a default import or named bindings, but not both."), None, None, None) }
    pub fn convert_to_type_only_export() -> DiagnosticMessage { diag(1364, DiagnosticCategory::Message, String::from("Convert_to_type_only_export_1364"), String::from("Convert to type-only export"), None, None, None) }
    pub fn convert_all_re_exported_types_to_type_only_exports() -> DiagnosticMessage { diag(1365, DiagnosticCategory::Message, String::from("Convert_all_re_exported_types_to_type_only_exports_1365"), String::from("Convert all re-exported types to type-only exports"), None, None, None) }
    pub fn split_into_two_separate_import_declarations() -> DiagnosticMessage { diag(1366, DiagnosticCategory::Message, String::from("Split_into_two_separate_import_declarations_1366"), String::from("Split into two separate import declarations"), None, None, None) }
    pub fn split_all_invalid_type_only_imports() -> DiagnosticMessage { diag(1367, DiagnosticCategory::Message, String::from("Split_all_invalid_type_only_imports_1367"), String::from("Split all invalid type-only imports"), None, None, None) }
    pub fn class_constructor_may_not_be_a_generator() -> DiagnosticMessage { diag(1368, DiagnosticCategory::Error, String::from("Class_constructor_may_not_be_a_generator_1368"), String::from("Class constructor may not be a generator."), None, None, None) }
    pub fn did_you_mean_0() -> DiagnosticMessage { diag(1369, DiagnosticCategory::Message, String::from("Did_you_mean_0_1369"), String::from("Did you mean '{0}'?"), None, None, None) }
    pub fn await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_consider_adding_an_empty_export_to_make_this_file_a_module() -> DiagnosticMessage { diag(1375, DiagnosticCategory::Error, String::from("await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_fi_1375"), String::from("'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."), None, None, None) }
    pub fn _0_was_imported_here() -> DiagnosticMessage { diag(1376, DiagnosticCategory::Message, String::from("_0_was_imported_here_1376"), String::from("'{0}' was imported here."), None, None, None) }
    pub fn _0_was_exported_here() -> DiagnosticMessage { diag(1377, DiagnosticCategory::Message, String::from("_0_was_exported_here_1377"), String::from("'{0}' was exported here."), None, None, None) }
    pub fn top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher() -> DiagnosticMessage { diag(1378, DiagnosticCategory::Error, String::from("Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_n_1378"), String::from("Top-level 'await' expressions are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', 'nodenext', or 'preserve', and the 'target' option is set to 'es2017' or higher."), None, None, None) }
    pub fn an_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type() -> DiagnosticMessage { diag(1379, DiagnosticCategory::Error, String::from("An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type_1379"), String::from("An import alias cannot reference a declaration that was exported using 'export type'."), None, None, None) }
    pub fn an_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type() -> DiagnosticMessage { diag(1380, DiagnosticCategory::Error, String::from("An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type_1380"), String::from("An import alias cannot reference a declaration that was imported using 'import type'."), None, None, None) }
    pub fn unexpected_token_did_you_mean_or_rbrace() -> DiagnosticMessage { diag(1381, DiagnosticCategory::Error, String::from("Unexpected_token_Did_you_mean_or_rbrace_1381"), String::from("Unexpected token. Did you mean `{'}'}` or `&rbrace;`?"), None, None, None) }
    pub fn unexpected_token_did_you_mean_or_gt() -> DiagnosticMessage { diag(1382, DiagnosticCategory::Error, String::from("Unexpected_token_Did_you_mean_or_gt_1382"), String::from("Unexpected token. Did you mean `{'>'}` or `&gt;`?"), None, None, None) }
    pub fn function_type_notation_must_be_parenthesized_when_used_in_a_union_type() -> DiagnosticMessage { diag(1385, DiagnosticCategory::Error, String::from("Function_type_notation_must_be_parenthesized_when_used_in_a_union_type_1385"), String::from("Function type notation must be parenthesized when used in a union type."), None, None, None) }
    pub fn constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type() -> DiagnosticMessage { diag(1386, DiagnosticCategory::Error, String::from("Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type_1386"), String::from("Constructor type notation must be parenthesized when used in a union type."), None, None, None) }
    pub fn function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type() -> DiagnosticMessage { diag(1387, DiagnosticCategory::Error, String::from("Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1387"), String::from("Function type notation must be parenthesized when used in an intersection type."), None, None, None) }
    pub fn constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type() -> DiagnosticMessage { diag(1388, DiagnosticCategory::Error, String::from("Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1388"), String::from("Constructor type notation must be parenthesized when used in an intersection type."), None, None, None) }
    pub fn _0_is_not_allowed_as_a_variable_declaration_name() -> DiagnosticMessage { diag(1389, DiagnosticCategory::Error, String::from("_0_is_not_allowed_as_a_variable_declaration_name_1389"), String::from("'{0}' is not allowed as a variable declaration name."), None, None, None) }
    pub fn _0_is_not_allowed_as_a_parameter_name() -> DiagnosticMessage { diag(1390, DiagnosticCategory::Error, String::from("_0_is_not_allowed_as_a_parameter_name_1390"), String::from("'{0}' is not allowed as a parameter name."), None, None, None) }
    pub fn an_import_alias_cannot_use_import_type() -> DiagnosticMessage { diag(1392, DiagnosticCategory::Error, String::from("An_import_alias_cannot_use_import_type_1392"), String::from("An import alias cannot use 'import type'"), None, None, None) }
    pub fn imported_via_0_from_file_1() -> DiagnosticMessage { diag(1393, DiagnosticCategory::Message, String::from("Imported_via_0_from_file_1_1393"), String::from("Imported via {0} from file '{1}'"), None, None, None) }
    pub fn imported_via_0_from_file_1_with_packageid_2() -> DiagnosticMessage { diag(1394, DiagnosticCategory::Message, String::from("Imported_via_0_from_file_1_with_packageId_2_1394"), String::from("Imported via {0} from file '{1}' with packageId '{2}'"), None, None, None) }
    pub fn imported_via_0_from_file_1_to_import_importhelpers_as_specified_in_compileroptions() -> DiagnosticMessage { diag(1395, DiagnosticCategory::Message, String::from("Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions_1395"), String::from("Imported via {0} from file '{1}' to import 'importHelpers' as specified in compilerOptions"), None, None, None) }
    pub fn imported_via_0_from_file_1_with_packageid_2_to_import_importhelpers_as_specified_in_compileroptions() -> DiagnosticMessage { diag(1396, DiagnosticCategory::Message, String::from("Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions_1396"), String::from("Imported via {0} from file '{1}' with packageId '{2}' to import 'importHelpers' as specified in compilerOptions"), None, None, None) }
    pub fn imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions() -> DiagnosticMessage { diag(1397, DiagnosticCategory::Message, String::from("Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions_1397"), String::from("Imported via {0} from file '{1}' to import 'jsx' and 'jsxs' factory functions"), None, None, None) }
    pub fn imported_via_0_from_file_1_with_packageid_2_to_import_jsx_and_jsxs_factory_functions() -> DiagnosticMessage { diag(1398, DiagnosticCategory::Message, String::from("Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions_1398"), String::from("Imported via {0} from file '{1}' with packageId '{2}' to import 'jsx' and 'jsxs' factory functions"), None, None, None) }
    pub fn file_is_included_via_import_here() -> DiagnosticMessage { diag(1399, DiagnosticCategory::Message, String::from("File_is_included_via_import_here_1399"), String::from("File is included via import here."), None, None, None) }
    pub fn referenced_via_0_from_file_1() -> DiagnosticMessage { diag(1400, DiagnosticCategory::Message, String::from("Referenced_via_0_from_file_1_1400"), String::from("Referenced via '{0}' from file '{1}'"), None, None, None) }
    pub fn file_is_included_via_reference_here() -> DiagnosticMessage { diag(1401, DiagnosticCategory::Message, String::from("File_is_included_via_reference_here_1401"), String::from("File is included via reference here."), None, None, None) }
    pub fn type_library_referenced_via_0_from_file_1() -> DiagnosticMessage { diag(1402, DiagnosticCategory::Message, String::from("Type_library_referenced_via_0_from_file_1_1402"), String::from("Type library referenced via '{0}' from file '{1}'"), None, None, None) }
    pub fn type_library_referenced_via_0_from_file_1_with_packageid_2() -> DiagnosticMessage { diag(1403, DiagnosticCategory::Message, String::from("Type_library_referenced_via_0_from_file_1_with_packageId_2_1403"), String::from("Type library referenced via '{0}' from file '{1}' with packageId '{2}'"), None, None, None) }
    pub fn file_is_included_via_type_library_reference_here() -> DiagnosticMessage { diag(1404, DiagnosticCategory::Message, String::from("File_is_included_via_type_library_reference_here_1404"), String::from("File is included via type library reference here."), None, None, None) }
    pub fn library_referenced_via_0_from_file_1() -> DiagnosticMessage { diag(1405, DiagnosticCategory::Message, String::from("Library_referenced_via_0_from_file_1_1405"), String::from("Library referenced via '{0}' from file '{1}'"), None, None, None) }
    pub fn file_is_included_via_library_reference_here() -> DiagnosticMessage { diag(1406, DiagnosticCategory::Message, String::from("File_is_included_via_library_reference_here_1406"), String::from("File is included via library reference here."), None, None, None) }
    pub fn matched_by_include_pattern_0_in_1() -> DiagnosticMessage { diag(1407, DiagnosticCategory::Message, String::from("Matched_by_include_pattern_0_in_1_1407"), String::from("Matched by include pattern '{0}' in '{1}'"), None, None, None) }
    pub fn file_is_matched_by_include_pattern_specified_here() -> DiagnosticMessage { diag(1408, DiagnosticCategory::Message, String::from("File_is_matched_by_include_pattern_specified_here_1408"), String::from("File is matched by include pattern specified here."), None, None, None) }
    pub fn part_of_files_list_in_tsconfig_json() -> DiagnosticMessage { diag(1409, DiagnosticCategory::Message, String::from("Part_of_files_list_in_tsconfig_json_1409"), String::from("Part of 'files' list in tsconfig.json"), None, None, None) }
    pub fn file_is_matched_by_files_list_specified_here() -> DiagnosticMessage { diag(1410, DiagnosticCategory::Message, String::from("File_is_matched_by_files_list_specified_here_1410"), String::from("File is matched by 'files' list specified here."), None, None, None) }
    pub fn output_from_referenced_project_0_included_because_1_specified() -> DiagnosticMessage { diag(1411, DiagnosticCategory::Message, String::from("Output_from_referenced_project_0_included_because_1_specified_1411"), String::from("Output from referenced project '{0}' included because '{1}' specified"), None, None, None) }
    pub fn output_from_referenced_project_0_included_because_module_is_specified_as_none() -> DiagnosticMessage { diag(1412, DiagnosticCategory::Message, String::from("Output_from_referenced_project_0_included_because_module_is_specified_as_none_1412"), String::from("Output from referenced project '{0}' included because '--module' is specified as 'none'"), None, None, None) }
    pub fn file_is_output_from_referenced_project_specified_here() -> DiagnosticMessage { diag(1413, DiagnosticCategory::Message, String::from("File_is_output_from_referenced_project_specified_here_1413"), String::from("File is output from referenced project specified here."), None, None, None) }
    pub fn source_from_referenced_project_0_included_because_1_specified() -> DiagnosticMessage { diag(1414, DiagnosticCategory::Message, String::from("Source_from_referenced_project_0_included_because_1_specified_1414"), String::from("Source from referenced project '{0}' included because '{1}' specified"), None, None, None) }
    pub fn source_from_referenced_project_0_included_because_module_is_specified_as_none() -> DiagnosticMessage { diag(1415, DiagnosticCategory::Message, String::from("Source_from_referenced_project_0_included_because_module_is_specified_as_none_1415"), String::from("Source from referenced project '{0}' included because '--module' is specified as 'none'"), None, None, None) }
    pub fn file_is_source_from_referenced_project_specified_here() -> DiagnosticMessage { diag(1416, DiagnosticCategory::Message, String::from("File_is_source_from_referenced_project_specified_here_1416"), String::from("File is source from referenced project specified here."), None, None, None) }
    pub fn entry_point_of_type_library_0_specified_in_compileroptions() -> DiagnosticMessage { diag(1417, DiagnosticCategory::Message, String::from("Entry_point_of_type_library_0_specified_in_compilerOptions_1417"), String::from("Entry point of type library '{0}' specified in compilerOptions"), None, None, None) }
    pub fn entry_point_of_type_library_0_specified_in_compileroptions_with_packageid_1() -> DiagnosticMessage { diag(1418, DiagnosticCategory::Message, String::from("Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1_1418"), String::from("Entry point of type library '{0}' specified in compilerOptions with packageId '{1}'"), None, None, None) }
    pub fn file_is_entry_point_of_type_library_specified_here() -> DiagnosticMessage { diag(1419, DiagnosticCategory::Message, String::from("File_is_entry_point_of_type_library_specified_here_1419"), String::from("File is entry point of type library specified here."), None, None, None) }
    pub fn entry_point_for_implicit_type_library_0() -> DiagnosticMessage { diag(1420, DiagnosticCategory::Message, String::from("Entry_point_for_implicit_type_library_0_1420"), String::from("Entry point for implicit type library '{0}'"), None, None, None) }
    pub fn entry_point_for_implicit_type_library_0_with_packageid_1() -> DiagnosticMessage { diag(1421, DiagnosticCategory::Message, String::from("Entry_point_for_implicit_type_library_0_with_packageId_1_1421"), String::from("Entry point for implicit type library '{0}' with packageId '{1}'"), None, None, None) }
    pub fn library_0_specified_in_compileroptions() -> DiagnosticMessage { diag(1422, DiagnosticCategory::Message, String::from("Library_0_specified_in_compilerOptions_1422"), String::from("Library '{0}' specified in compilerOptions"), None, None, None) }
    pub fn file_is_library_specified_here() -> DiagnosticMessage { diag(1423, DiagnosticCategory::Message, String::from("File_is_library_specified_here_1423"), String::from("File is library specified here."), None, None, None) }
    pub fn default_library() -> DiagnosticMessage { diag(1424, DiagnosticCategory::Message, String::from("Default_library_1424"), String::from("Default library"), None, None, None) }
    pub fn default_library_for_target_0() -> DiagnosticMessage { diag(1425, DiagnosticCategory::Message, String::from("Default_library_for_target_0_1425"), String::from("Default library for target '{0}'"), None, None, None) }
    pub fn file_is_default_library_for_target_specified_here() -> DiagnosticMessage { diag(1426, DiagnosticCategory::Message, String::from("File_is_default_library_for_target_specified_here_1426"), String::from("File is default library for target specified here."), None, None, None) }
    pub fn root_file_specified_for_compilation() -> DiagnosticMessage { diag(1427, DiagnosticCategory::Message, String::from("Root_file_specified_for_compilation_1427"), String::from("Root file specified for compilation"), None, None, None) }
    pub fn file_is_output_of_project_reference_source_0() -> DiagnosticMessage { diag(1428, DiagnosticCategory::Message, String::from("File_is_output_of_project_reference_source_0_1428"), String::from("File is output of project reference source '{0}'"), None, None, None) }
    pub fn file_redirects_to_file_0() -> DiagnosticMessage { diag(1429, DiagnosticCategory::Message, String::from("File_redirects_to_file_0_1429"), String::from("File redirects to file '{0}'"), None, None, None) }
    pub fn the_file_is_in_the_program_because_colon() -> DiagnosticMessage { diag(1430, DiagnosticCategory::Message, String::from("The_file_is_in_the_program_because_colon_1430"), String::from("The file is in the program because:"), None, None, None) }
    pub fn for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_consider_adding_an_empty_export_to_make_this_file_a_module() -> DiagnosticMessage { diag(1431, DiagnosticCategory::Error, String::from("for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_1431"), String::from("'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."), None, None, None) }
    pub fn top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher() -> DiagnosticMessage { diag(1432, DiagnosticCategory::Error, String::from("Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_nod_1432"), String::from("Top-level 'for await' loops are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', 'nodenext', or 'preserve', and the 'target' option is set to 'es2017' or higher."), None, None, None) }
    pub fn neither_decorators_nor_modifiers_may_be_applied_to_this_parameters() -> DiagnosticMessage { diag(1433, DiagnosticCategory::Error, String::from("Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters_1433"), String::from("Neither decorators nor modifiers may be applied to 'this' parameters."), None, None, None) }
    pub fn unexpected_keyword_or_identifier() -> DiagnosticMessage { diag(1434, DiagnosticCategory::Error, String::from("Unexpected_keyword_or_identifier_1434"), String::from("Unexpected keyword or identifier."), None, None, None) }
    pub fn unknown_keyword_or_identifier_did_you_mean_0() -> DiagnosticMessage { diag(1435, DiagnosticCategory::Error, String::from("Unknown_keyword_or_identifier_Did_you_mean_0_1435"), String::from("Unknown keyword or identifier. Did you mean '{0}'?"), None, None, None) }
    pub fn decorators_must_precede_the_name_and_all_keywords_of_property_declarations() -> DiagnosticMessage { diag(1436, DiagnosticCategory::Error, String::from("Decorators_must_precede_the_name_and_all_keywords_of_property_declarations_1436"), String::from("Decorators must precede the name and all keywords of property declarations."), None, None, None) }
    pub fn namespace_must_be_given_a_name() -> DiagnosticMessage { diag(1437, DiagnosticCategory::Error, String::from("Namespace_must_be_given_a_name_1437"), String::from("Namespace must be given a name."), None, None, None) }
    pub fn interface_must_be_given_a_name() -> DiagnosticMessage { diag(1438, DiagnosticCategory::Error, String::from("Interface_must_be_given_a_name_1438"), String::from("Interface must be given a name."), None, None, None) }
    pub fn type_alias_must_be_given_a_name() -> DiagnosticMessage { diag(1439, DiagnosticCategory::Error, String::from("Type_alias_must_be_given_a_name_1439"), String::from("Type alias must be given a name."), None, None, None) }
    pub fn variable_declaration_not_allowed_at_this_location() -> DiagnosticMessage { diag(1440, DiagnosticCategory::Error, String::from("Variable_declaration_not_allowed_at_this_location_1440"), String::from("Variable declaration not allowed at this location."), None, None, None) }
    pub fn cannot_start_a_function_call_in_a_type_annotation() -> DiagnosticMessage { diag(1441, DiagnosticCategory::Error, String::from("Cannot_start_a_function_call_in_a_type_annotation_1441"), String::from("Cannot start a function call in a type annotation."), None, None, None) }
    pub fn expected_for_property_initializer() -> DiagnosticMessage { diag(1442, DiagnosticCategory::Error, String::from("Expected_for_property_initializer_1442"), String::from("Expected '=' for property initializer."), None, None, None) }
    pub fn module_declaration_names_may_only_use_or_quoted_strings() -> DiagnosticMessage { diag(1443, DiagnosticCategory::Error, String::from("Module_declaration_names_may_only_use_or_quoted_strings_1443"), String::from("Module declaration names may only use ' or \" quoted strings."), None, None, None) }
    pub fn _0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled() -> DiagnosticMessage { diag(1448, DiagnosticCategory::Error, String::from("_0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_1448"), String::from("'{0}' resolves to a type-only declaration and must be re-exported using a type-only re-export when '{1}' is enabled."), None, None, None) }
    pub fn preserve_unused_imported_values_in_the_javascript_output_that_would_otherwise_be_removed() -> DiagnosticMessage { diag(1449, DiagnosticCategory::Message, String::from("Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed_1449"), String::from("Preserve unused imported values in the JavaScript output that would otherwise be removed."), None, None, None) }
    pub fn dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments() -> DiagnosticMessage { diag(1450, DiagnosticCategory::Message, String::from("Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments_1450"), String::from("Dynamic imports can only accept a module specifier and an optional set of attributes as arguments"), None, None, None) }
    pub fn private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression() -> DiagnosticMessage { diag(1451, DiagnosticCategory::Error, String::from("Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member__1451"), String::from("Private identifiers are only allowed in class bodies and may only be used as part of a class member declaration, property access, or on the left-hand-side of an 'in' expression"), None, None, None) }
    pub fn resolution_mode_should_be_either_require_or_import() -> DiagnosticMessage { diag(1453, DiagnosticCategory::Error, String::from("resolution_mode_should_be_either_require_or_import_1453"), String::from("`resolution-mode` should be either `require` or `import`."), None, None, None) }
    pub fn resolution_mode_can_only_be_set_for_type_only_imports() -> DiagnosticMessage { diag(1454, DiagnosticCategory::Error, String::from("resolution_mode_can_only_be_set_for_type_only_imports_1454"), String::from("`resolution-mode` can only be set for type-only imports."), None, None, None) }
    pub fn resolution_mode_is_the_only_valid_key_for_type_import_assertions() -> DiagnosticMessage { diag(1455, DiagnosticCategory::Error, String::from("resolution_mode_is_the_only_valid_key_for_type_import_assertions_1455"), String::from("`resolution-mode` is the only valid key for type import assertions."), None, None, None) }
    pub fn type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require() -> DiagnosticMessage { diag(1456, DiagnosticCategory::Error, String::from("Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require_1456"), String::from("Type import assertions should have exactly one key - `resolution-mode` - with value `import` or `require`."), None, None, None) }
    pub fn matched_by_default_include_pattern_asterisk_asterisk_slash_asterisk() -> DiagnosticMessage { diag(1457, DiagnosticCategory::Message, String::from("Matched_by_default_include_pattern_asterisk_asterisk_slash_asterisk_1457"), String::from("Matched by default include pattern '**/*'"), None, None, None) }
    pub fn file_is_ecmascript_module_because_0_has_field_type_with_value_module() -> DiagnosticMessage { diag(1458, DiagnosticCategory::Message, String::from("File_is_ECMAScript_module_because_0_has_field_type_with_value_module_1458"), String::from("File is ECMAScript module because '{0}' has field \"type\" with value \"module\""), None, None, None) }
    pub fn file_is_commonjs_module_because_0_has_field_type_whose_value_is_not_module() -> DiagnosticMessage { diag(1459, DiagnosticCategory::Message, String::from("File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module_1459"), String::from("File is CommonJS module because '{0}' has field \"type\" whose value is not \"module\""), None, None, None) }
    pub fn file_is_commonjs_module_because_0_does_not_have_field_type() -> DiagnosticMessage { diag(1460, DiagnosticCategory::Message, String::from("File_is_CommonJS_module_because_0_does_not_have_field_type_1460"), String::from("File is CommonJS module because '{0}' does not have field \"type\""), None, None, None) }
    pub fn file_is_commonjs_module_because_package_json_was_not_found() -> DiagnosticMessage { diag(1461, DiagnosticCategory::Message, String::from("File_is_CommonJS_module_because_package_json_was_not_found_1461"), String::from("File is CommonJS module because 'package.json' was not found"), None, None, None) }
    pub fn resolution_mode_is_the_only_valid_key_for_type_import_attributes() -> DiagnosticMessage { diag(1463, DiagnosticCategory::Error, String::from("resolution_mode_is_the_only_valid_key_for_type_import_attributes_1463"), String::from("'resolution-mode' is the only valid key for type import attributes."), None, None, None) }
    pub fn type_import_attributes_should_have_exactly_one_key_resolution_mode_with_value_import_or_require() -> DiagnosticMessage { diag(1464, DiagnosticCategory::Error, String::from("Type_import_attributes_should_have_exactly_one_key_resolution_mode_with_value_import_or_require_1464"), String::from("Type import attributes should have exactly one key - 'resolution-mode' - with value 'import' or 'require'."), None, None, None) }
    pub fn the_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_commonjs_output() -> DiagnosticMessage { diag(1470, DiagnosticCategory::Error, String::from("The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output_1470"), String::from("The 'import.meta' meta-property is not allowed in files which will build into CommonJS output."), None, None, None) }
    pub fn module_0_cannot_be_imported_using_this_construct_the_specifier_only_resolves_to_an_es_module_which_cannot_be_imported_with_require_use_an_ecmascript_import_instead() -> DiagnosticMessage { diag(1471, DiagnosticCategory::Error, String::from("Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_c_1471"), String::from("Module '{0}' cannot be imported using this construct. The specifier only resolves to an ES module, which cannot be imported with 'require'. Use an ECMAScript import instead."), None, None, None) }
    pub fn catch_or_finally_expected() -> DiagnosticMessage { diag(1472, DiagnosticCategory::Error, String::from("catch_or_finally_expected_1472"), String::from("'catch' or 'finally' expected."), None, None, None) }
    pub fn an_import_declaration_can_only_be_used_at_the_top_level_of_a_module() -> DiagnosticMessage { diag(1473, DiagnosticCategory::Error, String::from("An_import_declaration_can_only_be_used_at_the_top_level_of_a_module_1473"), String::from("An import declaration can only be used at the top level of a module."), None, None, None) }
    pub fn an_export_declaration_can_only_be_used_at_the_top_level_of_a_module() -> DiagnosticMessage { diag(1474, DiagnosticCategory::Error, String::from("An_export_declaration_can_only_be_used_at_the_top_level_of_a_module_1474"), String::from("An export declaration can only be used at the top level of a module."), None, None, None) }
    pub fn control_what_method_is_used_to_detect_module_format_js_files() -> DiagnosticMessage { diag(1475, DiagnosticCategory::Message, String::from("Control_what_method_is_used_to_detect_module_format_JS_files_1475"), String::from("Control what method is used to detect module-format JS files."), None, None, None) }
    pub fn auto_colon_treat_files_with_imports_exports_import_meta_jsx_with_jsx_colon_react_jsx_or_esm_format_with_module_colon_node16_as_modules() -> DiagnosticMessage { diag(1476, DiagnosticCategory::Message, String::from("auto_colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_colon_react_jsx_or_esm_format_w_1476"), String::from("\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules."), None, None, None) }
    pub fn an_instantiation_expression_cannot_be_followed_by_a_property_access() -> DiagnosticMessage { diag(1477, DiagnosticCategory::Error, String::from("An_instantiation_expression_cannot_be_followed_by_a_property_access_1477"), String::from("An instantiation expression cannot be followed by a property access."), None, None, None) }
    pub fn identifier_or_string_literal_expected() -> DiagnosticMessage { diag(1478, DiagnosticCategory::Error, String::from("Identifier_or_string_literal_expected_1478"), String::from("Identifier or string literal expected."), None, None, None) }
    pub fn the_current_file_is_a_commonjs_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ecmascript_module_and_cannot_be_imported_with_require_consider_writing_a_dynamic_import_0_call_instead() -> DiagnosticMessage { diag(1479, DiagnosticCategory::Error, String::from("The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_reference_1479"), String::from("The current file is a CommonJS module whose imports will produce 'require' calls; however, the referenced file is an ECMAScript module and cannot be imported with 'require'. Consider writing a dynamic 'import(\"{0}\")' call instead."), None, None, None) }
    pub fn to_convert_this_file_to_an_ecmascript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_colon_module() -> DiagnosticMessage { diag(1480, DiagnosticCategory::Message, String::from("To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_packag_1480"), String::from("To convert this file to an ECMAScript module, change its file extension to '{0}' or create a local package.json file with `{ \"type\": \"module\" }`."), None, None, None) }
    pub fn to_convert_this_file_to_an_ecmascript_module_change_its_file_extension_to_0_or_add_the_field_type_colon_module_to_1() -> DiagnosticMessage { diag(1481, DiagnosticCategory::Message, String::from("To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_co_1481"), String::from("To convert this file to an ECMAScript module, change its file extension to '{0}', or add the field `\"type\": \"module\"` to '{1}'."), None, None, None) }
    pub fn to_convert_this_file_to_an_ecmascript_module_add_the_field_type_colon_module_to_0() -> DiagnosticMessage { diag(1482, DiagnosticCategory::Message, String::from("To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_colon_module_to_0_1482"), String::from("To convert this file to an ECMAScript module, add the field `\"type\": \"module\"` to '{0}'."), None, None, None) }
    pub fn to_convert_this_file_to_an_ecmascript_module_create_a_local_package_json_file_with_type_colon_module() -> DiagnosticMessage { diag(1483, DiagnosticCategory::Message, String::from("To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_colon_module_1483"), String::from("To convert this file to an ECMAScript module, create a local package.json file with `{ \"type\": \"module\" }`."), None, None, None) }
    pub fn _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimmodulesyntax_is_enabled() -> DiagnosticMessage { diag(1484, DiagnosticCategory::Error, String::from("_0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled_1484"), String::from("'{0}' is a type and must be imported using a type-only import when 'verbatimModuleSyntax' is enabled."), None, None, None) }
    pub fn _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimmodulesyntax_is_enabled() -> DiagnosticMessage { diag(1485, DiagnosticCategory::Error, String::from("_0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimMo_1485"), String::from("'{0}' resolves to a type-only declaration and must be imported using a type-only import when 'verbatimModuleSyntax' is enabled."), None, None, None) }
    pub fn decorator_used_before_export_here() -> DiagnosticMessage { diag(1486, DiagnosticCategory::Error, String::from("Decorator_used_before_export_here_1486"), String::from("Decorator used before 'export' here."), None, None, None) }
    pub fn octal_escape_sequences_are_not_allowed_use_the_syntax_0() -> DiagnosticMessage { diag(1487, DiagnosticCategory::Error, String::from("Octal_escape_sequences_are_not_allowed_Use_the_syntax_0_1487"), String::from("Octal escape sequences are not allowed. Use the syntax '{0}'."), None, None, None) }
    pub fn escape_sequence_0_is_not_allowed() -> DiagnosticMessage { diag(1488, DiagnosticCategory::Error, String::from("Escape_sequence_0_is_not_allowed_1488"), String::from("Escape sequence '{0}' is not allowed."), None, None, None) }
    pub fn decimals_with_leading_zeros_are_not_allowed() -> DiagnosticMessage { diag(1489, DiagnosticCategory::Error, String::from("Decimals_with_leading_zeros_are_not_allowed_1489"), String::from("Decimals with leading zeros are not allowed."), None, None, None) }
    pub fn file_appears_to_be_binary() -> DiagnosticMessage { diag(1490, DiagnosticCategory::Error, String::from("File_appears_to_be_binary_1490"), String::from("File appears to be binary."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_a_using_declaration() -> DiagnosticMessage { diag(1491, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_a_using_declaration_1491"), String::from("'{0}' modifier cannot appear on a 'using' declaration."), None, None, None) }
    pub fn _0_declarations_may_not_have_binding_patterns() -> DiagnosticMessage { diag(1492, DiagnosticCategory::Error, String::from("_0_declarations_may_not_have_binding_patterns_1492"), String::from("'{0}' declarations may not have binding patterns."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration() -> DiagnosticMessage { diag(1493, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration_1493"), String::from("The left-hand side of a 'for...in' statement cannot be a 'using' declaration."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration() -> DiagnosticMessage { diag(1494, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration_1494"), String::from("The left-hand side of a 'for...in' statement cannot be an 'await using' declaration."), None, None, None) }
    pub fn _0_modifier_cannot_appear_on_an_await_using_declaration() -> DiagnosticMessage { diag(1495, DiagnosticCategory::Error, String::from("_0_modifier_cannot_appear_on_an_await_using_declaration_1495"), String::from("'{0}' modifier cannot appear on an 'await using' declaration."), None, None, None) }
    pub fn identifier_string_literal_or_number_literal_expected() -> DiagnosticMessage { diag(1496, DiagnosticCategory::Error, String::from("Identifier_string_literal_or_number_literal_expected_1496"), String::from("Identifier, string literal, or number literal expected."), None, None, None) }
    pub fn expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator() -> DiagnosticMessage { diag(1497, DiagnosticCategory::Error, String::from("Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator_1497"), String::from("Expression must be enclosed in parentheses to be used as a decorator."), None, None, None) }
    pub fn invalid_syntax_in_decorator() -> DiagnosticMessage { diag(1498, DiagnosticCategory::Error, String::from("Invalid_syntax_in_decorator_1498"), String::from("Invalid syntax in decorator."), None, None, None) }
    pub fn unknown_regular_expression_flag() -> DiagnosticMessage { diag(1499, DiagnosticCategory::Error, String::from("Unknown_regular_expression_flag_1499"), String::from("Unknown regular expression flag."), None, None, None) }
    pub fn duplicate_regular_expression_flag() -> DiagnosticMessage { diag(1500, DiagnosticCategory::Error, String::from("Duplicate_regular_expression_flag_1500"), String::from("Duplicate regular expression flag."), None, None, None) }
    pub fn this_regular_expression_flag_is_only_available_when_targeting_0_or_later() -> DiagnosticMessage { diag(1501, DiagnosticCategory::Error, String::from("This_regular_expression_flag_is_only_available_when_targeting_0_or_later_1501"), String::from("This regular expression flag is only available when targeting '{0}' or later."), None, None, None) }
    pub fn the_unicode_u_flag_and_the_unicode_sets_v_flag_cannot_be_set_simultaneously() -> DiagnosticMessage { diag(1502, DiagnosticCategory::Error, String::from("The_Unicode_u_flag_and_the_Unicode_Sets_v_flag_cannot_be_set_simultaneously_1502"), String::from("The Unicode (u) flag and the Unicode Sets (v) flag cannot be set simultaneously."), None, None, None) }
    pub fn named_capturing_groups_are_only_available_when_targeting_es2018_or_later() -> DiagnosticMessage { diag(1503, DiagnosticCategory::Error, String::from("Named_capturing_groups_are_only_available_when_targeting_ES2018_or_later_1503"), String::from("Named capturing groups are only available when targeting 'ES2018' or later."), None, None, None) }
    pub fn subpattern_flags_must_be_present_when_there_is_a_minus_sign() -> DiagnosticMessage { diag(1504, DiagnosticCategory::Error, String::from("Subpattern_flags_must_be_present_when_there_is_a_minus_sign_1504"), String::from("Subpattern flags must be present when there is a minus sign."), None, None, None) }
    pub fn incomplete_quantifier_digit_expected() -> DiagnosticMessage { diag(1505, DiagnosticCategory::Error, String::from("Incomplete_quantifier_Digit_expected_1505"), String::from("Incomplete quantifier. Digit expected."), None, None, None) }
    pub fn numbers_out_of_order_in_quantifier() -> DiagnosticMessage { diag(1506, DiagnosticCategory::Error, String::from("Numbers_out_of_order_in_quantifier_1506"), String::from("Numbers out of order in quantifier."), None, None, None) }
    pub fn there_is_nothing_available_for_repetition() -> DiagnosticMessage { diag(1507, DiagnosticCategory::Error, String::from("There_is_nothing_available_for_repetition_1507"), String::from("There is nothing available for repetition."), None, None, None) }
    pub fn unexpected_0_did_you_mean_to_escape_it_with_backslash() -> DiagnosticMessage { diag(1508, DiagnosticCategory::Error, String::from("Unexpected_0_Did_you_mean_to_escape_it_with_backslash_1508"), String::from("Unexpected '{0}'. Did you mean to escape it with backslash?"), None, None, None) }
    pub fn this_regular_expression_flag_cannot_be_toggled_within_a_subpattern() -> DiagnosticMessage { diag(1509, DiagnosticCategory::Error, String::from("This_regular_expression_flag_cannot_be_toggled_within_a_subpattern_1509"), String::from("This regular expression flag cannot be toggled within a subpattern."), None, None, None) }
    pub fn k_must_be_followed_by_a_capturing_group_name_enclosed_in_angle_brackets() -> DiagnosticMessage { diag(1510, DiagnosticCategory::Error, String::from("k_must_be_followed_by_a_capturing_group_name_enclosed_in_angle_brackets_1510"), String::from("'\\k' must be followed by a capturing group name enclosed in angle brackets."), None, None, None) }
    pub fn q_is_only_available_inside_character_class() -> DiagnosticMessage { diag(1511, DiagnosticCategory::Error, String::from("q_is_only_available_inside_character_class_1511"), String::from("'\\q' is only available inside character class."), None, None, None) }
    pub fn c_must_be_followed_by_an_ascii_letter() -> DiagnosticMessage { diag(1512, DiagnosticCategory::Error, String::from("c_must_be_followed_by_an_ASCII_letter_1512"), String::from("'\\c' must be followed by an ASCII letter."), None, None, None) }
    pub fn undetermined_character_escape() -> DiagnosticMessage { diag(1513, DiagnosticCategory::Error, String::from("Undetermined_character_escape_1513"), String::from("Undetermined character escape."), None, None, None) }
    pub fn expected_a_capturing_group_name() -> DiagnosticMessage { diag(1514, DiagnosticCategory::Error, String::from("Expected_a_capturing_group_name_1514"), String::from("Expected a capturing group name."), None, None, None) }
    pub fn named_capturing_groups_with_the_same_name_must_be_mutually_exclusive_to_each_other() -> DiagnosticMessage { diag(1515, DiagnosticCategory::Error, String::from("Named_capturing_groups_with_the_same_name_must_be_mutually_exclusive_to_each_other_1515"), String::from("Named capturing groups with the same name must be mutually exclusive to each other."), None, None, None) }
    pub fn a_character_class_range_must_not_be_bounded_by_another_character_class() -> DiagnosticMessage { diag(1516, DiagnosticCategory::Error, String::from("A_character_class_range_must_not_be_bounded_by_another_character_class_1516"), String::from("A character class range must not be bounded by another character class."), None, None, None) }
    pub fn range_out_of_order_in_character_class() -> DiagnosticMessage { diag(1517, DiagnosticCategory::Error, String::from("Range_out_of_order_in_character_class_1517"), String::from("Range out of order in character class."), None, None, None) }
    pub fn anything_that_would_possibly_match_more_than_a_single_character_is_invalid_inside_a_negated_character_class() -> DiagnosticMessage { diag(1518, DiagnosticCategory::Error, String::from("Anything_that_would_possibly_match_more_than_a_single_character_is_invalid_inside_a_negated_characte_1518"), String::from("Anything that would possibly match more than a single character is invalid inside a negated character class."), None, None, None) }
    pub fn operators_must_not_be_mixed_within_a_character_class_wrap_it_in_a_nested_class_instead() -> DiagnosticMessage { diag(1519, DiagnosticCategory::Error, String::from("Operators_must_not_be_mixed_within_a_character_class_Wrap_it_in_a_nested_class_instead_1519"), String::from("Operators must not be mixed within a character class. Wrap it in a nested class instead."), None, None, None) }
    pub fn expected_a_class_set_operand() -> DiagnosticMessage { diag(1520, DiagnosticCategory::Error, String::from("Expected_a_class_set_operand_1520"), String::from("Expected a class set operand."), None, None, None) }
    pub fn q_must_be_followed_by_string_alternatives_enclosed_in_braces() -> DiagnosticMessage { diag(1521, DiagnosticCategory::Error, String::from("q_must_be_followed_by_string_alternatives_enclosed_in_braces_1521"), String::from("'\\q' must be followed by string alternatives enclosed in braces."), None, None, None) }
    pub fn a_character_class_must_not_contain_a_reserved_double_punctuator_did_you_mean_to_escape_it_with_backslash() -> DiagnosticMessage { diag(1522, DiagnosticCategory::Error, String::from("A_character_class_must_not_contain_a_reserved_double_punctuator_Did_you_mean_to_escape_it_with_backs_1522"), String::from("A character class must not contain a reserved double punctuator. Did you mean to escape it with backslash?"), None, None, None) }
    pub fn expected_a_unicode_property_name() -> DiagnosticMessage { diag(1523, DiagnosticCategory::Error, String::from("Expected_a_Unicode_property_name_1523"), String::from("Expected a Unicode property name."), None, None, None) }
    pub fn unknown_unicode_property_name() -> DiagnosticMessage { diag(1524, DiagnosticCategory::Error, String::from("Unknown_Unicode_property_name_1524"), String::from("Unknown Unicode property name."), None, None, None) }
    pub fn expected_a_unicode_property_value() -> DiagnosticMessage { diag(1525, DiagnosticCategory::Error, String::from("Expected_a_Unicode_property_value_1525"), String::from("Expected a Unicode property value."), None, None, None) }
    pub fn unknown_unicode_property_value() -> DiagnosticMessage { diag(1526, DiagnosticCategory::Error, String::from("Unknown_Unicode_property_value_1526"), String::from("Unknown Unicode property value."), None, None, None) }
    pub fn expected_a_unicode_property_name_or_value() -> DiagnosticMessage { diag(1527, DiagnosticCategory::Error, String::from("Expected_a_Unicode_property_name_or_value_1527"), String::from("Expected a Unicode property name or value."), None, None, None) }
    pub fn any_unicode_property_that_would_possibly_match_more_than_a_single_character_is_only_available_when_the_unicode_sets_v_flag_is_set() -> DiagnosticMessage { diag(1528, DiagnosticCategory::Error, String::from("Any_Unicode_property_that_would_possibly_match_more_than_a_single_character_is_only_available_when_t_1528"), String::from("Any Unicode property that would possibly match more than a single character is only available when the Unicode Sets (v) flag is set."), None, None, None) }
    pub fn unknown_unicode_property_name_or_value() -> DiagnosticMessage { diag(1529, DiagnosticCategory::Error, String::from("Unknown_Unicode_property_name_or_value_1529"), String::from("Unknown Unicode property name or value."), None, None, None) }
    pub fn unicode_property_value_expressions_are_only_available_when_the_unicode_u_flag_or_the_unicode_sets_v_flag_is_set() -> DiagnosticMessage { diag(1530, DiagnosticCategory::Error, String::from("Unicode_property_value_expressions_are_only_available_when_the_Unicode_u_flag_or_the_Unicode_Sets_v__1530"), String::from("Unicode property value expressions are only available when the Unicode (u) flag or the Unicode Sets (v) flag is set."), None, None, None) }
    pub fn _0_must_be_followed_by_a_unicode_property_value_expression_enclosed_in_braces() -> DiagnosticMessage { diag(1531, DiagnosticCategory::Error, String::from("_0_must_be_followed_by_a_Unicode_property_value_expression_enclosed_in_braces_1531"), String::from("'\\{0}' must be followed by a Unicode property value expression enclosed in braces."), None, None, None) }
    pub fn there_is_no_capturing_group_named_0_in_this_regular_expression() -> DiagnosticMessage { diag(1532, DiagnosticCategory::Error, String::from("There_is_no_capturing_group_named_0_in_this_regular_expression_1532"), String::from("There is no capturing group named '{0}' in this regular expression."), None, None, None) }
    pub fn this_backreference_refers_to_a_group_that_does_not_exist_there_are_only_0_capturing_groups_in_this_regular_expression() -> DiagnosticMessage { diag(1533, DiagnosticCategory::Error, String::from("This_backreference_refers_to_a_group_that_does_not_exist_There_are_only_0_capturing_groups_in_this_r_1533"), String::from("This backreference refers to a group that does not exist. There are only {0} capturing groups in this regular expression."), None, None, None) }
    pub fn this_backreference_refers_to_a_group_that_does_not_exist_there_are_no_capturing_groups_in_this_regular_expression() -> DiagnosticMessage { diag(1534, DiagnosticCategory::Error, String::from("This_backreference_refers_to_a_group_that_does_not_exist_There_are_no_capturing_groups_in_this_regul_1534"), String::from("This backreference refers to a group that does not exist. There are no capturing groups in this regular expression."), None, None, None) }
    pub fn this_character_cannot_be_escaped_in_a_regular_expression() -> DiagnosticMessage { diag(1535, DiagnosticCategory::Error, String::from("This_character_cannot_be_escaped_in_a_regular_expression_1535"), String::from("This character cannot be escaped in a regular expression."), None, None, None) }
    pub fn octal_escape_sequences_and_backreferences_are_not_allowed_in_a_character_class_if_this_was_intended_as_an_escape_sequence_use_the_syntax_0_instead() -> DiagnosticMessage { diag(1536, DiagnosticCategory::Error, String::from("Octal_escape_sequences_and_backreferences_are_not_allowed_in_a_character_class_If_this_was_intended__1536"), String::from("Octal escape sequences and backreferences are not allowed in a character class. If this was intended as an escape sequence, use the syntax '{0}' instead."), None, None, None) }
    pub fn decimal_escape_sequences_and_backreferences_are_not_allowed_in_a_character_class() -> DiagnosticMessage { diag(1537, DiagnosticCategory::Error, String::from("Decimal_escape_sequences_and_backreferences_are_not_allowed_in_a_character_class_1537"), String::from("Decimal escape sequences and backreferences are not allowed in a character class."), None, None, None) }
    pub fn unicode_escape_sequences_are_only_available_when_the_unicode_u_flag_or_the_unicode_sets_v_flag_is_set() -> DiagnosticMessage { diag(1538, DiagnosticCategory::Error, String::from("Unicode_escape_sequences_are_only_available_when_the_Unicode_u_flag_or_the_Unicode_Sets_v_flag_is_se_1538"), String::from("Unicode escape sequences are only available when the Unicode (u) flag or the Unicode Sets (v) flag is set."), None, None, None) }
    pub fn a_bigint_literal_cannot_be_used_as_a_property_name() -> DiagnosticMessage { diag(1539, DiagnosticCategory::Error, String::from("A_bigint_literal_cannot_be_used_as_a_property_name_1539"), String::from("A 'bigint' literal cannot be used as a property name."), None, None, None) }
    pub fn a_namespace_declaration_should_not_be_declared_using_the_module_keyword_please_use_the_namespace_keyword_instead() -> DiagnosticMessage { diag(1540, DiagnosticCategory::Suggestion, String::from("A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_key_1540"), String::from("A 'namespace' declaration should not be declared using the 'module' keyword. Please use the 'namespace' keyword instead."), None, None, Some(true)) }
    pub fn the_types_of_0_are_incompatible_between_these_types() -> DiagnosticMessage { diag(2200, DiagnosticCategory::Error, String::from("The_types_of_0_are_incompatible_between_these_types_2200"), String::from("The types of '{0}' are incompatible between these types."), None, None, None) }
    pub fn the_types_returned_by_0_are_incompatible_between_these_types() -> DiagnosticMessage { diag(2201, DiagnosticCategory::Error, String::from("The_types_returned_by_0_are_incompatible_between_these_types_2201"), String::from("The types returned by '{0}' are incompatible between these types."), None, None, None) }
    pub fn call_signature_return_types_0_and_1_are_incompatible() -> DiagnosticMessage { diag(2202, DiagnosticCategory::Error, String::from("Call_signature_return_types_0_and_1_are_incompatible_2202"), String::from("Call signature return types '{0}' and '{1}' are incompatible."), None, Some(true), None) }
    pub fn construct_signature_return_types_0_and_1_are_incompatible() -> DiagnosticMessage { diag(2203, DiagnosticCategory::Error, String::from("Construct_signature_return_types_0_and_1_are_incompatible_2203"), String::from("Construct signature return types '{0}' and '{1}' are incompatible."), None, Some(true), None) }
    pub fn call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1() -> DiagnosticMessage { diag(2204, DiagnosticCategory::Error, String::from("Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2204"), String::from("Call signatures with no arguments have incompatible return types '{0}' and '{1}'."), None, Some(true), None) }
    pub fn construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1() -> DiagnosticMessage { diag(2205, DiagnosticCategory::Error, String::from("Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2205"), String::from("Construct signatures with no arguments have incompatible return types '{0}' and '{1}'."), None, Some(true), None) }
    pub fn the_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement() -> DiagnosticMessage { diag(2206, DiagnosticCategory::Error, String::from("The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement_2206"), String::from("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."), None, None, None) }
    pub fn the_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement() -> DiagnosticMessage { diag(2207, DiagnosticCategory::Error, String::from("The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement_2207"), String::from("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."), None, None, None) }
    pub fn this_type_parameter_might_need_an_extends_0_constraint() -> DiagnosticMessage { diag(2208, DiagnosticCategory::Error, String::from("This_type_parameter_might_need_an_extends_0_constraint_2208"), String::from("This type parameter might need an `extends {0}` constraint."), None, None, None) }
    pub fn the_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_supply_the_rootdir_compiler_option_to_disambiguate() -> DiagnosticMessage { diag(2209, DiagnosticCategory::Error, String::from("The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_roo_2209"), String::from("The project root is ambiguous, but is required to resolve export map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."), None, None, None) }
    pub fn the_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_supply_the_rootdir_compiler_option_to_disambiguate() -> DiagnosticMessage { diag(2210, DiagnosticCategory::Error, String::from("The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_roo_2210"), String::from("The project root is ambiguous, but is required to resolve import map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."), None, None, None) }
    pub fn add_extends_constraint() -> DiagnosticMessage { diag(2211, DiagnosticCategory::Message, String::from("Add_extends_constraint_2211"), String::from("Add `extends` constraint."), None, None, None) }
    pub fn add_extends_constraint_to_all_type_parameters() -> DiagnosticMessage { diag(2212, DiagnosticCategory::Message, String::from("Add_extends_constraint_to_all_type_parameters_2212"), String::from("Add `extends` constraint to all type parameters"), None, None, None) }
    pub fn duplicate_identifier_0() -> DiagnosticMessage { diag(2300, DiagnosticCategory::Error, String::from("Duplicate_identifier_0_2300"), String::from("Duplicate identifier '{0}'."), None, None, None) }
    pub fn initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor() -> DiagnosticMessage { diag(2301, DiagnosticCategory::Error, String::from("Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301"), String::from("Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."), None, None, None) }
    pub fn static_members_cannot_reference_class_type_parameters() -> DiagnosticMessage { diag(2302, DiagnosticCategory::Error, String::from("Static_members_cannot_reference_class_type_parameters_2302"), String::from("Static members cannot reference class type parameters."), None, None, None) }
    pub fn circular_definition_of_import_alias_0() -> DiagnosticMessage { diag(2303, DiagnosticCategory::Error, String::from("Circular_definition_of_import_alias_0_2303"), String::from("Circular definition of import alias '{0}'."), None, None, None) }
    pub fn cannot_find_name_0() -> DiagnosticMessage { diag(2304, DiagnosticCategory::Error, String::from("Cannot_find_name_0_2304"), String::from("Cannot find name '{0}'."), None, None, None) }
    pub fn module_0_has_no_exported_member_1() -> DiagnosticMessage { diag(2305, DiagnosticCategory::Error, String::from("Module_0_has_no_exported_member_1_2305"), String::from("Module '{0}' has no exported member '{1}'."), None, None, None) }
    pub fn file_0_is_not_a_module() -> DiagnosticMessage { diag(2306, DiagnosticCategory::Error, String::from("File_0_is_not_a_module_2306"), String::from("File '{0}' is not a module."), None, None, None) }
    pub fn cannot_find_module_0_or_its_corresponding_type_declarations() -> DiagnosticMessage { diag(2307, DiagnosticCategory::Error, String::from("Cannot_find_module_0_or_its_corresponding_type_declarations_2307"), String::from("Cannot find module '{0}' or its corresponding type declarations."), None, None, None) }
    pub fn module_0_has_already_exported_a_member_named_1_consider_explicitly_re_exporting_to_resolve_the_ambiguity() -> DiagnosticMessage { diag(2308, DiagnosticCategory::Error, String::from("Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308"), String::from("Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity."), None, None, None) }
    pub fn an_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements() -> DiagnosticMessage { diag(2309, DiagnosticCategory::Error, String::from("An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309"), String::from("An export assignment cannot be used in a module with other exported elements."), None, None, None) }
    pub fn type_0_recursively_references_itself_as_a_base_type() -> DiagnosticMessage { diag(2310, DiagnosticCategory::Error, String::from("Type_0_recursively_references_itself_as_a_base_type_2310"), String::from("Type '{0}' recursively references itself as a base type."), None, None, None) }
    pub fn cannot_find_name_0_did_you_mean_to_write_this_in_an_async_function() -> DiagnosticMessage { diag(2311, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function_2311"), String::from("Cannot find name '{0}'. Did you mean to write this in an async function?"), None, None, None) }
    pub fn an_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members() -> DiagnosticMessage { diag(2312, DiagnosticCategory::Error, String::from("An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_me_2312"), String::from("An interface can only extend an object type or intersection of object types with statically known members."), None, None, None) }
    pub fn type_parameter_0_has_a_circular_constraint() -> DiagnosticMessage { diag(2313, DiagnosticCategory::Error, String::from("Type_parameter_0_has_a_circular_constraint_2313"), String::from("Type parameter '{0}' has a circular constraint."), None, None, None) }
    pub fn generic_type_0_requires_1_type_argument_s() -> DiagnosticMessage { diag(2314, DiagnosticCategory::Error, String::from("Generic_type_0_requires_1_type_argument_s_2314"), String::from("Generic type '{0}' requires {1} type argument(s)."), None, None, None) }
    pub fn type_0_is_not_generic() -> DiagnosticMessage { diag(2315, DiagnosticCategory::Error, String::from("Type_0_is_not_generic_2315"), String::from("Type '{0}' is not generic."), None, None, None) }
    pub fn global_type_0_must_be_a_class_or_interface_type() -> DiagnosticMessage { diag(2316, DiagnosticCategory::Error, String::from("Global_type_0_must_be_a_class_or_interface_type_2316"), String::from("Global type '{0}' must be a class or interface type."), None, None, None) }
    pub fn global_type_0_must_have_1_type_parameter_s() -> DiagnosticMessage { diag(2317, DiagnosticCategory::Error, String::from("Global_type_0_must_have_1_type_parameter_s_2317"), String::from("Global type '{0}' must have {1} type parameter(s)."), None, None, None) }
    pub fn cannot_find_global_type_0() -> DiagnosticMessage { diag(2318, DiagnosticCategory::Error, String::from("Cannot_find_global_type_0_2318"), String::from("Cannot find global type '{0}'."), None, None, None) }
    pub fn named_property_0_of_types_1_and_2_are_not_identical() -> DiagnosticMessage { diag(2319, DiagnosticCategory::Error, String::from("Named_property_0_of_types_1_and_2_are_not_identical_2319"), String::from("Named property '{0}' of types '{1}' and '{2}' are not identical."), None, None, None) }
    pub fn interface_0_cannot_simultaneously_extend_types_1_and_2() -> DiagnosticMessage { diag(2320, DiagnosticCategory::Error, String::from("Interface_0_cannot_simultaneously_extend_types_1_and_2_2320"), String::from("Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'."), None, None, None) }
    pub fn excessive_stack_depth_comparing_types_0_and_1() -> DiagnosticMessage { diag(2321, DiagnosticCategory::Error, String::from("Excessive_stack_depth_comparing_types_0_and_1_2321"), String::from("Excessive stack depth comparing types '{0}' and '{1}'."), None, None, None) }
    pub fn type_0_is_not_assignable_to_type_1() -> DiagnosticMessage { diag(2322, DiagnosticCategory::Error, String::from("Type_0_is_not_assignable_to_type_1_2322"), String::from("Type '{0}' is not assignable to type '{1}'."), None, None, None) }
    pub fn cannot_redeclare_exported_variable_0() -> DiagnosticMessage { diag(2323, DiagnosticCategory::Error, String::from("Cannot_redeclare_exported_variable_0_2323"), String::from("Cannot redeclare exported variable '{0}'."), None, None, None) }
    pub fn property_0_is_missing_in_type_1() -> DiagnosticMessage { diag(2324, DiagnosticCategory::Error, String::from("Property_0_is_missing_in_type_1_2324"), String::from("Property '{0}' is missing in type '{1}'."), None, None, None) }
    pub fn property_0_is_private_in_type_1_but_not_in_type_2() -> DiagnosticMessage { diag(2325, DiagnosticCategory::Error, String::from("Property_0_is_private_in_type_1_but_not_in_type_2_2325"), String::from("Property '{0}' is private in type '{1}' but not in type '{2}'."), None, None, None) }
    pub fn types_of_property_0_are_incompatible() -> DiagnosticMessage { diag(2326, DiagnosticCategory::Error, String::from("Types_of_property_0_are_incompatible_2326"), String::from("Types of property '{0}' are incompatible."), None, None, None) }
    pub fn property_0_is_optional_in_type_1_but_required_in_type_2() -> DiagnosticMessage { diag(2327, DiagnosticCategory::Error, String::from("Property_0_is_optional_in_type_1_but_required_in_type_2_2327"), String::from("Property '{0}' is optional in type '{1}' but required in type '{2}'."), None, None, None) }
    pub fn types_of_parameters_0_and_1_are_incompatible() -> DiagnosticMessage { diag(2328, DiagnosticCategory::Error, String::from("Types_of_parameters_0_and_1_are_incompatible_2328"), String::from("Types of parameters '{0}' and '{1}' are incompatible."), None, None, None) }
    pub fn index_signature_for_type_0_is_missing_in_type_1() -> DiagnosticMessage { diag(2329, DiagnosticCategory::Error, String::from("Index_signature_for_type_0_is_missing_in_type_1_2329"), String::from("Index signature for type '{0}' is missing in type '{1}'."), None, None, None) }
    pub fn _0_and_1_index_signatures_are_incompatible() -> DiagnosticMessage { diag(2330, DiagnosticCategory::Error, String::from("_0_and_1_index_signatures_are_incompatible_2330"), String::from("'{0}' and '{1}' index signatures are incompatible."), None, None, None) }
    pub fn this_cannot_be_referenced_in_a_module_or_namespace_body() -> DiagnosticMessage { diag(2331, DiagnosticCategory::Error, String::from("this_cannot_be_referenced_in_a_module_or_namespace_body_2331"), String::from("'this' cannot be referenced in a module or namespace body."), None, None, None) }
    pub fn this_cannot_be_referenced_in_current_location() -> DiagnosticMessage { diag(2332, DiagnosticCategory::Error, String::from("this_cannot_be_referenced_in_current_location_2332"), String::from("'this' cannot be referenced in current location."), None, None, None) }
    pub fn this_cannot_be_referenced_in_a_static_property_initializer() -> DiagnosticMessage { diag(2334, DiagnosticCategory::Error, String::from("this_cannot_be_referenced_in_a_static_property_initializer_2334"), String::from("'this' cannot be referenced in a static property initializer."), None, None, None) }
    pub fn super_can_only_be_referenced_in_a_derived_class() -> DiagnosticMessage { diag(2335, DiagnosticCategory::Error, String::from("super_can_only_be_referenced_in_a_derived_class_2335"), String::from("'super' can only be referenced in a derived class."), None, None, None) }
    pub fn super_cannot_be_referenced_in_constructor_arguments() -> DiagnosticMessage { diag(2336, DiagnosticCategory::Error, String::from("super_cannot_be_referenced_in_constructor_arguments_2336"), String::from("'super' cannot be referenced in constructor arguments."), None, None, None) }
    pub fn super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors() -> DiagnosticMessage { diag(2337, DiagnosticCategory::Error, String::from("Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337"), String::from("Super calls are not permitted outside constructors or in nested functions inside constructors."), None, None, None) }
    pub fn super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class() -> DiagnosticMessage { diag(2338, DiagnosticCategory::Error, String::from("super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338"), String::from("'super' property access is permitted only in a constructor, member function, or member accessor of a derived class."), None, None, None) }
    pub fn property_0_does_not_exist_on_type_1() -> DiagnosticMessage { diag(2339, DiagnosticCategory::Error, String::from("Property_0_does_not_exist_on_type_1_2339"), String::from("Property '{0}' does not exist on type '{1}'."), None, None, None) }
    pub fn only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword() -> DiagnosticMessage { diag(2340, DiagnosticCategory::Error, String::from("Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340"), String::from("Only public and protected methods of the base class are accessible via the 'super' keyword."), None, None, None) }
    pub fn property_0_is_private_and_only_accessible_within_class_1() -> DiagnosticMessage { diag(2341, DiagnosticCategory::Error, String::from("Property_0_is_private_and_only_accessible_within_class_1_2341"), String::from("Property '{0}' is private and only accessible within class '{1}'."), None, None, None) }
    pub fn this_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_consider_upgrading_your_version_of_0() -> DiagnosticMessage { diag(2343, DiagnosticCategory::Error, String::from("This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_ve_2343"), String::from("This syntax requires an imported helper named '{1}' which does not exist in '{0}'. Consider upgrading your version of '{0}'."), None, None, None) }
    pub fn type_0_does_not_satisfy_the_constraint_1() -> DiagnosticMessage { diag(2344, DiagnosticCategory::Error, String::from("Type_0_does_not_satisfy_the_constraint_1_2344"), String::from("Type '{0}' does not satisfy the constraint '{1}'."), None, None, None) }
    pub fn argument_of_type_0_is_not_assignable_to_parameter_of_type_1() -> DiagnosticMessage { diag(2345, DiagnosticCategory::Error, String::from("Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345"), String::from("Argument of type '{0}' is not assignable to parameter of type '{1}'."), None, None, None) }
    pub fn untyped_function_calls_may_not_accept_type_arguments() -> DiagnosticMessage { diag(2347, DiagnosticCategory::Error, String::from("Untyped_function_calls_may_not_accept_type_arguments_2347"), String::from("Untyped function calls may not accept type arguments."), None, None, None) }
    pub fn value_of_type_0_is_not_callable_did_you_mean_to_include_new() -> DiagnosticMessage { diag(2348, DiagnosticCategory::Error, String::from("Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348"), String::from("Value of type '{0}' is not callable. Did you mean to include 'new'?"), None, None, None) }
    pub fn this_expression_is_not_callable() -> DiagnosticMessage { diag(2349, DiagnosticCategory::Error, String::from("This_expression_is_not_callable_2349"), String::from("This expression is not callable."), None, None, None) }
    pub fn only_a_void_function_can_be_called_with_the_new_keyword() -> DiagnosticMessage { diag(2350, DiagnosticCategory::Error, String::from("Only_a_void_function_can_be_called_with_the_new_keyword_2350"), String::from("Only a void function can be called with the 'new' keyword."), None, None, None) }
    pub fn this_expression_is_not_constructable() -> DiagnosticMessage { diag(2351, DiagnosticCategory::Error, String::from("This_expression_is_not_constructable_2351"), String::from("This expression is not constructable."), None, None, None) }
    pub fn conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_if_this_was_intentional_convert_the_expression_to_unknown_first() -> DiagnosticMessage { diag(2352, DiagnosticCategory::Error, String::from("Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the__2352"), String::from("Conversion of type '{0}' to type '{1}' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first."), None, None, None) }
    pub fn object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1() -> DiagnosticMessage { diag(2353, DiagnosticCategory::Error, String::from("Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353"), String::from("Object literal may only specify known properties, and '{0}' does not exist in type '{1}'."), None, None, None) }
    pub fn this_syntax_requires_an_imported_helper_but_module_0_cannot_be_found() -> DiagnosticMessage { diag(2354, DiagnosticCategory::Error, String::from("This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354"), String::from("This syntax requires an imported helper but module '{0}' cannot be found."), None, None, None) }
    pub fn a_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value() -> DiagnosticMessage { diag(2355, DiagnosticCategory::Error, String::from("A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value_2355"), String::from("A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value."), None, None, None) }
    pub fn an_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type() -> DiagnosticMessage { diag(2356, DiagnosticCategory::Error, String::from("An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type_2356"), String::from("An arithmetic operand must be of type 'any', 'number', 'bigint' or an enum type."), None, None, None) }
    pub fn the_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access() -> DiagnosticMessage { diag(2357, DiagnosticCategory::Error, String::from("The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357"), String::from("The operand of an increment or decrement operator must be a variable or a property access."), None, None, None) }
    pub fn the_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter() -> DiagnosticMessage { diag(2358, DiagnosticCategory::Error, String::from("The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358"), String::from("The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter."), None, None, None) }
    pub fn the_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_function_interface_type_or_an_object_type_with_a_symbol_hasinstance_method() -> DiagnosticMessage { diag(2359, DiagnosticCategory::Error, String::from("The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_2359"), String::from("The right-hand side of an 'instanceof' expression must be either of type 'any', a class, function, or other type assignable to the 'Function' interface type, or an object type with a 'Symbol.hasInstance' method."), None, None, None) }
    pub fn the_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type() -> DiagnosticMessage { diag(2362, DiagnosticCategory::Error, String::from("The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2362"), String::from("The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."), None, None, None) }
    pub fn the_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type() -> DiagnosticMessage { diag(2363, DiagnosticCategory::Error, String::from("The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2363"), String::from("The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."), None, None, None) }
    pub fn the_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access() -> DiagnosticMessage { diag(2364, DiagnosticCategory::Error, String::from("The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364"), String::from("The left-hand side of an assignment expression must be a variable or a property access."), None, None, None) }
    pub fn operator_0_cannot_be_applied_to_types_1_and_2() -> DiagnosticMessage { diag(2365, DiagnosticCategory::Error, String::from("Operator_0_cannot_be_applied_to_types_1_and_2_2365"), String::from("Operator '{0}' cannot be applied to types '{1}' and '{2}'."), None, None, None) }
    pub fn function_lacks_ending_return_statement_and_return_type_does_not_include_undefined() -> DiagnosticMessage { diag(2366, DiagnosticCategory::Error, String::from("Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366"), String::from("Function lacks ending return statement and return type does not include 'undefined'."), None, None, None) }
    pub fn this_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap() -> DiagnosticMessage { diag(2367, DiagnosticCategory::Error, String::from("This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap_2367"), String::from("This comparison appears to be unintentional because the types '{0}' and '{1}' have no overlap."), None, None, None) }
    pub fn type_parameter_name_cannot_be_0() -> DiagnosticMessage { diag(2368, DiagnosticCategory::Error, String::from("Type_parameter_name_cannot_be_0_2368"), String::from("Type parameter name cannot be '{0}'."), None, None, None) }
    pub fn a_parameter_property_is_only_allowed_in_a_constructor_implementation() -> DiagnosticMessage { diag(2369, DiagnosticCategory::Error, String::from("A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369"), String::from("A parameter property is only allowed in a constructor implementation."), None, None, None) }
    pub fn a_rest_parameter_must_be_of_an_array_type() -> DiagnosticMessage { diag(2370, DiagnosticCategory::Error, String::from("A_rest_parameter_must_be_of_an_array_type_2370"), String::from("A rest parameter must be of an array type."), None, None, None) }
    pub fn a_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation() -> DiagnosticMessage { diag(2371, DiagnosticCategory::Error, String::from("A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371"), String::from("A parameter initializer is only allowed in a function or constructor implementation."), None, None, None) }
    pub fn parameter_0_cannot_reference_itself() -> DiagnosticMessage { diag(2372, DiagnosticCategory::Error, String::from("Parameter_0_cannot_reference_itself_2372"), String::from("Parameter '{0}' cannot reference itself."), None, None, None) }
    pub fn parameter_0_cannot_reference_identifier_1_declared_after_it() -> DiagnosticMessage { diag(2373, DiagnosticCategory::Error, String::from("Parameter_0_cannot_reference_identifier_1_declared_after_it_2373"), String::from("Parameter '{0}' cannot reference identifier '{1}' declared after it."), None, None, None) }
    pub fn duplicate_index_signature_for_type_0() -> DiagnosticMessage { diag(2374, DiagnosticCategory::Error, String::from("Duplicate_index_signature_for_type_0_2374"), String::from("Duplicate index signature for type '{0}'."), None, None, None) }
    pub fn type_0_is_not_assignable_to_type_1_with_exactoptionalpropertytypes_colon_true_consider_adding_undefined_to_the_types_of_the_target_s_properties() -> DiagnosticMessage { diag(2375, DiagnosticCategory::Error, String::from("Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_colon_true_Consider_adding_undefi_2375"), String::from("Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."), None, None, None) }
    pub fn a_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers() -> DiagnosticMessage { diag(2376, DiagnosticCategory::Error, String::from("A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_2376"), String::from("A 'super' call must be the first statement in the constructor to refer to 'super' or 'this' when a derived class contains initialized properties, parameter properties, or private identifiers."), None, None, None) }
    pub fn constructors_for_derived_classes_must_contain_a_super_call() -> DiagnosticMessage { diag(2377, DiagnosticCategory::Error, String::from("Constructors_for_derived_classes_must_contain_a_super_call_2377"), String::from("Constructors for derived classes must contain a 'super' call."), None, None, None) }
    pub fn a_get_accessor_must_return_a_value() -> DiagnosticMessage { diag(2378, DiagnosticCategory::Error, String::from("A_get_accessor_must_return_a_value_2378"), String::from("A 'get' accessor must return a value."), None, None, None) }
    pub fn argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactoptionalpropertytypes_colon_true_consider_adding_undefined_to_the_types_of_the_target_s_properties() -> DiagnosticMessage { diag(2379, DiagnosticCategory::Error, String::from("Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_colon_tr_2379"), String::from("Argument of type '{0}' is not assignable to parameter of type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."), None, None, None) }
    pub fn overload_signatures_must_all_be_exported_or_non_exported() -> DiagnosticMessage { diag(2383, DiagnosticCategory::Error, String::from("Overload_signatures_must_all_be_exported_or_non_exported_2383"), String::from("Overload signatures must all be exported or non-exported."), None, None, None) }
    pub fn overload_signatures_must_all_be_ambient_or_non_ambient() -> DiagnosticMessage { diag(2384, DiagnosticCategory::Error, String::from("Overload_signatures_must_all_be_ambient_or_non_ambient_2384"), String::from("Overload signatures must all be ambient or non-ambient."), None, None, None) }
    pub fn overload_signatures_must_all_be_public_private_or_protected() -> DiagnosticMessage { diag(2385, DiagnosticCategory::Error, String::from("Overload_signatures_must_all_be_public_private_or_protected_2385"), String::from("Overload signatures must all be public, private or protected."), None, None, None) }
    pub fn overload_signatures_must_all_be_optional_or_required() -> DiagnosticMessage { diag(2386, DiagnosticCategory::Error, String::from("Overload_signatures_must_all_be_optional_or_required_2386"), String::from("Overload signatures must all be optional or required."), None, None, None) }
    pub fn function_overload_must_be_static() -> DiagnosticMessage { diag(2387, DiagnosticCategory::Error, String::from("Function_overload_must_be_static_2387"), String::from("Function overload must be static."), None, None, None) }
    pub fn function_overload_must_not_be_static() -> DiagnosticMessage { diag(2388, DiagnosticCategory::Error, String::from("Function_overload_must_not_be_static_2388"), String::from("Function overload must not be static."), None, None, None) }
    pub fn function_implementation_name_must_be_0() -> DiagnosticMessage { diag(2389, DiagnosticCategory::Error, String::from("Function_implementation_name_must_be_0_2389"), String::from("Function implementation name must be '{0}'."), None, None, None) }
    pub fn constructor_implementation_is_missing() -> DiagnosticMessage { diag(2390, DiagnosticCategory::Error, String::from("Constructor_implementation_is_missing_2390"), String::from("Constructor implementation is missing."), None, None, None) }
    pub fn function_implementation_is_missing_or_not_immediately_following_the_declaration() -> DiagnosticMessage { diag(2391, DiagnosticCategory::Error, String::from("Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391"), String::from("Function implementation is missing or not immediately following the declaration."), None, None, None) }
    pub fn multiple_constructor_implementations_are_not_allowed() -> DiagnosticMessage { diag(2392, DiagnosticCategory::Error, String::from("Multiple_constructor_implementations_are_not_allowed_2392"), String::from("Multiple constructor implementations are not allowed."), None, None, None) }
    pub fn duplicate_function_implementation() -> DiagnosticMessage { diag(2393, DiagnosticCategory::Error, String::from("Duplicate_function_implementation_2393"), String::from("Duplicate function implementation."), None, None, None) }
    pub fn this_overload_signature_is_not_compatible_with_its_implementation_signature() -> DiagnosticMessage { diag(2394, DiagnosticCategory::Error, String::from("This_overload_signature_is_not_compatible_with_its_implementation_signature_2394"), String::from("This overload signature is not compatible with its implementation signature."), None, None, None) }
    pub fn individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local() -> DiagnosticMessage { diag(2395, DiagnosticCategory::Error, String::from("Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395"), String::from("Individual declarations in merged declaration '{0}' must be all exported or all local."), None, None, None) }
    pub fn duplicate_identifier_arguments_compiler_uses_arguments_to_initialize_rest_parameters() -> DiagnosticMessage { diag(2396, DiagnosticCategory::Error, String::from("Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396"), String::from("Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters."), None, None, None) }
    pub fn declaration_name_conflicts_with_built_in_global_identifier_0() -> DiagnosticMessage { diag(2397, DiagnosticCategory::Error, String::from("Declaration_name_conflicts_with_built_in_global_identifier_0_2397"), String::from("Declaration name conflicts with built-in global identifier '{0}'."), None, None, None) }
    pub fn constructor_cannot_be_used_as_a_parameter_property_name() -> DiagnosticMessage { diag(2398, DiagnosticCategory::Error, String::from("constructor_cannot_be_used_as_a_parameter_property_name_2398"), String::from("'constructor' cannot be used as a parameter property name."), None, None, None) }
    pub fn duplicate_identifier_this_compiler_uses_variable_declaration_this_to_capture_this_reference() -> DiagnosticMessage { diag(2399, DiagnosticCategory::Error, String::from("Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399"), String::from("Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference."), None, None, None) }
    pub fn expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference() -> DiagnosticMessage { diag(2400, DiagnosticCategory::Error, String::from("Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400"), String::from("Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference."), None, None, None) }
    pub fn a_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers() -> DiagnosticMessage { diag(2401, DiagnosticCategory::Error, String::from("A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_in_2401"), String::from("A 'super' call must be a root-level statement within a constructor of a derived class that contains initialized properties, parameter properties, or private identifiers."), None, None, None) }
    pub fn expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference() -> DiagnosticMessage { diag(2402, DiagnosticCategory::Error, String::from("Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402"), String::from("Expression resolves to '_super' that compiler uses to capture base class reference."), None, None, None) }
    pub fn subsequent_variable_declarations_must_have_the_same_type_variable_0_must_be_of_type_1_but_here_has_type_2() -> DiagnosticMessage { diag(2403, DiagnosticCategory::Error, String::from("Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403"), String::from("Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation() -> DiagnosticMessage { diag(2404, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404"), String::from("The left-hand side of a 'for...in' statement cannot use a type annotation."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any() -> DiagnosticMessage { diag(2405, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405"), String::from("The left-hand side of a 'for...in' statement must be of type 'string' or 'any'."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access() -> DiagnosticMessage { diag(2406, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406"), String::from("The left-hand side of a 'for...in' statement must be a variable or a property access."), None, None, None) }
    pub fn the_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0() -> DiagnosticMessage { diag(2407, DiagnosticCategory::Error, String::from("The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_2407"), String::from("The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter, but here has type '{0}'."), None, None, None) }
    pub fn setters_cannot_return_a_value() -> DiagnosticMessage { diag(2408, DiagnosticCategory::Error, String::from("Setters_cannot_return_a_value_2408"), String::from("Setters cannot return a value."), None, None, None) }
    pub fn return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class() -> DiagnosticMessage { diag(2409, DiagnosticCategory::Error, String::from("Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409"), String::from("Return type of constructor signature must be assignable to the instance type of the class."), None, None, None) }
    pub fn the_with_statement_is_not_supported_all_symbols_in_a_with_block_will_have_type_any() -> DiagnosticMessage { diag(2410, DiagnosticCategory::Error, String::from("The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410"), String::from("The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'."), None, None, None) }
    pub fn type_0_is_not_assignable_to_type_1_with_exactoptionalpropertytypes_colon_true_consider_adding_undefined_to_the_type_of_the_target() -> DiagnosticMessage { diag(2412, DiagnosticCategory::Error, String::from("Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_colon_true_Consider_adding_undefi_2412"), String::from("Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target."), None, None, None) }
    pub fn property_0_of_type_1_is_not_assignable_to_2_index_type_3() -> DiagnosticMessage { diag(2411, DiagnosticCategory::Error, String::from("Property_0_of_type_1_is_not_assignable_to_2_index_type_3_2411"), String::from("Property '{0}' of type '{1}' is not assignable to '{2}' index type '{3}'."), None, None, None) }
    pub fn _0_index_type_1_is_not_assignable_to_2_index_type_3() -> DiagnosticMessage { diag(2413, DiagnosticCategory::Error, String::from("_0_index_type_1_is_not_assignable_to_2_index_type_3_2413"), String::from("'{0}' index type '{1}' is not assignable to '{2}' index type '{3}'."), None, None, None) }
    pub fn class_name_cannot_be_0() -> DiagnosticMessage { diag(2414, DiagnosticCategory::Error, String::from("Class_name_cannot_be_0_2414"), String::from("Class name cannot be '{0}'."), None, None, None) }
    pub fn class_0_incorrectly_extends_base_class_1() -> DiagnosticMessage { diag(2415, DiagnosticCategory::Error, String::from("Class_0_incorrectly_extends_base_class_1_2415"), String::from("Class '{0}' incorrectly extends base class '{1}'."), None, None, None) }
    pub fn property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2() -> DiagnosticMessage { diag(2416, DiagnosticCategory::Error, String::from("Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2_2416"), String::from("Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'."), None, None, None) }
    pub fn class_static_side_0_incorrectly_extends_base_class_static_side_1() -> DiagnosticMessage { diag(2417, DiagnosticCategory::Error, String::from("Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417"), String::from("Class static side '{0}' incorrectly extends base class static side '{1}'."), None, None, None) }
    pub fn type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1() -> DiagnosticMessage { diag(2418, DiagnosticCategory::Error, String::from("Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1_2418"), String::from("Type of computed property's value is '{0}', which is not assignable to type '{1}'."), None, None, None) }
    pub fn types_of_construct_signatures_are_incompatible() -> DiagnosticMessage { diag(2419, DiagnosticCategory::Error, String::from("Types_of_construct_signatures_are_incompatible_2419"), String::from("Types of construct signatures are incompatible."), None, None, None) }
    pub fn class_0_incorrectly_implements_interface_1() -> DiagnosticMessage { diag(2420, DiagnosticCategory::Error, String::from("Class_0_incorrectly_implements_interface_1_2420"), String::from("Class '{0}' incorrectly implements interface '{1}'."), None, None, None) }
    pub fn a_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members() -> DiagnosticMessage { diag(2422, DiagnosticCategory::Error, String::from("A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_memb_2422"), String::from("A class can only implement an object type or intersection of object types with statically known members."), None, None, None) }
    pub fn class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor() -> DiagnosticMessage { diag(2423, DiagnosticCategory::Error, String::from("Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423"), String::from("Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor."), None, None, None) }
    pub fn class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function() -> DiagnosticMessage { diag(2425, DiagnosticCategory::Error, String::from("Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425"), String::from("Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function."), None, None, None) }
    pub fn class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function() -> DiagnosticMessage { diag(2426, DiagnosticCategory::Error, String::from("Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426"), String::from("Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function."), None, None, None) }
    pub fn interface_name_cannot_be_0() -> DiagnosticMessage { diag(2427, DiagnosticCategory::Error, String::from("Interface_name_cannot_be_0_2427"), String::from("Interface name cannot be '{0}'."), None, None, None) }
    pub fn all_declarations_of_0_must_have_identical_type_parameters() -> DiagnosticMessage { diag(2428, DiagnosticCategory::Error, String::from("All_declarations_of_0_must_have_identical_type_parameters_2428"), String::from("All declarations of '{0}' must have identical type parameters."), None, None, None) }
    pub fn interface_0_incorrectly_extends_interface_1() -> DiagnosticMessage { diag(2430, DiagnosticCategory::Error, String::from("Interface_0_incorrectly_extends_interface_1_2430"), String::from("Interface '{0}' incorrectly extends interface '{1}'."), None, None, None) }
    pub fn enum_name_cannot_be_0() -> DiagnosticMessage { diag(2431, DiagnosticCategory::Error, String::from("Enum_name_cannot_be_0_2431"), String::from("Enum name cannot be '{0}'."), None, None, None) }
    pub fn in_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element() -> DiagnosticMessage { diag(2432, DiagnosticCategory::Error, String::from("In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432"), String::from("In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element."), None, None, None) }
    pub fn a_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged() -> DiagnosticMessage { diag(2433, DiagnosticCategory::Error, String::from("A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433"), String::from("A namespace declaration cannot be in a different file from a class or function with which it is merged."), None, None, None) }
    pub fn a_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged() -> DiagnosticMessage { diag(2434, DiagnosticCategory::Error, String::from("A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434"), String::from("A namespace declaration cannot be located prior to a class or function with which it is merged."), None, None, None) }
    pub fn ambient_modules_cannot_be_nested_in_other_modules_or_namespaces() -> DiagnosticMessage { diag(2435, DiagnosticCategory::Error, String::from("Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435"), String::from("Ambient modules cannot be nested in other modules or namespaces."), None, None, None) }
    pub fn ambient_module_declaration_cannot_specify_relative_module_name() -> DiagnosticMessage { diag(2436, DiagnosticCategory::Error, String::from("Ambient_module_declaration_cannot_specify_relative_module_name_2436"), String::from("Ambient module declaration cannot specify relative module name."), None, None, None) }
    pub fn module_0_is_hidden_by_a_local_declaration_with_the_same_name() -> DiagnosticMessage { diag(2437, DiagnosticCategory::Error, String::from("Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437"), String::from("Module '{0}' is hidden by a local declaration with the same name."), None, None, None) }
    pub fn import_name_cannot_be_0() -> DiagnosticMessage { diag(2438, DiagnosticCategory::Error, String::from("Import_name_cannot_be_0_2438"), String::from("Import name cannot be '{0}'."), None, None, None) }
    pub fn import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name() -> DiagnosticMessage { diag(2439, DiagnosticCategory::Error, String::from("Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439"), String::from("Import or export declaration in an ambient module declaration cannot reference module through relative module name."), None, None, None) }
    pub fn import_declaration_conflicts_with_local_declaration_of_0() -> DiagnosticMessage { diag(2440, DiagnosticCategory::Error, String::from("Import_declaration_conflicts_with_local_declaration_of_0_2440"), String::from("Import declaration conflicts with local declaration of '{0}'."), None, None, None) }
    pub fn duplicate_identifier_0_compiler_reserves_name_1_in_top_level_scope_of_a_module() -> DiagnosticMessage { diag(2441, DiagnosticCategory::Error, String::from("Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441"), String::from("Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module."), None, None, None) }
    pub fn types_have_separate_declarations_of_a_private_property_0() -> DiagnosticMessage { diag(2442, DiagnosticCategory::Error, String::from("Types_have_separate_declarations_of_a_private_property_0_2442"), String::from("Types have separate declarations of a private property '{0}'."), None, None, None) }
    pub fn property_0_is_protected_but_type_1_is_not_a_class_derived_from_2() -> DiagnosticMessage { diag(2443, DiagnosticCategory::Error, String::from("Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443"), String::from("Property '{0}' is protected but type '{1}' is not a class derived from '{2}'."), None, None, None) }
    pub fn property_0_is_protected_in_type_1_but_public_in_type_2() -> DiagnosticMessage { diag(2444, DiagnosticCategory::Error, String::from("Property_0_is_protected_in_type_1_but_public_in_type_2_2444"), String::from("Property '{0}' is protected in type '{1}' but public in type '{2}'."), None, None, None) }
    pub fn property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses() -> DiagnosticMessage { diag(2445, DiagnosticCategory::Error, String::from("Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445"), String::from("Property '{0}' is protected and only accessible within class '{1}' and its subclasses."), None, None, None) }
    pub fn property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_this_is_an_instance_of_class_2() -> DiagnosticMessage { diag(2446, DiagnosticCategory::Error, String::from("Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_cl_2446"), String::from("Property '{0}' is protected and only accessible through an instance of class '{1}'. This is an instance of class '{2}'."), None, None, None) }
    pub fn the_0_operator_is_not_allowed_for_boolean_types_consider_using_1_instead() -> DiagnosticMessage { diag(2447, DiagnosticCategory::Error, String::from("The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447"), String::from("The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead."), None, None, None) }
    pub fn block_scoped_variable_0_used_before_its_declaration() -> DiagnosticMessage { diag(2448, DiagnosticCategory::Error, String::from("Block_scoped_variable_0_used_before_its_declaration_2448"), String::from("Block-scoped variable '{0}' used before its declaration."), None, None, None) }
    pub fn class_0_used_before_its_declaration() -> DiagnosticMessage { diag(2449, DiagnosticCategory::Error, String::from("Class_0_used_before_its_declaration_2449"), String::from("Class '{0}' used before its declaration."), None, None, None) }
    pub fn enum_0_used_before_its_declaration() -> DiagnosticMessage { diag(2450, DiagnosticCategory::Error, String::from("Enum_0_used_before_its_declaration_2450"), String::from("Enum '{0}' used before its declaration."), None, None, None) }
    pub fn cannot_redeclare_block_scoped_variable_0() -> DiagnosticMessage { diag(2451, DiagnosticCategory::Error, String::from("Cannot_redeclare_block_scoped_variable_0_2451"), String::from("Cannot redeclare block-scoped variable '{0}'."), None, None, None) }
    pub fn an_enum_member_cannot_have_a_numeric_name() -> DiagnosticMessage { diag(2452, DiagnosticCategory::Error, String::from("An_enum_member_cannot_have_a_numeric_name_2452"), String::from("An enum member cannot have a numeric name."), None, None, None) }
    pub fn variable_0_is_used_before_being_assigned() -> DiagnosticMessage { diag(2454, DiagnosticCategory::Error, String::from("Variable_0_is_used_before_being_assigned_2454"), String::from("Variable '{0}' is used before being assigned."), None, None, None) }
    pub fn type_alias_0_circularly_references_itself() -> DiagnosticMessage { diag(2456, DiagnosticCategory::Error, String::from("Type_alias_0_circularly_references_itself_2456"), String::from("Type alias '{0}' circularly references itself."), None, None, None) }
    pub fn type_alias_name_cannot_be_0() -> DiagnosticMessage { diag(2457, DiagnosticCategory::Error, String::from("Type_alias_name_cannot_be_0_2457"), String::from("Type alias name cannot be '{0}'."), None, None, None) }
    pub fn an_amd_module_cannot_have_multiple_name_assignments() -> DiagnosticMessage { diag(2458, DiagnosticCategory::Error, String::from("An_AMD_module_cannot_have_multiple_name_assignments_2458"), String::from("An AMD module cannot have multiple name assignments."), None, None, None) }
    pub fn module_0_declares_1_locally_but_it_is_not_exported() -> DiagnosticMessage { diag(2459, DiagnosticCategory::Error, String::from("Module_0_declares_1_locally_but_it_is_not_exported_2459"), String::from("Module '{0}' declares '{1}' locally, but it is not exported."), None, None, None) }
    pub fn module_0_declares_1_locally_but_it_is_exported_as_2() -> DiagnosticMessage { diag(2460, DiagnosticCategory::Error, String::from("Module_0_declares_1_locally_but_it_is_exported_as_2_2460"), String::from("Module '{0}' declares '{1}' locally, but it is exported as '{2}'."), None, None, None) }
    pub fn type_0_is_not_an_array_type() -> DiagnosticMessage { diag(2461, DiagnosticCategory::Error, String::from("Type_0_is_not_an_array_type_2461"), String::from("Type '{0}' is not an array type."), None, None, None) }
    pub fn a_rest_element_must_be_last_in_a_destructuring_pattern() -> DiagnosticMessage { diag(2462, DiagnosticCategory::Error, String::from("A_rest_element_must_be_last_in_a_destructuring_pattern_2462"), String::from("A rest element must be last in a destructuring pattern."), None, None, None) }
    pub fn a_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature() -> DiagnosticMessage { diag(2463, DiagnosticCategory::Error, String::from("A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463"), String::from("A binding pattern parameter cannot be optional in an implementation signature."), None, None, None) }
    pub fn a_computed_property_name_must_be_of_type_string_number_symbol_or_any() -> DiagnosticMessage { diag(2464, DiagnosticCategory::Error, String::from("A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464"), String::from("A computed property name must be of type 'string', 'number', 'symbol', or 'any'."), None, None, None) }
    pub fn this_cannot_be_referenced_in_a_computed_property_name() -> DiagnosticMessage { diag(2465, DiagnosticCategory::Error, String::from("this_cannot_be_referenced_in_a_computed_property_name_2465"), String::from("'this' cannot be referenced in a computed property name."), None, None, None) }
    pub fn super_cannot_be_referenced_in_a_computed_property_name() -> DiagnosticMessage { diag(2466, DiagnosticCategory::Error, String::from("super_cannot_be_referenced_in_a_computed_property_name_2466"), String::from("'super' cannot be referenced in a computed property name."), None, None, None) }
    pub fn a_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type() -> DiagnosticMessage { diag(2467, DiagnosticCategory::Error, String::from("A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467"), String::from("A computed property name cannot reference a type parameter from its containing type."), None, None, None) }
    pub fn cannot_find_global_value_0() -> DiagnosticMessage { diag(2468, DiagnosticCategory::Error, String::from("Cannot_find_global_value_0_2468"), String::from("Cannot find global value '{0}'."), None, None, None) }
    pub fn the_0_operator_cannot_be_applied_to_type_symbol() -> DiagnosticMessage { diag(2469, DiagnosticCategory::Error, String::from("The_0_operator_cannot_be_applied_to_type_symbol_2469"), String::from("The '{0}' operator cannot be applied to type 'symbol'."), None, None, None) }
    pub fn spread_operator_in_new_expressions_is_only_available_when_targeting_ecmascript_5_and_higher() -> DiagnosticMessage { diag(2472, DiagnosticCategory::Error, String::from("Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472"), String::from("Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher."), None, None, None) }
    pub fn enum_declarations_must_all_be_const_or_non_const() -> DiagnosticMessage { diag(2473, DiagnosticCategory::Error, String::from("Enum_declarations_must_all_be_const_or_non_const_2473"), String::from("Enum declarations must all be const or non-const."), None, None, None) }
    pub fn const_enum_member_initializers_must_be_constant_expressions() -> DiagnosticMessage { diag(2474, DiagnosticCategory::Error, String::from("const_enum_member_initializers_must_be_constant_expressions_2474"), String::from("const enum member initializers must be constant expressions."), None, None, None) }
    pub fn const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query() -> DiagnosticMessage { diag(2475, DiagnosticCategory::Error, String::from("const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475"), String::from("'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query."), None, None, None) }
    pub fn a_const_enum_member_can_only_be_accessed_using_a_string_literal() -> DiagnosticMessage { diag(2476, DiagnosticCategory::Error, String::from("A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476"), String::from("A const enum member can only be accessed using a string literal."), None, None, None) }
    pub fn const_enum_member_initializer_was_evaluated_to_a_non_finite_value() -> DiagnosticMessage { diag(2477, DiagnosticCategory::Error, String::from("const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477"), String::from("'const' enum member initializer was evaluated to a non-finite value."), None, None, None) }
    pub fn const_enum_member_initializer_was_evaluated_to_disallowed_value_nan() -> DiagnosticMessage { diag(2478, DiagnosticCategory::Error, String::from("const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478"), String::from("'const' enum member initializer was evaluated to disallowed value 'NaN'."), None, None, None) }
    pub fn let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations() -> DiagnosticMessage { diag(2480, DiagnosticCategory::Error, String::from("let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480"), String::from("'let' is not allowed to be used as a name in 'let' or 'const' declarations."), None, None, None) }
    pub fn cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1() -> DiagnosticMessage { diag(2481, DiagnosticCategory::Error, String::from("Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481"), String::from("Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation() -> DiagnosticMessage { diag(2483, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483"), String::from("The left-hand side of a 'for...of' statement cannot use a type annotation."), None, None, None) }
    pub fn export_declaration_conflicts_with_exported_declaration_of_0() -> DiagnosticMessage { diag(2484, DiagnosticCategory::Error, String::from("Export_declaration_conflicts_with_exported_declaration_of_0_2484"), String::from("Export declaration conflicts with exported declaration of '{0}'."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access() -> DiagnosticMessage { diag(2487, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487"), String::from("The left-hand side of a 'for...of' statement must be a variable or a property access."), None, None, None) }
    pub fn type_0_must_have_a_symbol_iterator_method_that_returns_an_iterator() -> DiagnosticMessage { diag(2488, DiagnosticCategory::Error, String::from("Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488"), String::from("Type '{0}' must have a '[Symbol.iterator]()' method that returns an iterator."), None, None, None) }
    pub fn an_iterator_must_have_a_next_method() -> DiagnosticMessage { diag(2489, DiagnosticCategory::Error, String::from("An_iterator_must_have_a_next_method_2489"), String::from("An iterator must have a 'next()' method."), None, None, None) }
    pub fn the_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property() -> DiagnosticMessage { diag(2490, DiagnosticCategory::Error, String::from("The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property_2490"), String::from("The type returned by the '{0}()' method of an iterator must have a 'value' property."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern() -> DiagnosticMessage { diag(2491, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491"), String::from("The left-hand side of a 'for...in' statement cannot be a destructuring pattern."), None, None, None) }
    pub fn cannot_redeclare_identifier_0_in_catch_clause() -> DiagnosticMessage { diag(2492, DiagnosticCategory::Error, String::from("Cannot_redeclare_identifier_0_in_catch_clause_2492"), String::from("Cannot redeclare identifier '{0}' in catch clause."), None, None, None) }
    pub fn tuple_type_0_of_length_1_has_no_element_at_index_2() -> DiagnosticMessage { diag(2493, DiagnosticCategory::Error, String::from("Tuple_type_0_of_length_1_has_no_element_at_index_2_2493"), String::from("Tuple type '{0}' of length '{1}' has no element at index '{2}'."), None, None, None) }
    pub fn using_a_string_in_a_for_of_statement_is_only_supported_in_ecmascript_5_and_higher() -> DiagnosticMessage { diag(2494, DiagnosticCategory::Error, String::from("Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494"), String::from("Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher."), None, None, None) }
    pub fn type_0_is_not_an_array_type_or_a_string_type() -> DiagnosticMessage { diag(2495, DiagnosticCategory::Error, String::from("Type_0_is_not_an_array_type_or_a_string_type_2495"), String::from("Type '{0}' is not an array type or a string type."), None, None, None) }
    pub fn the_arguments_object_cannot_be_referenced_in_an_arrow_function_in_es5_consider_using_a_standard_function_expression() -> DiagnosticMessage { diag(2496, DiagnosticCategory::Error, String::from("The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_func_2496"), String::from("The 'arguments' object cannot be referenced in an arrow function in ES5. Consider using a standard function expression."), None, None, None) }
    pub fn this_module_can_only_be_referenced_with_ecmascript_imports_slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export() -> DiagnosticMessage { diag(2497, DiagnosticCategory::Error, String::from("This_module_can_only_be_referenced_with_ECMAScript_imports_slashexports_by_turning_on_the_0_flag_and_2497"), String::from("This module can only be referenced with ECMAScript imports/exports by turning on the '{0}' flag and referencing its default export."), None, None, None) }
    pub fn module_0_uses_export_and_cannot_be_used_with_export_asterisk() -> DiagnosticMessage { diag(2498, DiagnosticCategory::Error, String::from("Module_0_uses_export_and_cannot_be_used_with_export_asterisk_2498"), String::from("Module '{0}' uses 'export =' and cannot be used with 'export *'."), None, None, None) }
    pub fn an_interface_can_only_extend_an_identifier_slashqualified_name_with_optional_type_arguments() -> DiagnosticMessage { diag(2499, DiagnosticCategory::Error, String::from("An_interface_can_only_extend_an_identifier_slashqualified_name_with_optional_type_arguments_2499"), String::from("An interface can only extend an identifier/qualified-name with optional type arguments."), None, None, None) }
    pub fn a_class_can_only_implement_an_identifier_slashqualified_name_with_optional_type_arguments() -> DiagnosticMessage { diag(2500, DiagnosticCategory::Error, String::from("A_class_can_only_implement_an_identifier_slashqualified_name_with_optional_type_arguments_2500"), String::from("A class can only implement an identifier/qualified-name with optional type arguments."), None, None, None) }
    pub fn a_rest_element_cannot_contain_a_binding_pattern() -> DiagnosticMessage { diag(2501, DiagnosticCategory::Error, String::from("A_rest_element_cannot_contain_a_binding_pattern_2501"), String::from("A rest element cannot contain a binding pattern."), None, None, None) }
    pub fn _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation() -> DiagnosticMessage { diag(2502, DiagnosticCategory::Error, String::from("_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502"), String::from("'{0}' is referenced directly or indirectly in its own type annotation."), None, None, None) }
    pub fn cannot_find_namespace_0() -> DiagnosticMessage { diag(2503, DiagnosticCategory::Error, String::from("Cannot_find_namespace_0_2503"), String::from("Cannot find namespace '{0}'."), None, None, None) }
    pub fn type_0_must_have_a_symbol_asynciterator_method_that_returns_an_async_iterator() -> DiagnosticMessage { diag(2504, DiagnosticCategory::Error, String::from("Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504"), String::from("Type '{0}' must have a '[Symbol.asyncIterator]()' method that returns an async iterator."), None, None, None) }
    pub fn a_generator_cannot_have_a_void_type_annotation() -> DiagnosticMessage { diag(2505, DiagnosticCategory::Error, String::from("A_generator_cannot_have_a_void_type_annotation_2505"), String::from("A generator cannot have a 'void' type annotation."), None, None, None) }
    pub fn _0_is_referenced_directly_or_indirectly_in_its_own_base_expression() -> DiagnosticMessage { diag(2506, DiagnosticCategory::Error, String::from("_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506"), String::from("'{0}' is referenced directly or indirectly in its own base expression."), None, None, None) }
    pub fn type_0_is_not_a_constructor_function_type() -> DiagnosticMessage { diag(2507, DiagnosticCategory::Error, String::from("Type_0_is_not_a_constructor_function_type_2507"), String::from("Type '{0}' is not a constructor function type."), None, None, None) }
    pub fn no_base_constructor_has_the_specified_number_of_type_arguments() -> DiagnosticMessage { diag(2508, DiagnosticCategory::Error, String::from("No_base_constructor_has_the_specified_number_of_type_arguments_2508"), String::from("No base constructor has the specified number of type arguments."), None, None, None) }
    pub fn base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members() -> DiagnosticMessage { diag(2509, DiagnosticCategory::Error, String::from("Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_2509"), String::from("Base constructor return type '{0}' is not an object type or intersection of object types with statically known members."), None, None, None) }
    pub fn base_constructors_must_all_have_the_same_return_type() -> DiagnosticMessage { diag(2510, DiagnosticCategory::Error, String::from("Base_constructors_must_all_have_the_same_return_type_2510"), String::from("Base constructors must all have the same return type."), None, None, None) }
    pub fn cannot_create_an_instance_of_an_abstract_class() -> DiagnosticMessage { diag(2511, DiagnosticCategory::Error, String::from("Cannot_create_an_instance_of_an_abstract_class_2511"), String::from("Cannot create an instance of an abstract class."), None, None, None) }
    pub fn overload_signatures_must_all_be_abstract_or_non_abstract() -> DiagnosticMessage { diag(2512, DiagnosticCategory::Error, String::from("Overload_signatures_must_all_be_abstract_or_non_abstract_2512"), String::from("Overload signatures must all be abstract or non-abstract."), None, None, None) }
    pub fn abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression() -> DiagnosticMessage { diag(2513, DiagnosticCategory::Error, String::from("Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513"), String::from("Abstract method '{0}' in class '{1}' cannot be accessed via super expression."), None, None, None) }
    pub fn a_tuple_type_cannot_be_indexed_with_a_negative_value() -> DiagnosticMessage { diag(2514, DiagnosticCategory::Error, String::from("A_tuple_type_cannot_be_indexed_with_a_negative_value_2514"), String::from("A tuple type cannot be indexed with a negative value."), None, None, None) }
    pub fn non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2() -> DiagnosticMessage { diag(2515, DiagnosticCategory::Error, String::from("Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515"), String::from("Non-abstract class '{0}' does not implement inherited abstract member {1} from class '{2}'."), None, None, None) }
    pub fn all_declarations_of_an_abstract_method_must_be_consecutive() -> DiagnosticMessage { diag(2516, DiagnosticCategory::Error, String::from("All_declarations_of_an_abstract_method_must_be_consecutive_2516"), String::from("All declarations of an abstract method must be consecutive."), None, None, None) }
    pub fn cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type() -> DiagnosticMessage { diag(2517, DiagnosticCategory::Error, String::from("Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517"), String::from("Cannot assign an abstract constructor type to a non-abstract constructor type."), None, None, None) }
    pub fn a_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard() -> DiagnosticMessage { diag(2518, DiagnosticCategory::Error, String::from("A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518"), String::from("A 'this'-based type guard is not compatible with a parameter-based type guard."), None, None, None) }
    pub fn an_async_iterator_must_have_a_next_method() -> DiagnosticMessage { diag(2519, DiagnosticCategory::Error, String::from("An_async_iterator_must_have_a_next_method_2519"), String::from("An async iterator must have a 'next()' method."), None, None, None) }
    pub fn duplicate_identifier_0_compiler_uses_declaration_1_to_support_async_functions() -> DiagnosticMessage { diag(2520, DiagnosticCategory::Error, String::from("Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520"), String::from("Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions."), None, None, None) }
    pub fn the_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_es5_consider_using_a_standard_function_or_method() -> DiagnosticMessage { diag(2522, DiagnosticCategory::Error, String::from("The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_sta_2522"), String::from("The 'arguments' object cannot be referenced in an async function or method in ES5. Consider using a standard function or method."), None, None, None) }
    pub fn yield_expressions_cannot_be_used_in_a_parameter_initializer() -> DiagnosticMessage { diag(2523, DiagnosticCategory::Error, String::from("yield_expressions_cannot_be_used_in_a_parameter_initializer_2523"), String::from("'yield' expressions cannot be used in a parameter initializer."), None, None, None) }
    pub fn await_expressions_cannot_be_used_in_a_parameter_initializer() -> DiagnosticMessage { diag(2524, DiagnosticCategory::Error, String::from("await_expressions_cannot_be_used_in_a_parameter_initializer_2524"), String::from("'await' expressions cannot be used in a parameter initializer."), None, None, None) }
    pub fn a_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface() -> DiagnosticMessage { diag(2526, DiagnosticCategory::Error, String::from("A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526"), String::from("A 'this' type is available only in a non-static member of a class or interface."), None, None, None) }
    pub fn the_inferred_type_of_0_references_an_inaccessible_1_type_a_type_annotation_is_necessary() -> DiagnosticMessage { diag(2527, DiagnosticCategory::Error, String::from("The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary_2527"), String::from("The inferred type of '{0}' references an inaccessible '{1}' type. A type annotation is necessary."), None, None, None) }
    pub fn a_module_cannot_have_multiple_default_exports() -> DiagnosticMessage { diag(2528, DiagnosticCategory::Error, String::from("A_module_cannot_have_multiple_default_exports_2528"), String::from("A module cannot have multiple default exports."), None, None, None) }
    pub fn duplicate_identifier_0_compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions() -> DiagnosticMessage { diag(2529, DiagnosticCategory::Error, String::from("Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529"), String::from("Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions."), None, None, None) }
    pub fn property_0_is_incompatible_with_index_signature() -> DiagnosticMessage { diag(2530, DiagnosticCategory::Error, String::from("Property_0_is_incompatible_with_index_signature_2530"), String::from("Property '{0}' is incompatible with index signature."), None, None, None) }
    pub fn object_is_possibly_null() -> DiagnosticMessage { diag(2531, DiagnosticCategory::Error, String::from("Object_is_possibly_null_2531"), String::from("Object is possibly 'null'."), None, None, None) }
    pub fn object_is_possibly_undefined() -> DiagnosticMessage { diag(2532, DiagnosticCategory::Error, String::from("Object_is_possibly_undefined_2532"), String::from("Object is possibly 'undefined'."), None, None, None) }
    pub fn object_is_possibly_null_or_undefined() -> DiagnosticMessage { diag(2533, DiagnosticCategory::Error, String::from("Object_is_possibly_null_or_undefined_2533"), String::from("Object is possibly 'null' or 'undefined'."), None, None, None) }
    pub fn a_function_returning_never_cannot_have_a_reachable_end_point() -> DiagnosticMessage { diag(2534, DiagnosticCategory::Error, String::from("A_function_returning_never_cannot_have_a_reachable_end_point_2534"), String::from("A function returning 'never' cannot have a reachable end point."), None, None, None) }
    pub fn type_0_cannot_be_used_to_index_type_1() -> DiagnosticMessage { diag(2536, DiagnosticCategory::Error, String::from("Type_0_cannot_be_used_to_index_type_1_2536"), String::from("Type '{0}' cannot be used to index type '{1}'."), None, None, None) }
    pub fn type_0_has_no_matching_index_signature_for_type_1() -> DiagnosticMessage { diag(2537, DiagnosticCategory::Error, String::from("Type_0_has_no_matching_index_signature_for_type_1_2537"), String::from("Type '{0}' has no matching index signature for type '{1}'."), None, None, None) }
    pub fn type_0_cannot_be_used_as_an_index_type() -> DiagnosticMessage { diag(2538, DiagnosticCategory::Error, String::from("Type_0_cannot_be_used_as_an_index_type_2538"), String::from("Type '{0}' cannot be used as an index type."), None, None, None) }
    pub fn cannot_assign_to_0_because_it_is_not_a_variable() -> DiagnosticMessage { diag(2539, DiagnosticCategory::Error, String::from("Cannot_assign_to_0_because_it_is_not_a_variable_2539"), String::from("Cannot assign to '{0}' because it is not a variable."), None, None, None) }
    pub fn cannot_assign_to_0_because_it_is_a_read_only_property() -> DiagnosticMessage { diag(2540, DiagnosticCategory::Error, String::from("Cannot_assign_to_0_because_it_is_a_read_only_property_2540"), String::from("Cannot assign to '{0}' because it is a read-only property."), None, None, None) }
    pub fn index_signature_in_type_0_only_permits_reading() -> DiagnosticMessage { diag(2542, DiagnosticCategory::Error, String::from("Index_signature_in_type_0_only_permits_reading_2542"), String::from("Index signature in type '{0}' only permits reading."), None, None, None) }
    pub fn duplicate_identifier_newtarget_compiler_uses_variable_declaration_newtarget_to_capture_new_target_meta_property_reference() -> DiagnosticMessage { diag(2543, DiagnosticCategory::Error, String::from("Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543"), String::from("Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference."), None, None, None) }
    pub fn expression_resolves_to_variable_declaration_newtarget_that_compiler_uses_to_capture_new_target_meta_property_reference() -> DiagnosticMessage { diag(2544, DiagnosticCategory::Error, String::from("Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544"), String::from("Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference."), None, None, None) }
    pub fn a_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any() -> DiagnosticMessage { diag(2545, DiagnosticCategory::Error, String::from("A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545"), String::from("A mixin class must have a constructor with a single rest parameter of type 'any[]'."), None, None, None) }
    pub fn the_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property() -> DiagnosticMessage { diag(2547, DiagnosticCategory::Error, String::from("The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_pro_2547"), String::from("The type returned by the '{0}()' method of an async iterator must be a promise for a type with a 'value' property."), None, None, None) }
    pub fn type_0_is_not_an_array_type_or_does_not_have_a_symbol_iterator_method_that_returns_an_iterator() -> DiagnosticMessage { diag(2548, DiagnosticCategory::Error, String::from("Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548"), String::from("Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator."), None, None, None) }
    pub fn type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_symbol_iterator_method_that_returns_an_iterator() -> DiagnosticMessage { diag(2549, DiagnosticCategory::Error, String::from("Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549"), String::from("Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator."), None, None, None) }
    pub fn property_0_does_not_exist_on_type_1_do_you_need_to_change_your_target_library_try_changing_the_lib_compiler_option_to_2_or_later() -> DiagnosticMessage { diag(2550, DiagnosticCategory::Error, String::from("Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_c_2550"), String::from("Property '{0}' does not exist on type '{1}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{2}' or later."), None, None, None) }
    pub fn property_0_does_not_exist_on_type_1_did_you_mean_2() -> DiagnosticMessage { diag(2551, DiagnosticCategory::Error, String::from("Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551"), String::from("Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?"), None, None, None) }
    pub fn cannot_find_name_0_did_you_mean_1() -> DiagnosticMessage { diag(2552, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Did_you_mean_1_2552"), String::from("Cannot find name '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn computed_values_are_not_permitted_in_an_enum_with_string_valued_members() -> DiagnosticMessage { diag(2553, DiagnosticCategory::Error, String::from("Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553"), String::from("Computed values are not permitted in an enum with string valued members."), None, None, None) }
    pub fn expected_0_arguments_but_got_1() -> DiagnosticMessage { diag(2554, DiagnosticCategory::Error, String::from("Expected_0_arguments_but_got_1_2554"), String::from("Expected {0} arguments, but got {1}."), None, None, None) }
    pub fn expected_at_least_0_arguments_but_got_1() -> DiagnosticMessage { diag(2555, DiagnosticCategory::Error, String::from("Expected_at_least_0_arguments_but_got_1_2555"), String::from("Expected at least {0} arguments, but got {1}."), None, None, None) }
    pub fn a_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter() -> DiagnosticMessage { diag(2556, DiagnosticCategory::Error, String::from("A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter_2556"), String::from("A spread argument must either have a tuple type or be passed to a rest parameter."), None, None, None) }
    pub fn expected_0_type_arguments_but_got_1() -> DiagnosticMessage { diag(2558, DiagnosticCategory::Error, String::from("Expected_0_type_arguments_but_got_1_2558"), String::from("Expected {0} type arguments, but got {1}."), None, None, None) }
    pub fn type_0_has_no_properties_in_common_with_type_1() -> DiagnosticMessage { diag(2559, DiagnosticCategory::Error, String::from("Type_0_has_no_properties_in_common_with_type_1_2559"), String::from("Type '{0}' has no properties in common with type '{1}'."), None, None, None) }
    pub fn value_of_type_0_has_no_properties_in_common_with_type_1_did_you_mean_to_call_it() -> DiagnosticMessage { diag(2560, DiagnosticCategory::Error, String::from("Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560"), String::from("Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?"), None, None, None) }
    pub fn object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_did_you_mean_to_write_2() -> DiagnosticMessage { diag(2561, DiagnosticCategory::Error, String::from("Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561"), String::from("Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?"), None, None, None) }
    pub fn base_class_expressions_cannot_reference_class_type_parameters() -> DiagnosticMessage { diag(2562, DiagnosticCategory::Error, String::from("Base_class_expressions_cannot_reference_class_type_parameters_2562"), String::from("Base class expressions cannot reference class type parameters."), None, None, None) }
    pub fn the_containing_function_or_module_body_is_too_large_for_control_flow_analysis() -> DiagnosticMessage { diag(2563, DiagnosticCategory::Error, String::from("The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563"), String::from("The containing function or module body is too large for control flow analysis."), None, None, None) }
    pub fn property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor() -> DiagnosticMessage { diag(2564, DiagnosticCategory::Error, String::from("Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor_2564"), String::from("Property '{0}' has no initializer and is not definitely assigned in the constructor."), None, None, None) }
    pub fn property_0_is_used_before_being_assigned() -> DiagnosticMessage { diag(2565, DiagnosticCategory::Error, String::from("Property_0_is_used_before_being_assigned_2565"), String::from("Property '{0}' is used before being assigned."), None, None, None) }
    pub fn a_rest_element_cannot_have_a_property_name() -> DiagnosticMessage { diag(2566, DiagnosticCategory::Error, String::from("A_rest_element_cannot_have_a_property_name_2566"), String::from("A rest element cannot have a property name."), None, None, None) }
    pub fn enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations() -> DiagnosticMessage { diag(2567, DiagnosticCategory::Error, String::from("Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations_2567"), String::from("Enum declarations can only merge with namespace or other enum declarations."), None, None, None) }
    pub fn property_0_may_not_exist_on_type_1_did_you_mean_2() -> DiagnosticMessage { diag(2568, DiagnosticCategory::Error, String::from("Property_0_may_not_exist_on_type_1_Did_you_mean_2_2568"), String::from("Property '{0}' may not exist on type '{1}'. Did you mean '{2}'?"), None, None, None) }
    pub fn could_not_find_name_0_did_you_mean_1() -> DiagnosticMessage { diag(2570, DiagnosticCategory::Error, String::from("Could_not_find_name_0_Did_you_mean_1_2570"), String::from("Could not find name '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn object_is_of_type_unknown() -> DiagnosticMessage { diag(2571, DiagnosticCategory::Error, String::from("Object_is_of_type_unknown_2571"), String::from("Object is of type 'unknown'."), None, None, None) }
    pub fn a_rest_element_type_must_be_an_array_type() -> DiagnosticMessage { diag(2574, DiagnosticCategory::Error, String::from("A_rest_element_type_must_be_an_array_type_2574"), String::from("A rest element type must be an array type."), None, None, None) }
    pub fn no_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments() -> DiagnosticMessage { diag(2575, DiagnosticCategory::Error, String::from("No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments_2575"), String::from("No overload expects {0} arguments, but overloads do exist that expect either {1} or {2} arguments."), None, None, None) }
    pub fn property_0_does_not_exist_on_type_1_did_you_mean_to_access_the_static_member_2_instead() -> DiagnosticMessage { diag(2576, DiagnosticCategory::Error, String::from("Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead_2576"), String::from("Property '{0}' does not exist on type '{1}'. Did you mean to access the static member '{2}' instead?"), None, None, None) }
    pub fn return_type_annotation_circularly_references_itself() -> DiagnosticMessage { diag(2577, DiagnosticCategory::Error, String::from("Return_type_annotation_circularly_references_itself_2577"), String::from("Return type annotation circularly references itself."), None, None, None) }
    pub fn unused_ts_expect_error_directive() -> DiagnosticMessage { diag(2578, DiagnosticCategory::Error, String::from("Unused_ts_expect_error_directive_2578"), String::from("Unused '@ts-expect-error' directive."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_install_type_definitions_for_node_try_npm_i_save_dev_types_slashnode() -> DiagnosticMessage { diag(2580, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_slashno_2580"), String::from("Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_install_type_definitions_for_jquery_try_npm_i_save_dev_types_slashjquery() -> DiagnosticMessage { diag(2581, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_slash_2581"), String::from("Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery`."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_install_type_definitions_for_a_test_runner_try_npm_i_save_dev_types_slashjest_or_npm_i_save_dev_types_slashmocha() -> DiagnosticMessage { diag(2582, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2582"), String::from("Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha`."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_change_your_target_library_try_changing_the_lib_compiler_option_to_1_or_later() -> DiagnosticMessage { diag(2583, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2583"), String::from("Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{1}' or later."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_change_your_target_library_try_changing_the_lib_compiler_option_to_include_dom() -> DiagnosticMessage { diag(2584, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2584"), String::from("Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'."), None, None, None) }
    pub fn _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_do_you_need_to_change_your_target_library_try_changing_the_lib_compiler_option_to_es2015_or_later() -> DiagnosticMessage { diag(2585, DiagnosticCategory::Error, String::from("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_2585"), String::from("'{0}' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the 'lib' compiler option to es2015 or later."), None, None, None) }
    pub fn cannot_assign_to_0_because_it_is_a_constant() -> DiagnosticMessage { diag(2588, DiagnosticCategory::Error, String::from("Cannot_assign_to_0_because_it_is_a_constant_2588"), String::from("Cannot assign to '{0}' because it is a constant."), None, None, None) }
    pub fn type_instantiation_is_excessively_deep_and_possibly_infinite() -> DiagnosticMessage { diag(2589, DiagnosticCategory::Error, String::from("Type_instantiation_is_excessively_deep_and_possibly_infinite_2589"), String::from("Type instantiation is excessively deep and possibly infinite."), None, None, None) }
    pub fn expression_produces_a_union_type_that_is_too_complex_to_represent() -> DiagnosticMessage { diag(2590, DiagnosticCategory::Error, String::from("Expression_produces_a_union_type_that_is_too_complex_to_represent_2590"), String::from("Expression produces a union type that is too complex to represent."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_install_type_definitions_for_node_try_npm_i_save_dev_types_slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig() -> DiagnosticMessage { diag(2591, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_slashno_2591"), String::from("Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_install_type_definitions_for_jquery_try_npm_i_save_dev_types_slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig() -> DiagnosticMessage { diag(2592, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_slash_2592"), String::from("Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery` and then add 'jquery' to the types field in your tsconfig."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_install_type_definitions_for_a_test_runner_try_npm_i_save_dev_types_slashjest_or_npm_i_save_dev_types_slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig() -> DiagnosticMessage { diag(2593, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2593"), String::from("Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig."), None, None, None) }
    pub fn this_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag() -> DiagnosticMessage { diag(2594, DiagnosticCategory::Error, String::from("This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag_2594"), String::from("This module is declared with 'export =', and can only be used with a default import when using the '{0}' flag."), None, None, None) }
    pub fn _0_can_only_be_imported_by_using_a_default_import() -> DiagnosticMessage { diag(2595, DiagnosticCategory::Error, String::from("_0_can_only_be_imported_by_using_a_default_import_2595"), String::from("'{0}' can only be imported by using a default import."), None, None, None) }
    pub fn _0_can_only_be_imported_by_turning_on_the_esmoduleinterop_flag_and_using_a_default_import() -> DiagnosticMessage { diag(2596, DiagnosticCategory::Error, String::from("_0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import_2596"), String::from("'{0}' can only be imported by turning on the 'esModuleInterop' flag and using a default import."), None, None, None) }
    pub fn _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import() -> DiagnosticMessage { diag(2597, DiagnosticCategory::Error, String::from("_0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import_2597"), String::from("'{0}' can only be imported by using a 'require' call or by using a default import."), None, None, None) }
    pub fn _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esmoduleinterop_flag_and_using_a_default_import() -> DiagnosticMessage { diag(2598, DiagnosticCategory::Error, String::from("_0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using__2598"), String::from("'{0}' can only be imported by using a 'require' call or by turning on the 'esModuleInterop' flag and using a default import."), None, None, None) }
    pub fn jsx_element_implicitly_has_type_any_because_the_global_type_jsx_element_does_not_exist() -> DiagnosticMessage { diag(2602, DiagnosticCategory::Error, String::from("JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602"), String::from("JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist."), None, None, None) }
    pub fn property_0_in_type_1_is_not_assignable_to_type_2() -> DiagnosticMessage { diag(2603, DiagnosticCategory::Error, String::from("Property_0_in_type_1_is_not_assignable_to_type_2_2603"), String::from("Property '{0}' in type '{1}' is not assignable to type '{2}'."), None, None, None) }
    pub fn jsx_element_type_0_does_not_have_any_construct_or_call_signatures() -> DiagnosticMessage { diag(2604, DiagnosticCategory::Error, String::from("JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604"), String::from("JSX element type '{0}' does not have any construct or call signatures."), None, None, None) }
    pub fn property_0_of_jsx_spread_attribute_is_not_assignable_to_target_property() -> DiagnosticMessage { diag(2606, DiagnosticCategory::Error, String::from("Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606"), String::from("Property '{0}' of JSX spread attribute is not assignable to target property."), None, None, None) }
    pub fn jsx_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property() -> DiagnosticMessage { diag(2607, DiagnosticCategory::Error, String::from("JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607"), String::from("JSX element class does not support attributes because it does not have a '{0}' property."), None, None, None) }
    pub fn the_global_type_jsx_0_may_not_have_more_than_one_property() -> DiagnosticMessage { diag(2608, DiagnosticCategory::Error, String::from("The_global_type_JSX_0_may_not_have_more_than_one_property_2608"), String::from("The global type 'JSX.{0}' may not have more than one property."), None, None, None) }
    pub fn jsx_spread_child_must_be_an_array_type() -> DiagnosticMessage { diag(2609, DiagnosticCategory::Error, String::from("JSX_spread_child_must_be_an_array_type_2609"), String::from("JSX spread child must be an array type."), None, None, None) }
    pub fn _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property() -> DiagnosticMessage { diag(2610, DiagnosticCategory::Error, String::from("_0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property_2610"), String::from("'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property."), None, None, None) }
    pub fn _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor() -> DiagnosticMessage { diag(2611, DiagnosticCategory::Error, String::from("_0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor_2611"), String::from("'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor."), None, None, None) }
    pub fn property_0_will_overwrite_the_base_property_in_1_if_this_is_intentional_add_an_initializer_otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration() -> DiagnosticMessage { diag(2612, DiagnosticCategory::Error, String::from("Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_2612"), String::from("Property '{0}' will overwrite the base property in '{1}'. If this is intentional, add an initializer. Otherwise, add a 'declare' modifier or remove the redundant declaration."), None, None, None) }
    pub fn module_0_has_no_default_export_did_you_mean_to_use_import_1_from_0_instead() -> DiagnosticMessage { diag(2613, DiagnosticCategory::Error, String::from("Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead_2613"), String::from("Module '{0}' has no default export. Did you mean to use 'import { {1} } from {0}' instead?"), None, None, None) }
    pub fn module_0_has_no_exported_member_1_did_you_mean_to_use_import_1_from_0_instead() -> DiagnosticMessage { diag(2614, DiagnosticCategory::Error, String::from("Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead_2614"), String::from("Module '{0}' has no exported member '{1}'. Did you mean to use 'import {1} from {0}' instead?"), None, None, None) }
    pub fn type_of_property_0_circularly_references_itself_in_mapped_type_1() -> DiagnosticMessage { diag(2615, DiagnosticCategory::Error, String::from("Type_of_property_0_circularly_references_itself_in_mapped_type_1_2615"), String::from("Type of property '{0}' circularly references itself in mapped type '{1}'."), None, None, None) }
    pub fn _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import() -> DiagnosticMessage { diag(2616, DiagnosticCategory::Error, String::from("_0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import_2616"), String::from("'{0}' can only be imported by using 'import {1} = require({2})' or a default import."), None, None, None) }
    pub fn _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esmoduleinterop_flag_and_using_a_default_import() -> DiagnosticMessage { diag(2617, DiagnosticCategory::Error, String::from("_0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_us_2617"), String::from("'{0}' can only be imported by using 'import {1} = require({2})' or by turning on the 'esModuleInterop' flag and using a default import."), None, None, None) }
    pub fn source_has_0_element_s_but_target_requires_1() -> DiagnosticMessage { diag(2618, DiagnosticCategory::Error, String::from("Source_has_0_element_s_but_target_requires_1_2618"), String::from("Source has {0} element(s) but target requires {1}."), None, None, None) }
    pub fn source_has_0_element_s_but_target_allows_only_1() -> DiagnosticMessage { diag(2619, DiagnosticCategory::Error, String::from("Source_has_0_element_s_but_target_allows_only_1_2619"), String::from("Source has {0} element(s) but target allows only {1}."), None, None, None) }
    pub fn target_requires_0_element_s_but_source_may_have_fewer() -> DiagnosticMessage { diag(2620, DiagnosticCategory::Error, String::from("Target_requires_0_element_s_but_source_may_have_fewer_2620"), String::from("Target requires {0} element(s) but source may have fewer."), None, None, None) }
    pub fn target_allows_only_0_element_s_but_source_may_have_more() -> DiagnosticMessage { diag(2621, DiagnosticCategory::Error, String::from("Target_allows_only_0_element_s_but_source_may_have_more_2621"), String::from("Target allows only {0} element(s) but source may have more."), None, None, None) }
    pub fn source_provides_no_match_for_required_element_at_position_0_in_target() -> DiagnosticMessage { diag(2623, DiagnosticCategory::Error, String::from("Source_provides_no_match_for_required_element_at_position_0_in_target_2623"), String::from("Source provides no match for required element at position {0} in target."), None, None, None) }
    pub fn source_provides_no_match_for_variadic_element_at_position_0_in_target() -> DiagnosticMessage { diag(2624, DiagnosticCategory::Error, String::from("Source_provides_no_match_for_variadic_element_at_position_0_in_target_2624"), String::from("Source provides no match for variadic element at position {0} in target."), None, None, None) }
    pub fn variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target() -> DiagnosticMessage { diag(2625, DiagnosticCategory::Error, String::from("Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target_2625"), String::from("Variadic element at position {0} in source does not match element at position {1} in target."), None, None, None) }
    pub fn type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target() -> DiagnosticMessage { diag(2626, DiagnosticCategory::Error, String::from("Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target_2626"), String::from("Type at position {0} in source is not compatible with type at position {1} in target."), None, None, None) }
    pub fn type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target() -> DiagnosticMessage { diag(2627, DiagnosticCategory::Error, String::from("Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target_2627"), String::from("Type at positions {0} through {1} in source is not compatible with type at position {2} in target."), None, None, None) }
    pub fn cannot_assign_to_0_because_it_is_an_enum() -> DiagnosticMessage { diag(2628, DiagnosticCategory::Error, String::from("Cannot_assign_to_0_because_it_is_an_enum_2628"), String::from("Cannot assign to '{0}' because it is an enum."), None, None, None) }
    pub fn cannot_assign_to_0_because_it_is_a_class() -> DiagnosticMessage { diag(2629, DiagnosticCategory::Error, String::from("Cannot_assign_to_0_because_it_is_a_class_2629"), String::from("Cannot assign to '{0}' because it is a class."), None, None, None) }
    pub fn cannot_assign_to_0_because_it_is_a_function() -> DiagnosticMessage { diag(2630, DiagnosticCategory::Error, String::from("Cannot_assign_to_0_because_it_is_a_function_2630"), String::from("Cannot assign to '{0}' because it is a function."), None, None, None) }
    pub fn cannot_assign_to_0_because_it_is_a_namespace() -> DiagnosticMessage { diag(2631, DiagnosticCategory::Error, String::from("Cannot_assign_to_0_because_it_is_a_namespace_2631"), String::from("Cannot assign to '{0}' because it is a namespace."), None, None, None) }
    pub fn cannot_assign_to_0_because_it_is_an_import() -> DiagnosticMessage { diag(2632, DiagnosticCategory::Error, String::from("Cannot_assign_to_0_because_it_is_an_import_2632"), String::from("Cannot assign to '{0}' because it is an import."), None, None, None) }
    pub fn jsx_property_access_expressions_cannot_include_jsx_namespace_names() -> DiagnosticMessage { diag(2633, DiagnosticCategory::Error, String::from("JSX_property_access_expressions_cannot_include_JSX_namespace_names_2633"), String::from("JSX property access expressions cannot include JSX namespace names"), None, None, None) }
    pub fn _0_index_signatures_are_incompatible() -> DiagnosticMessage { diag(2634, DiagnosticCategory::Error, String::from("_0_index_signatures_are_incompatible_2634"), String::from("'{0}' index signatures are incompatible."), None, None, None) }
    pub fn type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable() -> DiagnosticMessage { diag(2635, DiagnosticCategory::Error, String::from("Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable_2635"), String::from("Type '{0}' has no signatures for which the type argument list is applicable."), None, None, None) }
    pub fn type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation() -> DiagnosticMessage { diag(2636, DiagnosticCategory::Error, String::from("Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation_2636"), String::from("Type '{0}' is not assignable to type '{1}' as implied by variance annotation."), None, None, None) }
    pub fn variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types() -> DiagnosticMessage { diag(2637, DiagnosticCategory::Error, String::from("Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_t_2637"), String::from("Variance annotations are only supported in type aliases for object, function, constructor, and mapped types."), None, None, None) }
    pub fn type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator() -> DiagnosticMessage { diag(2638, DiagnosticCategory::Error, String::from("Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operato_2638"), String::from("Type '{0}' may represent a primitive value, which is not permitted as the right operand of the 'in' operator."), None, None, None) }
    pub fn react_components_cannot_include_jsx_namespace_names() -> DiagnosticMessage { diag(2639, DiagnosticCategory::Error, String::from("React_components_cannot_include_JSX_namespace_names_2639"), String::from("React components cannot include JSX namespace names"), None, None, None) }
    pub fn cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity() -> DiagnosticMessage { diag(2649, DiagnosticCategory::Error, String::from("Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649"), String::from("Cannot augment module '{0}' with value exports because it resolves to a non-module entity."), None, None, None) }
    pub fn non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_colon_1_and_2_more() -> DiagnosticMessage { diag(2650, DiagnosticCategory::Error, String::from("Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_colon_1_and__2650"), String::from("Non-abstract class expression is missing implementations for the following members of '{0}': {1} and {2} more."), None, None, None) }
    pub fn a_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums() -> DiagnosticMessage { diag(2651, DiagnosticCategory::Error, String::from("A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651"), String::from("A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums."), None, None, None) }
    pub fn merged_declaration_0_cannot_include_a_default_export_declaration_consider_adding_a_separate_export_default_0_declaration_instead() -> DiagnosticMessage { diag(2652, DiagnosticCategory::Error, String::from("Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652"), String::from("Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead."), None, None, None) }
    pub fn non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1() -> DiagnosticMessage { diag(2653, DiagnosticCategory::Error, String::from("Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653"), String::from("Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'."), None, None, None) }
    pub fn non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_colon_2() -> DiagnosticMessage { diag(2654, DiagnosticCategory::Error, String::from("Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_colon_2_2654"), String::from("Non-abstract class '{0}' is missing implementations for the following members of '{1}': {2}."), None, None, None) }
    pub fn non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_colon_2_and_3_more() -> DiagnosticMessage { diag(2655, DiagnosticCategory::Error, String::from("Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_colon_2_and_3_more_2655"), String::from("Non-abstract class '{0}' is missing implementations for the following members of '{1}': {2} and {3} more."), None, None, None) }
    pub fn non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_colon_1() -> DiagnosticMessage { diag(2656, DiagnosticCategory::Error, String::from("Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_colon_1_2656"), String::from("Non-abstract class expression is missing implementations for the following members of '{0}': {1}."), None, None, None) }
    pub fn jsx_expressions_must_have_one_parent_element() -> DiagnosticMessage { diag(2657, DiagnosticCategory::Error, String::from("JSX_expressions_must_have_one_parent_element_2657"), String::from("JSX expressions must have one parent element."), None, None, None) }
    pub fn type_0_provides_no_match_for_the_signature_1() -> DiagnosticMessage { diag(2658, DiagnosticCategory::Error, String::from("Type_0_provides_no_match_for_the_signature_1_2658"), String::from("Type '{0}' provides no match for the signature '{1}'."), None, None, None) }
    pub fn super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_es2015_or_higher() -> DiagnosticMessage { diag(2659, DiagnosticCategory::Error, String::from("super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659"), String::from("'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher."), None, None, None) }
    pub fn super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions() -> DiagnosticMessage { diag(2660, DiagnosticCategory::Error, String::from("super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660"), String::from("'super' can only be referenced in members of derived classes or object literal expressions."), None, None, None) }
    pub fn cannot_export_0_only_local_declarations_can_be_exported_from_a_module() -> DiagnosticMessage { diag(2661, DiagnosticCategory::Error, String::from("Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661"), String::from("Cannot export '{0}'. Only local declarations can be exported from a module."), None, None, None) }
    pub fn cannot_find_name_0_did_you_mean_the_static_member_1_0() -> DiagnosticMessage { diag(2662, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662"), String::from("Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?"), None, None, None) }
    pub fn cannot_find_name_0_did_you_mean_the_instance_member_this_0() -> DiagnosticMessage { diag(2663, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663"), String::from("Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?"), None, None, None) }
    pub fn invalid_module_name_in_augmentation_module_0_cannot_be_found() -> DiagnosticMessage { diag(2664, DiagnosticCategory::Error, String::from("Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664"), String::from("Invalid module name in augmentation, module '{0}' cannot be found."), None, None, None) }
    pub fn invalid_module_name_in_augmentation_module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented() -> DiagnosticMessage { diag(2665, DiagnosticCategory::Error, String::from("Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665"), String::from("Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented."), None, None, None) }
    pub fn exports_and_export_assignments_are_not_permitted_in_module_augmentations() -> DiagnosticMessage { diag(2666, DiagnosticCategory::Error, String::from("Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666"), String::from("Exports and export assignments are not permitted in module augmentations."), None, None, None) }
    pub fn imports_are_not_permitted_in_module_augmentations_consider_moving_them_to_the_enclosing_external_module() -> DiagnosticMessage { diag(2667, DiagnosticCategory::Error, String::from("Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667"), String::from("Imports are not permitted in module augmentations. Consider moving them to the enclosing external module."), None, None, None) }
    pub fn export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible() -> DiagnosticMessage { diag(2668, DiagnosticCategory::Error, String::from("export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668"), String::from("'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible."), None, None, None) }
    pub fn augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations() -> DiagnosticMessage { diag(2669, DiagnosticCategory::Error, String::from("Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669"), String::from("Augmentations for the global scope can only be directly nested in external modules or ambient module declarations."), None, None, None) }
    pub fn augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context() -> DiagnosticMessage { diag(2670, DiagnosticCategory::Error, String::from("Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670"), String::from("Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context."), None, None, None) }
    pub fn cannot_augment_module_0_because_it_resolves_to_a_non_module_entity() -> DiagnosticMessage { diag(2671, DiagnosticCategory::Error, String::from("Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671"), String::from("Cannot augment module '{0}' because it resolves to a non-module entity."), None, None, None) }
    pub fn cannot_assign_a_0_constructor_type_to_a_1_constructor_type() -> DiagnosticMessage { diag(2672, DiagnosticCategory::Error, String::from("Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672"), String::from("Cannot assign a '{0}' constructor type to a '{1}' constructor type."), None, None, None) }
    pub fn constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration() -> DiagnosticMessage { diag(2673, DiagnosticCategory::Error, String::from("Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673"), String::from("Constructor of class '{0}' is private and only accessible within the class declaration."), None, None, None) }
    pub fn constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration() -> DiagnosticMessage { diag(2674, DiagnosticCategory::Error, String::from("Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674"), String::from("Constructor of class '{0}' is protected and only accessible within the class declaration."), None, None, None) }
    pub fn cannot_extend_a_class_0_class_constructor_is_marked_as_private() -> DiagnosticMessage { diag(2675, DiagnosticCategory::Error, String::from("Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675"), String::from("Cannot extend a class '{0}'. Class constructor is marked as private."), None, None, None) }
    pub fn accessors_must_both_be_abstract_or_non_abstract() -> DiagnosticMessage { diag(2676, DiagnosticCategory::Error, String::from("Accessors_must_both_be_abstract_or_non_abstract_2676"), String::from("Accessors must both be abstract or non-abstract."), None, None, None) }
    pub fn a_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type() -> DiagnosticMessage { diag(2677, DiagnosticCategory::Error, String::from("A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677"), String::from("A type predicate's type must be assignable to its parameter's type."), None, None, None) }
    pub fn type_0_is_not_comparable_to_type_1() -> DiagnosticMessage { diag(2678, DiagnosticCategory::Error, String::from("Type_0_is_not_comparable_to_type_1_2678"), String::from("Type '{0}' is not comparable to type '{1}'."), None, None, None) }
    pub fn a_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void() -> DiagnosticMessage { diag(2679, DiagnosticCategory::Error, String::from("A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679"), String::from("A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'."), None, None, None) }
    pub fn a_0_parameter_must_be_the_first_parameter() -> DiagnosticMessage { diag(2680, DiagnosticCategory::Error, String::from("A_0_parameter_must_be_the_first_parameter_2680"), String::from("A '{0}' parameter must be the first parameter."), None, None, None) }
    pub fn a_constructor_cannot_have_a_this_parameter() -> DiagnosticMessage { diag(2681, DiagnosticCategory::Error, String::from("A_constructor_cannot_have_a_this_parameter_2681"), String::from("A constructor cannot have a 'this' parameter."), None, None, None) }
    pub fn this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation() -> DiagnosticMessage { diag(2683, DiagnosticCategory::Error, String::from("this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683"), String::from("'this' implicitly has type 'any' because it does not have a type annotation."), None, None, None) }
    pub fn the_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1() -> DiagnosticMessage { diag(2684, DiagnosticCategory::Error, String::from("The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684"), String::from("The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'."), None, None, None) }
    pub fn the_this_types_of_each_signature_are_incompatible() -> DiagnosticMessage { diag(2685, DiagnosticCategory::Error, String::from("The_this_types_of_each_signature_are_incompatible_2685"), String::from("The 'this' types of each signature are incompatible."), None, None, None) }
    pub fn _0_refers_to_a_umd_global_but_the_current_file_is_a_module_consider_adding_an_import_instead() -> DiagnosticMessage { diag(2686, DiagnosticCategory::Error, String::from("_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686"), String::from("'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead."), None, None, None) }
    pub fn all_declarations_of_0_must_have_identical_modifiers() -> DiagnosticMessage { diag(2687, DiagnosticCategory::Error, String::from("All_declarations_of_0_must_have_identical_modifiers_2687"), String::from("All declarations of '{0}' must have identical modifiers."), None, None, None) }
    pub fn cannot_find_type_definition_file_for_0() -> DiagnosticMessage { diag(2688, DiagnosticCategory::Error, String::from("Cannot_find_type_definition_file_for_0_2688"), String::from("Cannot find type definition file for '{0}'."), None, None, None) }
    pub fn cannot_extend_an_interface_0_did_you_mean_implements() -> DiagnosticMessage { diag(2689, DiagnosticCategory::Error, String::from("Cannot_extend_an_interface_0_Did_you_mean_implements_2689"), String::from("Cannot extend an interface '{0}'. Did you mean 'implements'?"), None, None, None) }
    pub fn _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_did_you_mean_to_use_1_in_0() -> DiagnosticMessage { diag(2690, DiagnosticCategory::Error, String::from("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0_2690"), String::from("'{0}' only refers to a type, but is being used as a value here. Did you mean to use '{1} in {0}'?"), None, None, None) }
    pub fn _0_is_a_primitive_but_1_is_a_wrapper_object_prefer_using_0_when_possible() -> DiagnosticMessage { diag(2692, DiagnosticCategory::Error, String::from("_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692"), String::from("'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible."), None, None, None) }
    pub fn _0_only_refers_to_a_type_but_is_being_used_as_a_value_here() -> DiagnosticMessage { diag(2693, DiagnosticCategory::Error, String::from("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693"), String::from("'{0}' only refers to a type, but is being used as a value here."), None, None, None) }
    pub fn namespace_0_has_no_exported_member_1() -> DiagnosticMessage { diag(2694, DiagnosticCategory::Error, String::from("Namespace_0_has_no_exported_member_1_2694"), String::from("Namespace '{0}' has no exported member '{1}'."), None, None, None) }
    pub fn left_side_of_comma_operator_is_unused_and_has_no_side_effects() -> DiagnosticMessage { diag(2695, DiagnosticCategory::Error, String::from("Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695"), String::from("Left side of comma operator is unused and has no side effects."), Some(true), None, None) }
    pub fn the_object_type_is_assignable_to_very_few_other_types_did_you_mean_to_use_the_any_type_instead() -> DiagnosticMessage { diag(2696, DiagnosticCategory::Error, String::from("The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696"), String::from("The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?"), None, None, None) }
    pub fn an_async_function_or_method_must_return_a_promise_make_sure_you_have_a_declaration_for_promise_or_include_es2015_in_your_lib_option() -> DiagnosticMessage { diag(2697, DiagnosticCategory::Error, String::from("An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697"), String::from("An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."), None, None, None) }
    pub fn spread_types_may_only_be_created_from_object_types() -> DiagnosticMessage { diag(2698, DiagnosticCategory::Error, String::from("Spread_types_may_only_be_created_from_object_types_2698"), String::from("Spread types may only be created from object types."), None, None, None) }
    pub fn static_property_0_conflicts_with_built_in_property_function_0_of_constructor_function_1() -> DiagnosticMessage { diag(2699, DiagnosticCategory::Error, String::from("Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699"), String::from("Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'."), None, None, None) }
    pub fn rest_types_may_only_be_created_from_object_types() -> DiagnosticMessage { diag(2700, DiagnosticCategory::Error, String::from("Rest_types_may_only_be_created_from_object_types_2700"), String::from("Rest types may only be created from object types."), None, None, None) }
    pub fn the_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access() -> DiagnosticMessage { diag(2701, DiagnosticCategory::Error, String::from("The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701"), String::from("The target of an object rest assignment must be a variable or a property access."), None, None, None) }
    pub fn _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here() -> DiagnosticMessage { diag(2702, DiagnosticCategory::Error, String::from("_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702"), String::from("'{0}' only refers to a type, but is being used as a namespace here."), None, None, None) }
    pub fn the_operand_of_a_delete_operator_must_be_a_property_reference() -> DiagnosticMessage { diag(2703, DiagnosticCategory::Error, String::from("The_operand_of_a_delete_operator_must_be_a_property_reference_2703"), String::from("The operand of a 'delete' operator must be a property reference."), None, None, None) }
    pub fn the_operand_of_a_delete_operator_cannot_be_a_read_only_property() -> DiagnosticMessage { diag(2704, DiagnosticCategory::Error, String::from("The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704"), String::from("The operand of a 'delete' operator cannot be a read-only property."), None, None, None) }
    pub fn an_async_function_or_method_in_es5_requires_the_promise_constructor_make_sure_you_have_a_declaration_for_the_promise_constructor_or_include_es2015_in_your_lib_option() -> DiagnosticMessage { diag(2705, DiagnosticCategory::Error, String::from("An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_2705"), String::from("An async function or method in ES5 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."), None, None, None) }
    pub fn required_type_parameters_may_not_follow_optional_type_parameters() -> DiagnosticMessage { diag(2706, DiagnosticCategory::Error, String::from("Required_type_parameters_may_not_follow_optional_type_parameters_2706"), String::from("Required type parameters may not follow optional type parameters."), None, None, None) }
    pub fn generic_type_0_requires_between_1_and_2_type_arguments() -> DiagnosticMessage { diag(2707, DiagnosticCategory::Error, String::from("Generic_type_0_requires_between_1_and_2_type_arguments_2707"), String::from("Generic type '{0}' requires between {1} and {2} type arguments."), None, None, None) }
    pub fn cannot_use_namespace_0_as_a_value() -> DiagnosticMessage { diag(2708, DiagnosticCategory::Error, String::from("Cannot_use_namespace_0_as_a_value_2708"), String::from("Cannot use namespace '{0}' as a value."), None, None, None) }
    pub fn cannot_use_namespace_0_as_a_type() -> DiagnosticMessage { diag(2709, DiagnosticCategory::Error, String::from("Cannot_use_namespace_0_as_a_type_2709"), String::from("Cannot use namespace '{0}' as a type."), None, None, None) }
    pub fn _0_are_specified_twice_the_attribute_named_0_will_be_overwritten() -> DiagnosticMessage { diag(2710, DiagnosticCategory::Error, String::from("_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710"), String::from("'{0}' are specified twice. The attribute named '{0}' will be overwritten."), None, None, None) }
    pub fn a_dynamic_import_call_returns_a_promise_make_sure_you_have_a_declaration_for_promise_or_include_es2015_in_your_lib_option() -> DiagnosticMessage { diag(2711, DiagnosticCategory::Error, String::from("A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711"), String::from("A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."), None, None, None) }
    pub fn a_dynamic_import_call_in_es5_requires_the_promise_constructor_make_sure_you_have_a_declaration_for_the_promise_constructor_or_include_es2015_in_your_lib_option() -> DiagnosticMessage { diag(2712, DiagnosticCategory::Error, String::from("A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_t_2712"), String::from("A dynamic import call in ES5 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."), None, None, None) }
    pub fn cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1() -> DiagnosticMessage { diag(2713, DiagnosticCategory::Error, String::from("Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713"), String::from("Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}[\"{1}\"]'?"), None, None, None) }
    pub fn the_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context() -> DiagnosticMessage { diag(2714, DiagnosticCategory::Error, String::from("The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714"), String::from("The expression of an export assignment must be an identifier or qualified name in an ambient context."), None, None, None) }
    pub fn abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor() -> DiagnosticMessage { diag(2715, DiagnosticCategory::Error, String::from("Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715"), String::from("Abstract property '{0}' in class '{1}' cannot be accessed in the constructor."), None, None, None) }
    pub fn type_parameter_0_has_a_circular_default() -> DiagnosticMessage { diag(2716, DiagnosticCategory::Error, String::from("Type_parameter_0_has_a_circular_default_2716"), String::from("Type parameter '{0}' has a circular default."), None, None, None) }
    pub fn subsequent_property_declarations_must_have_the_same_type_property_0_must_be_of_type_1_but_here_has_type_2() -> DiagnosticMessage { diag(2717, DiagnosticCategory::Error, String::from("Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_t_2717"), String::from("Subsequent property declarations must have the same type.  Property '{0}' must be of type '{1}', but here has type '{2}'."), None, None, None) }
    pub fn duplicate_property_0() -> DiagnosticMessage { diag(2718, DiagnosticCategory::Error, String::from("Duplicate_property_0_2718"), String::from("Duplicate property '{0}'."), None, None, None) }
    pub fn type_0_is_not_assignable_to_type_1_two_different_types_with_this_name_exist_but_they_are_unrelated() -> DiagnosticMessage { diag(2719, DiagnosticCategory::Error, String::from("Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_2719"), String::from("Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated."), None, None, None) }
    pub fn class_0_incorrectly_implements_class_1_did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass() -> DiagnosticMessage { diag(2720, DiagnosticCategory::Error, String::from("Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclas_2720"), String::from("Class '{0}' incorrectly implements class '{1}'. Did you mean to extend '{1}' and inherit its members as a subclass?"), None, None, None) }
    pub fn cannot_invoke_an_object_which_is_possibly_null() -> DiagnosticMessage { diag(2721, DiagnosticCategory::Error, String::from("Cannot_invoke_an_object_which_is_possibly_null_2721"), String::from("Cannot invoke an object which is possibly 'null'."), None, None, None) }
    pub fn cannot_invoke_an_object_which_is_possibly_undefined() -> DiagnosticMessage { diag(2722, DiagnosticCategory::Error, String::from("Cannot_invoke_an_object_which_is_possibly_undefined_2722"), String::from("Cannot invoke an object which is possibly 'undefined'."), None, None, None) }
    pub fn cannot_invoke_an_object_which_is_possibly_null_or_undefined() -> DiagnosticMessage { diag(2723, DiagnosticCategory::Error, String::from("Cannot_invoke_an_object_which_is_possibly_null_or_undefined_2723"), String::from("Cannot invoke an object which is possibly 'null' or 'undefined'."), None, None, None) }
    pub fn _0_has_no_exported_member_named_1_did_you_mean_2() -> DiagnosticMessage { diag(2724, DiagnosticCategory::Error, String::from("_0_has_no_exported_member_named_1_Did_you_mean_2_2724"), String::from("'{0}' has no exported member named '{1}'. Did you mean '{2}'?"), None, None, None) }
    pub fn class_name_cannot_be_object_when_targeting_es5_with_module_0() -> DiagnosticMessage { diag(2725, DiagnosticCategory::Error, String::from("Class_name_cannot_be_Object_when_targeting_ES5_with_module_0_2725"), String::from("Class name cannot be 'Object' when targeting ES5 with module {0}."), None, None, None) }
    pub fn cannot_find_lib_definition_for_0() -> DiagnosticMessage { diag(2726, DiagnosticCategory::Error, String::from("Cannot_find_lib_definition_for_0_2726"), String::from("Cannot find lib definition for '{0}'."), None, None, None) }
    pub fn cannot_find_lib_definition_for_0_did_you_mean_1() -> DiagnosticMessage { diag(2727, DiagnosticCategory::Error, String::from("Cannot_find_lib_definition_for_0_Did_you_mean_1_2727"), String::from("Cannot find lib definition for '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn _0_is_declared_here() -> DiagnosticMessage { diag(2728, DiagnosticCategory::Message, String::from("_0_is_declared_here_2728"), String::from("'{0}' is declared here."), None, None, None) }
    pub fn property_0_is_used_before_its_initialization() -> DiagnosticMessage { diag(2729, DiagnosticCategory::Error, String::from("Property_0_is_used_before_its_initialization_2729"), String::from("Property '{0}' is used before its initialization."), None, None, None) }
    pub fn an_arrow_function_cannot_have_a_this_parameter() -> DiagnosticMessage { diag(2730, DiagnosticCategory::Error, String::from("An_arrow_function_cannot_have_a_this_parameter_2730"), String::from("An arrow function cannot have a 'this' parameter."), None, None, None) }
    pub fn implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_consider_wrapping_this_expression_in_string() -> DiagnosticMessage { diag(2731, DiagnosticCategory::Error, String::from("Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_i_2731"), String::from("Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'."), None, None, None) }
    pub fn cannot_find_module_0_consider_using_resolvejsonmodule_to_import_module_with_json_extension() -> DiagnosticMessage { diag(2732, DiagnosticCategory::Error, String::from("Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension_2732"), String::from("Cannot find module '{0}'. Consider using '--resolveJsonModule' to import module with '.json' extension."), None, None, None) }
    pub fn property_0_was_also_declared_here() -> DiagnosticMessage { diag(2733, DiagnosticCategory::Error, String::from("Property_0_was_also_declared_here_2733"), String::from("Property '{0}' was also declared here."), None, None, None) }
    pub fn are_you_missing_a_semicolon() -> DiagnosticMessage { diag(2734, DiagnosticCategory::Error, String::from("Are_you_missing_a_semicolon_2734"), String::from("Are you missing a semicolon?"), None, None, None) }
    pub fn did_you_mean_for_0_to_be_constrained_to_type_new_args_colon_any_1() -> DiagnosticMessage { diag(2735, DiagnosticCategory::Error, String::from("Did_you_mean_for_0_to_be_constrained_to_type_new_args_colon_any_1_2735"), String::from("Did you mean for '{0}' to be constrained to type 'new (...args: any[]) => {1}'?"), None, None, None) }
    pub fn operator_0_cannot_be_applied_to_type_1() -> DiagnosticMessage { diag(2736, DiagnosticCategory::Error, String::from("Operator_0_cannot_be_applied_to_type_1_2736"), String::from("Operator '{0}' cannot be applied to type '{1}'."), None, None, None) }
    pub fn bigint_literals_are_not_available_when_targeting_lower_than_es2020() -> DiagnosticMessage { diag(2737, DiagnosticCategory::Error, String::from("BigInt_literals_are_not_available_when_targeting_lower_than_ES2020_2737"), String::from("BigInt literals are not available when targeting lower than ES2020."), None, None, None) }
    pub fn an_outer_value_of_this_is_shadowed_by_this_container() -> DiagnosticMessage { diag(2738, DiagnosticCategory::Message, String::from("An_outer_value_of_this_is_shadowed_by_this_container_2738"), String::from("An outer value of 'this' is shadowed by this container."), None, None, None) }
    pub fn type_0_is_missing_the_following_properties_from_type_1_colon_2() -> DiagnosticMessage { diag(2739, DiagnosticCategory::Error, String::from("Type_0_is_missing_the_following_properties_from_type_1_colon_2_2739"), String::from("Type '{0}' is missing the following properties from type '{1}': {2}"), None, None, None) }
    pub fn type_0_is_missing_the_following_properties_from_type_1_colon_2_and_3_more() -> DiagnosticMessage { diag(2740, DiagnosticCategory::Error, String::from("Type_0_is_missing_the_following_properties_from_type_1_colon_2_and_3_more_2740"), String::from("Type '{0}' is missing the following properties from type '{1}': {2}, and {3} more."), None, None, None) }
    pub fn property_0_is_missing_in_type_1_but_required_in_type_2() -> DiagnosticMessage { diag(2741, DiagnosticCategory::Error, String::from("Property_0_is_missing_in_type_1_but_required_in_type_2_2741"), String::from("Property '{0}' is missing in type '{1}' but required in type '{2}'."), None, None, None) }
    pub fn the_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_this_is_likely_not_portable_a_type_annotation_is_necessary() -> DiagnosticMessage { diag(2742, DiagnosticCategory::Error, String::from("The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_a_2742"), String::from("The inferred type of '{0}' cannot be named without a reference to '{1}'. This is likely not portable. A type annotation is necessary."), None, None, None) }
    pub fn no_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments() -> DiagnosticMessage { diag(2743, DiagnosticCategory::Error, String::from("No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments_2743"), String::from("No overload expects {0} type arguments, but overloads do exist that expect either {1} or {2} type arguments."), None, None, None) }
    pub fn type_parameter_defaults_can_only_reference_previously_declared_type_parameters() -> DiagnosticMessage { diag(2744, DiagnosticCategory::Error, String::from("Type_parameter_defaults_can_only_reference_previously_declared_type_parameters_2744"), String::from("Type parameter defaults can only reference previously declared type parameters."), None, None, None) }
    pub fn this_jsx_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided() -> DiagnosticMessage { diag(2745, DiagnosticCategory::Error, String::from("This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_pr_2745"), String::from("This JSX tag's '{0}' prop expects type '{1}' which requires multiple children, but only a single child was provided."), None, None, None) }
    pub fn this_jsx_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided() -> DiagnosticMessage { diag(2746, DiagnosticCategory::Error, String::from("This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided_2746"), String::from("This JSX tag's '{0}' prop expects a single child of type '{1}', but multiple children were provided."), None, None, None) }
    pub fn _0_components_don_t_accept_text_as_child_elements_text_in_jsx_has_the_type_string_but_the_expected_type_of_1_is_2() -> DiagnosticMessage { diag(2747, DiagnosticCategory::Error, String::from("_0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_t_2747"), String::from("'{0}' components don't accept text as child elements. Text in JSX has the type 'string', but the expected type of '{1}' is '{2}'."), None, None, None) }
    pub fn cannot_access_ambient_const_enums_when_0_is_enabled() -> DiagnosticMessage { diag(2748, DiagnosticCategory::Error, String::from("Cannot_access_ambient_const_enums_when_0_is_enabled_2748"), String::from("Cannot access ambient const enums when '{0}' is enabled."), None, None, None) }
    pub fn _0_refers_to_a_value_but_is_being_used_as_a_type_here_did_you_mean_typeof_0() -> DiagnosticMessage { diag(2749, DiagnosticCategory::Error, String::from("_0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0_2749"), String::from("'{0}' refers to a value, but is being used as a type here. Did you mean 'typeof {0}'?"), None, None, None) }
    pub fn the_implementation_signature_is_declared_here() -> DiagnosticMessage { diag(2750, DiagnosticCategory::Error, String::from("The_implementation_signature_is_declared_here_2750"), String::from("The implementation signature is declared here."), None, None, None) }
    pub fn circularity_originates_in_type_at_this_location() -> DiagnosticMessage { diag(2751, DiagnosticCategory::Error, String::from("Circularity_originates_in_type_at_this_location_2751"), String::from("Circularity originates in type at this location."), None, None, None) }
    pub fn the_first_export_default_is_here() -> DiagnosticMessage { diag(2752, DiagnosticCategory::Error, String::from("The_first_export_default_is_here_2752"), String::from("The first export default is here."), None, None, None) }
    pub fn another_export_default_is_here() -> DiagnosticMessage { diag(2753, DiagnosticCategory::Error, String::from("Another_export_default_is_here_2753"), String::from("Another export default is here."), None, None, None) }
    pub fn super_may_not_use_type_arguments() -> DiagnosticMessage { diag(2754, DiagnosticCategory::Error, String::from("super_may_not_use_type_arguments_2754"), String::from("'super' may not use type arguments."), None, None, None) }
    pub fn no_constituent_of_type_0_is_callable() -> DiagnosticMessage { diag(2755, DiagnosticCategory::Error, String::from("No_constituent_of_type_0_is_callable_2755"), String::from("No constituent of type '{0}' is callable."), None, None, None) }
    pub fn not_all_constituents_of_type_0_are_callable() -> DiagnosticMessage { diag(2756, DiagnosticCategory::Error, String::from("Not_all_constituents_of_type_0_are_callable_2756"), String::from("Not all constituents of type '{0}' are callable."), None, None, None) }
    pub fn type_0_has_no_call_signatures() -> DiagnosticMessage { diag(2757, DiagnosticCategory::Error, String::from("Type_0_has_no_call_signatures_2757"), String::from("Type '{0}' has no call signatures."), None, None, None) }
    pub fn each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other() -> DiagnosticMessage { diag(2758, DiagnosticCategory::Error, String::from("Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_2758"), String::from("Each member of the union type '{0}' has signatures, but none of those signatures are compatible with each other."), None, None, None) }
    pub fn no_constituent_of_type_0_is_constructable() -> DiagnosticMessage { diag(2759, DiagnosticCategory::Error, String::from("No_constituent_of_type_0_is_constructable_2759"), String::from("No constituent of type '{0}' is constructable."), None, None, None) }
    pub fn not_all_constituents_of_type_0_are_constructable() -> DiagnosticMessage { diag(2760, DiagnosticCategory::Error, String::from("Not_all_constituents_of_type_0_are_constructable_2760"), String::from("Not all constituents of type '{0}' are constructable."), None, None, None) }
    pub fn type_0_has_no_construct_signatures() -> DiagnosticMessage { diag(2761, DiagnosticCategory::Error, String::from("Type_0_has_no_construct_signatures_2761"), String::from("Type '{0}' has no construct signatures."), None, None, None) }
    pub fn each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other() -> DiagnosticMessage { diag(2762, DiagnosticCategory::Error, String::from("Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_2762"), String::from("Each member of the union type '{0}' has construct signatures, but none of those signatures are compatible with each other."), None, None, None) }
    pub fn cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0() -> DiagnosticMessage { diag(2763, DiagnosticCategory::Error, String::from("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_s_2763"), String::from("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but for-of will always send '{0}'."), None, None, None) }
    pub fn cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0() -> DiagnosticMessage { diag(2764, DiagnosticCategory::Error, String::from("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_al_2764"), String::from("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array spread will always send '{0}'."), None, None, None) }
    pub fn cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0() -> DiagnosticMessage { diag(2765, DiagnosticCategory::Error, String::from("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring__2765"), String::from("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array destructuring will always send '{0}'."), None, None, None) }
    pub fn cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0() -> DiagnosticMessage { diag(2766, DiagnosticCategory::Error, String::from("Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_co_2766"), String::from("Cannot delegate iteration to value because the 'next' method of its iterator expects type '{1}', but the containing generator will always send '{0}'."), None, None, None) }
    pub fn the_0_property_of_an_iterator_must_be_a_method() -> DiagnosticMessage { diag(2767, DiagnosticCategory::Error, String::from("The_0_property_of_an_iterator_must_be_a_method_2767"), String::from("The '{0}' property of an iterator must be a method."), None, None, None) }
    pub fn the_0_property_of_an_async_iterator_must_be_a_method() -> DiagnosticMessage { diag(2768, DiagnosticCategory::Error, String::from("The_0_property_of_an_async_iterator_must_be_a_method_2768"), String::from("The '{0}' property of an async iterator must be a method."), None, None, None) }
    pub fn no_overload_matches_this_call() -> DiagnosticMessage { diag(2769, DiagnosticCategory::Error, String::from("No_overload_matches_this_call_2769"), String::from("No overload matches this call."), None, None, None) }
    pub fn the_last_overload_gave_the_following_error() -> DiagnosticMessage { diag(2770, DiagnosticCategory::Error, String::from("The_last_overload_gave_the_following_error_2770"), String::from("The last overload gave the following error."), None, None, None) }
    pub fn the_last_overload_is_declared_here() -> DiagnosticMessage { diag(2771, DiagnosticCategory::Error, String::from("The_last_overload_is_declared_here_2771"), String::from("The last overload is declared here."), None, None, None) }
    pub fn overload_0_of_1_2_gave_the_following_error() -> DiagnosticMessage { diag(2772, DiagnosticCategory::Error, String::from("Overload_0_of_1_2_gave_the_following_error_2772"), String::from("Overload {0} of {1}, '{2}', gave the following error."), None, None, None) }
    pub fn did_you_forget_to_use_await() -> DiagnosticMessage { diag(2773, DiagnosticCategory::Error, String::from("Did_you_forget_to_use_await_2773"), String::from("Did you forget to use 'await'?"), None, None, None) }
    pub fn this_condition_will_always_return_true_since_this_function_is_always_defined_did_you_mean_to_call_it_instead() -> DiagnosticMessage { diag(2774, DiagnosticCategory::Error, String::from("This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_2774"), String::from("This condition will always return true since this function is always defined. Did you mean to call it instead?"), None, None, None) }
    pub fn assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation() -> DiagnosticMessage { diag(2775, DiagnosticCategory::Error, String::from("Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation_2775"), String::from("Assertions require every name in the call target to be declared with an explicit type annotation."), None, None, None) }
    pub fn assertions_require_the_call_target_to_be_an_identifier_or_qualified_name() -> DiagnosticMessage { diag(2776, DiagnosticCategory::Error, String::from("Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name_2776"), String::from("Assertions require the call target to be an identifier or qualified name."), None, None, None) }
    pub fn the_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access() -> DiagnosticMessage { diag(2777, DiagnosticCategory::Error, String::from("The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access_2777"), String::from("The operand of an increment or decrement operator may not be an optional property access."), None, None, None) }
    pub fn the_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access() -> DiagnosticMessage { diag(2778, DiagnosticCategory::Error, String::from("The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access_2778"), String::from("The target of an object rest assignment may not be an optional property access."), None, None, None) }
    pub fn the_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access() -> DiagnosticMessage { diag(2779, DiagnosticCategory::Error, String::from("The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access_2779"), String::from("The left-hand side of an assignment expression may not be an optional property access."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access() -> DiagnosticMessage { diag(2780, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access_2780"), String::from("The left-hand side of a 'for...in' statement may not be an optional property access."), None, None, None) }
    pub fn the_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access() -> DiagnosticMessage { diag(2781, DiagnosticCategory::Error, String::from("The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access_2781"), String::from("The left-hand side of a 'for...of' statement may not be an optional property access."), None, None, None) }
    pub fn _0_needs_an_explicit_type_annotation() -> DiagnosticMessage { diag(2782, DiagnosticCategory::Message, String::from("_0_needs_an_explicit_type_annotation_2782"), String::from("'{0}' needs an explicit type annotation."), None, None, None) }
    pub fn _0_is_specified_more_than_once_so_this_usage_will_be_overwritten() -> DiagnosticMessage { diag(2783, DiagnosticCategory::Error, String::from("_0_is_specified_more_than_once_so_this_usage_will_be_overwritten_2783"), String::from("'{0}' is specified more than once, so this usage will be overwritten."), None, None, None) }
    pub fn get_and_set_accessors_cannot_declare_this_parameters() -> DiagnosticMessage { diag(2784, DiagnosticCategory::Error, String::from("get_and_set_accessors_cannot_declare_this_parameters_2784"), String::from("'get' and 'set' accessors cannot declare 'this' parameters."), None, None, None) }
    pub fn this_spread_always_overwrites_this_property() -> DiagnosticMessage { diag(2785, DiagnosticCategory::Error, String::from("This_spread_always_overwrites_this_property_2785"), String::from("This spread always overwrites this property."), None, None, None) }
    pub fn _0_cannot_be_used_as_a_jsx_component() -> DiagnosticMessage { diag(2786, DiagnosticCategory::Error, String::from("_0_cannot_be_used_as_a_JSX_component_2786"), String::from("'{0}' cannot be used as a JSX component."), None, None, None) }
    pub fn its_return_type_0_is_not_a_valid_jsx_element() -> DiagnosticMessage { diag(2787, DiagnosticCategory::Error, String::from("Its_return_type_0_is_not_a_valid_JSX_element_2787"), String::from("Its return type '{0}' is not a valid JSX element."), None, None, None) }
    pub fn its_instance_type_0_is_not_a_valid_jsx_element() -> DiagnosticMessage { diag(2788, DiagnosticCategory::Error, String::from("Its_instance_type_0_is_not_a_valid_JSX_element_2788"), String::from("Its instance type '{0}' is not a valid JSX element."), None, None, None) }
    pub fn its_element_type_0_is_not_a_valid_jsx_element() -> DiagnosticMessage { diag(2789, DiagnosticCategory::Error, String::from("Its_element_type_0_is_not_a_valid_JSX_element_2789"), String::from("Its element type '{0}' is not a valid JSX element."), None, None, None) }
    pub fn the_operand_of_a_delete_operator_must_be_optional() -> DiagnosticMessage { diag(2790, DiagnosticCategory::Error, String::from("The_operand_of_a_delete_operator_must_be_optional_2790"), String::from("The operand of a 'delete' operator must be optional."), None, None, None) }
    pub fn exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later() -> DiagnosticMessage { diag(2791, DiagnosticCategory::Error, String::from("Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_lat_2791"), String::from("Exponentiation cannot be performed on 'bigint' values unless the 'target' option is set to 'es2016' or later."), None, None, None) }
    pub fn cannot_find_module_0_did_you_mean_to_set_the_moduleresolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option() -> DiagnosticMessage { diag(2792, DiagnosticCategory::Error, String::from("Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_t_2792"), String::from("Cannot find module '{0}'. Did you mean to set the 'moduleResolution' option to 'nodenext', or to add aliases to the 'paths' option?"), None, None, None) }
    pub fn the_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible() -> DiagnosticMessage { diag(2793, DiagnosticCategory::Error, String::from("The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_2793"), String::from("The call would have succeeded against this implementation, but implementation signatures of overloads are not externally visible."), None, None, None) }
    pub fn expected_0_arguments_but_got_1_did_you_forget_to_include_void_in_your_type_argument_to_promise() -> DiagnosticMessage { diag(2794, DiagnosticCategory::Error, String::from("Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise_2794"), String::from("Expected {0} arguments, but got {1}. Did you forget to include 'void' in your type argument to 'Promise'?"), None, None, None) }
    pub fn the_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types() -> DiagnosticMessage { diag(2795, DiagnosticCategory::Error, String::from("The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types_2795"), String::from("The 'intrinsic' keyword can only be used to declare compiler provided intrinsic types."), None, None, None) }
    pub fn it_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_they_form_a_tagged_template_expression_which_cannot_be_invoked() -> DiagnosticMessage { diag(2796, DiagnosticCategory::Error, String::from("It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tag_2796"), String::from("It is likely that you are missing a comma to separate these two template expressions. They form a tagged template expression which cannot be invoked."), None, None, None) }
    pub fn a_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract() -> DiagnosticMessage { diag(2797, DiagnosticCategory::Error, String::from("A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_2797"), String::from("A mixin class that extends from a type variable containing an abstract construct signature must also be declared 'abstract'."), None, None, None) }
    pub fn the_declaration_was_marked_as_deprecated_here() -> DiagnosticMessage { diag(2798, DiagnosticCategory::Error, String::from("The_declaration_was_marked_as_deprecated_here_2798"), String::from("The declaration was marked as deprecated here."), None, None, None) }
    pub fn type_produces_a_tuple_type_that_is_too_large_to_represent() -> DiagnosticMessage { diag(2799, DiagnosticCategory::Error, String::from("Type_produces_a_tuple_type_that_is_too_large_to_represent_2799"), String::from("Type produces a tuple type that is too large to represent."), None, None, None) }
    pub fn expression_produces_a_tuple_type_that_is_too_large_to_represent() -> DiagnosticMessage { diag(2800, DiagnosticCategory::Error, String::from("Expression_produces_a_tuple_type_that_is_too_large_to_represent_2800"), String::from("Expression produces a tuple type that is too large to represent."), None, None, None) }
    pub fn this_condition_will_always_return_true_since_this_0_is_always_defined() -> DiagnosticMessage { diag(2801, DiagnosticCategory::Error, String::from("This_condition_will_always_return_true_since_this_0_is_always_defined_2801"), String::from("This condition will always return true since this '{0}' is always defined."), None, None, None) }
    pub fn type_0_can_only_be_iterated_through_when_using_the_downleveliteration_flag_or_with_a_target_of_es2015_or_higher() -> DiagnosticMessage { diag(2802, DiagnosticCategory::Error, String::from("Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es201_2802"), String::from("Type '{0}' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher."), None, None, None) }
    pub fn cannot_assign_to_private_method_0_private_methods_are_not_writable() -> DiagnosticMessage { diag(2803, DiagnosticCategory::Error, String::from("Cannot_assign_to_private_method_0_Private_methods_are_not_writable_2803"), String::from("Cannot assign to private method '{0}'. Private methods are not writable."), None, None, None) }
    pub fn duplicate_identifier_0_static_and_instance_elements_cannot_share_the_same_private_name() -> DiagnosticMessage { diag(2804, DiagnosticCategory::Error, String::from("Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name_2804"), String::from("Duplicate identifier '{0}'. Static and instance elements cannot share the same private name."), None, None, None) }
    pub fn private_accessor_was_defined_without_a_getter() -> DiagnosticMessage { diag(2806, DiagnosticCategory::Error, String::from("Private_accessor_was_defined_without_a_getter_2806"), String::from("Private accessor was defined without a getter."), None, None, None) }
    pub fn this_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_consider_upgrading_your_version_of_0() -> DiagnosticMessage { diag(2807, DiagnosticCategory::Error, String::from("This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_o_2807"), String::from("This syntax requires an imported helper named '{1}' with {2} parameters, which is not compatible with the one in '{0}'. Consider upgrading your version of '{0}'."), None, None, None) }
    pub fn a_get_accessor_must_be_at_least_as_accessible_as_the_setter() -> DiagnosticMessage { diag(2808, DiagnosticCategory::Error, String::from("A_get_accessor_must_be_at_least_as_accessible_as_the_setter_2808"), String::from("A get accessor must be at least as accessible as the setter"), None, None, None) }
    pub fn declaration_or_statement_expected_this_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_whole_assignment_in_parentheses() -> DiagnosticMessage { diag(2809, DiagnosticCategory::Error, String::from("Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_d_2809"), String::from("Declaration or statement expected. This '=' follows a block of statements, so if you intended to write a destructuring assignment, you might need to wrap the whole assignment in parentheses."), None, None, None) }
    pub fn expected_1_argument_but_got_0_new_promise_needs_a_jsdoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments() -> DiagnosticMessage { diag(2810, DiagnosticCategory::Error, String::from("Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_2810"), String::from("Expected 1 argument, but got 0. 'new Promise()' needs a JSDoc hint to produce a 'resolve' that can be called without arguments."), None, None, None) }
    pub fn initializer_for_property_0() -> DiagnosticMessage { diag(2811, DiagnosticCategory::Error, String::from("Initializer_for_property_0_2811"), String::from("Initializer for property '{0}'"), None, None, None) }
    pub fn property_0_does_not_exist_on_type_1_try_changing_the_lib_compiler_option_to_include_dom() -> DiagnosticMessage { diag(2812, DiagnosticCategory::Error, String::from("Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom_2812"), String::from("Property '{0}' does not exist on type '{1}'. Try changing the 'lib' compiler option to include 'dom'."), None, None, None) }
    pub fn class_declaration_cannot_implement_overload_list_for_0() -> DiagnosticMessage { diag(2813, DiagnosticCategory::Error, String::from("Class_declaration_cannot_implement_overload_list_for_0_2813"), String::from("Class declaration cannot implement overload list for '{0}'."), None, None, None) }
    pub fn function_with_bodies_can_only_merge_with_classes_that_are_ambient() -> DiagnosticMessage { diag(2814, DiagnosticCategory::Error, String::from("Function_with_bodies_can_only_merge_with_classes_that_are_ambient_2814"), String::from("Function with bodies can only merge with classes that are ambient."), None, None, None) }
    pub fn arguments_cannot_be_referenced_in_property_initializers() -> DiagnosticMessage { diag(2815, DiagnosticCategory::Error, String::from("arguments_cannot_be_referenced_in_property_initializers_2815"), String::from("'arguments' cannot be referenced in property initializers."), None, None, None) }
    pub fn cannot_use_this_in_a_static_property_initializer_of_a_decorated_class() -> DiagnosticMessage { diag(2816, DiagnosticCategory::Error, String::from("Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class_2816"), String::from("Cannot use 'this' in a static property initializer of a decorated class."), None, None, None) }
    pub fn property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block() -> DiagnosticMessage { diag(2817, DiagnosticCategory::Error, String::from("Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block_2817"), String::from("Property '{0}' has no initializer and is not definitely assigned in a class static block."), None, None, None) }
    pub fn duplicate_identifier_0_compiler_reserves_name_1_when_emitting_super_references_in_static_initializers() -> DiagnosticMessage { diag(2818, DiagnosticCategory::Error, String::from("Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializer_2818"), String::from("Duplicate identifier '{0}'. Compiler reserves name '{1}' when emitting 'super' references in static initializers."), None, None, None) }
    pub fn namespace_name_cannot_be_0() -> DiagnosticMessage { diag(2819, DiagnosticCategory::Error, String::from("Namespace_name_cannot_be_0_2819"), String::from("Namespace name cannot be '{0}'."), None, None, None) }
    pub fn type_0_is_not_assignable_to_type_1_did_you_mean_2() -> DiagnosticMessage { diag(2820, DiagnosticCategory::Error, String::from("Type_0_is_not_assignable_to_type_1_Did_you_mean_2_2820"), String::from("Type '{0}' is not assignable to type '{1}'. Did you mean '{2}'?"), None, None, None) }
    pub fn import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve() -> DiagnosticMessage { diag(2821, DiagnosticCategory::Error, String::from("Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve_2821"), String::from("Import assertions are only supported when the '--module' option is set to 'esnext', 'nodenext', or 'preserve'."), None, None, None) }
    pub fn import_assertions_cannot_be_used_with_type_only_imports_or_exports() -> DiagnosticMessage { diag(2822, DiagnosticCategory::Error, String::from("Import_assertions_cannot_be_used_with_type_only_imports_or_exports_2822"), String::from("Import assertions cannot be used with type-only imports or exports."), None, None, None) }
    pub fn import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve() -> DiagnosticMessage { diag(2823, DiagnosticCategory::Error, String::from("Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve_2823"), String::from("Import attributes are only supported when the '--module' option is set to 'esnext', 'nodenext', or 'preserve'."), None, None, None) }
    pub fn cannot_find_namespace_0_did_you_mean_1() -> DiagnosticMessage { diag(2833, DiagnosticCategory::Error, String::from("Cannot_find_namespace_0_Did_you_mean_1_2833"), String::from("Cannot find namespace '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn relative_import_paths_need_explicit_file_extensions_in_ecmascript_imports_when_moduleresolution_is_node16_or_nodenext_consider_adding_an_extension_to_the_import_path() -> DiagnosticMessage { diag(2834, DiagnosticCategory::Error, String::from("Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_n_2834"), String::from("Relative import paths need explicit file extensions in ECMAScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Consider adding an extension to the import path."), None, None, None) }
    pub fn relative_import_paths_need_explicit_file_extensions_in_ecmascript_imports_when_moduleresolution_is_node16_or_nodenext_did_you_mean_0() -> DiagnosticMessage { diag(2835, DiagnosticCategory::Error, String::from("Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_n_2835"), String::from("Relative import paths need explicit file extensions in ECMAScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Did you mean '{0}'?"), None, None, None) }
    pub fn import_assertions_are_not_allowed_on_statements_that_compile_to_commonjs_require_calls() -> DiagnosticMessage { diag(2836, DiagnosticCategory::Error, String::from("Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls_2836"), String::from("Import assertions are not allowed on statements that compile to CommonJS 'require' calls."), None, None, None) }
    pub fn import_assertion_values_must_be_string_literal_expressions() -> DiagnosticMessage { diag(2837, DiagnosticCategory::Error, String::from("Import_assertion_values_must_be_string_literal_expressions_2837"), String::from("Import assertion values must be string literal expressions."), None, None, None) }
    pub fn all_declarations_of_0_must_have_identical_constraints() -> DiagnosticMessage { diag(2838, DiagnosticCategory::Error, String::from("All_declarations_of_0_must_have_identical_constraints_2838"), String::from("All declarations of '{0}' must have identical constraints."), None, None, None) }
    pub fn this_condition_will_always_return_0_since_javascript_compares_objects_by_reference_not_value() -> DiagnosticMessage { diag(2839, DiagnosticCategory::Error, String::from("This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value_2839"), String::from("This condition will always return '{0}' since JavaScript compares objects by reference, not value."), None, None, None) }
    pub fn an_interface_cannot_extend_a_primitive_type_like_0_it_can_only_extend_other_named_object_types() -> DiagnosticMessage { diag(2840, DiagnosticCategory::Error, String::from("An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types_2840"), String::from("An interface cannot extend a primitive type like '{0}'. It can only extend other named object types."), None, None, None) }
    pub fn _0_is_an_unused_renaming_of_1_did_you_intend_to_use_it_as_a_type_annotation() -> DiagnosticMessage { diag(2842, DiagnosticCategory::Error, String::from("_0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation_2842"), String::from("'{0}' is an unused renaming of '{1}'. Did you intend to use it as a type annotation?"), None, None, None) }
    pub fn we_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here() -> DiagnosticMessage { diag(2843, DiagnosticCategory::Error, String::from("We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here_2843"), String::from("We can only write a type for '{0}' by adding a type for the entire parameter here."), None, None, None) }
    pub fn type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor() -> DiagnosticMessage { diag(2844, DiagnosticCategory::Error, String::from("Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2844"), String::from("Type of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."), None, None, None) }
    pub fn this_condition_will_always_return_0() -> DiagnosticMessage { diag(2845, DiagnosticCategory::Error, String::from("This_condition_will_always_return_0_2845"), String::from("This condition will always return '{0}'."), None, None, None) }
    pub fn a_declaration_file_cannot_be_imported_without_import_type_did_you_mean_to_import_an_implementation_file_0_instead() -> DiagnosticMessage { diag(2846, DiagnosticCategory::Error, String::from("A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_f_2846"), String::from("A declaration file cannot be imported without 'import type'. Did you mean to import an implementation file '{0}' instead?"), None, None, None) }
    pub fn the_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression() -> DiagnosticMessage { diag(2848, DiagnosticCategory::Error, String::from("The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression_2848"), String::from("The right-hand side of an 'instanceof' expression must not be an instantiation expression."), None, None, None) }
    pub fn target_signature_provides_too_few_arguments_expected_0_or_more_but_got_1() -> DiagnosticMessage { diag(2849, DiagnosticCategory::Error, String::from("Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1_2849"), String::from("Target signature provides too few arguments. Expected {0} or more, but got {1}."), None, None, None) }
    pub fn the_initializer_of_a_using_declaration_must_be_either_an_object_with_a_symbol_dispose_method_or_be_null_or_undefined() -> DiagnosticMessage { diag(2850, DiagnosticCategory::Error, String::from("The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_n_2850"), String::from("The initializer of a 'using' declaration must be either an object with a '[Symbol.dispose]()' method, or be 'null' or 'undefined'."), None, None, None) }
    pub fn the_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_symbol_asyncdispose_or_symbol_dispose_method_or_be_null_or_undefined() -> DiagnosticMessage { diag(2851, DiagnosticCategory::Error, String::from("The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_2851"), String::from("The initializer of an 'await using' declaration must be either an object with a '[Symbol.asyncDispose]()' or '[Symbol.dispose]()' method, or be 'null' or 'undefined'."), None, None, None) }
    pub fn await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules() -> DiagnosticMessage { diag(2852, DiagnosticCategory::Error, String::from("await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_2852"), String::from("'await using' statements are only allowed within async functions and at the top levels of modules."), None, None, None) }
    pub fn await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_consider_adding_an_empty_export_to_make_this_file_a_module() -> DiagnosticMessage { diag(2853, DiagnosticCategory::Error, String::from("await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_th_2853"), String::from("'await using' statements are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."), None, None, None) }
    pub fn top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher() -> DiagnosticMessage { diag(2854, DiagnosticCategory::Error, String::from("Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_sys_2854"), String::from("Top-level 'await using' statements are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', 'nodenext', or 'preserve', and the 'target' option is set to 'es2017' or higher."), None, None, None) }
    pub fn class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super() -> DiagnosticMessage { diag(2855, DiagnosticCategory::Error, String::from("Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super_2855"), String::from("Class field '{0}' defined by the parent class is not accessible in the child class via super."), None, None, None) }
    pub fn import_attributes_are_not_allowed_on_statements_that_compile_to_commonjs_require_calls() -> DiagnosticMessage { diag(2856, DiagnosticCategory::Error, String::from("Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls_2856"), String::from("Import attributes are not allowed on statements that compile to CommonJS 'require' calls."), None, None, None) }
    pub fn import_attributes_cannot_be_used_with_type_only_imports_or_exports() -> DiagnosticMessage { diag(2857, DiagnosticCategory::Error, String::from("Import_attributes_cannot_be_used_with_type_only_imports_or_exports_2857"), String::from("Import attributes cannot be used with type-only imports or exports."), None, None, None) }
    pub fn import_attribute_values_must_be_string_literal_expressions() -> DiagnosticMessage { diag(2858, DiagnosticCategory::Error, String::from("Import_attribute_values_must_be_string_literal_expressions_2858"), String::from("Import attribute values must be string literal expressions."), None, None, None) }
    pub fn excessive_complexity_comparing_types_0_and_1() -> DiagnosticMessage { diag(2859, DiagnosticCategory::Error, String::from("Excessive_complexity_comparing_types_0_and_1_2859"), String::from("Excessive complexity comparing types '{0}' and '{1}'."), None, None, None) }
    pub fn the_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_symbol_hasinstance_method() -> DiagnosticMessage { diag(2860, DiagnosticCategory::Error, String::from("The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_2860"), String::from("The left-hand side of an 'instanceof' expression must be assignable to the first argument of the right-hand side's '[Symbol.hasInstance]' method."), None, None, None) }
    pub fn an_object_s_symbol_hasinstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression() -> DiagnosticMessage { diag(2861, DiagnosticCategory::Error, String::from("An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_han_2861"), String::from("An object's '[Symbol.hasInstance]' method must return a boolean value for it to be used on the right-hand side of an 'instanceof' expression."), None, None, None) }
    pub fn type_0_is_generic_and_can_only_be_indexed_for_reading() -> DiagnosticMessage { diag(2862, DiagnosticCategory::Error, String::from("Type_0_is_generic_and_can_only_be_indexed_for_reading_2862"), String::from("Type '{0}' is generic and can only be indexed for reading."), None, None, None) }
    pub fn a_class_cannot_extend_a_primitive_type_like_0_classes_can_only_extend_constructable_values() -> DiagnosticMessage { diag(2863, DiagnosticCategory::Error, String::from("A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values_2863"), String::from("A class cannot extend a primitive type like '{0}'. Classes can only extend constructable values."), None, None, None) }
    pub fn a_class_cannot_implement_a_primitive_type_like_0_it_can_only_implement_other_named_object_types() -> DiagnosticMessage { diag(2864, DiagnosticCategory::Error, String::from("A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types_2864"), String::from("A class cannot implement a primitive type like '{0}'. It can only implement other named object types."), None, None, None) }
    pub fn import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedmodules_is_enabled() -> DiagnosticMessage { diag(2865, DiagnosticCategory::Error, String::from("Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_2865"), String::from("Import '{0}' conflicts with local value, so must be declared with a type-only import when 'isolatedModules' is enabled."), None, None, None) }
    pub fn import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedmodules_is_enabled() -> DiagnosticMessage { diag(2866, DiagnosticCategory::Error, String::from("Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_w_2866"), String::from("Import '{0}' conflicts with global value used in this file, so must be declared with a type-only import when 'isolatedModules' is enabled."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_install_type_definitions_for_bun_try_npm_i_save_dev_types_slashbun() -> DiagnosticMessage { diag(2867, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_slashbun_2867"), String::from("Cannot find name '{0}'. Do you need to install type definitions for Bun? Try `npm i --save-dev @types/bun`."), None, None, None) }
    pub fn cannot_find_name_0_do_you_need_to_install_type_definitions_for_bun_try_npm_i_save_dev_types_slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig() -> DiagnosticMessage { diag(2868, DiagnosticCategory::Error, String::from("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_slashbun_2868"), String::from("Cannot find name '{0}'. Do you need to install type definitions for Bun? Try `npm i --save-dev @types/bun` and then add 'bun' to the types field in your tsconfig."), None, None, None) }
    pub fn right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish() -> DiagnosticMessage { diag(2869, DiagnosticCategory::Error, String::from("Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish_2869"), String::from("Right operand of ?? is unreachable because the left operand is never nullish."), None, None, None) }
    pub fn this_binary_expression_is_never_nullish_are_you_missing_parentheses() -> DiagnosticMessage { diag(2870, DiagnosticCategory::Error, String::from("This_binary_expression_is_never_nullish_Are_you_missing_parentheses_2870"), String::from("This binary expression is never nullish. Are you missing parentheses?"), None, None, None) }
    pub fn this_expression_is_always_nullish() -> DiagnosticMessage { diag(2871, DiagnosticCategory::Error, String::from("This_expression_is_always_nullish_2871"), String::from("This expression is always nullish."), None, None, None) }
    pub fn this_kind_of_expression_is_always_truthy() -> DiagnosticMessage { diag(2872, DiagnosticCategory::Error, String::from("This_kind_of_expression_is_always_truthy_2872"), String::from("This kind of expression is always truthy."), None, None, None) }
    pub fn this_kind_of_expression_is_always_falsy() -> DiagnosticMessage { diag(2873, DiagnosticCategory::Error, String::from("This_kind_of_expression_is_always_falsy_2873"), String::from("This kind of expression is always falsy."), None, None, None) }
    pub fn import_declaration_0_is_using_private_name_1() -> DiagnosticMessage { diag(4000, DiagnosticCategory::Error, String::from("Import_declaration_0_is_using_private_name_1_4000"), String::from("Import declaration '{0}' is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4002, DiagnosticCategory::Error, String::from("Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002"), String::from("Type parameter '{0}' of exported class has or is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4004, DiagnosticCategory::Error, String::from("Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004"), String::from("Type parameter '{0}' of exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4006, DiagnosticCategory::Error, String::from("Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006"), String::from("Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4008, DiagnosticCategory::Error, String::from("Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008"), String::from("Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4010, DiagnosticCategory::Error, String::from("Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010"), String::from("Type parameter '{0}' of public static method from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4012, DiagnosticCategory::Error, String::from("Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012"), String::from("Type parameter '{0}' of public method from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4014, DiagnosticCategory::Error, String::from("Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014"), String::from("Type parameter '{0}' of method from exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_exported_function_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4016, DiagnosticCategory::Error, String::from("Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016"), String::from("Type parameter '{0}' of exported function has or is using private name '{1}'."), None, None, None) }
    pub fn implements_clause_of_exported_class_0_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4019, DiagnosticCategory::Error, String::from("Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019"), String::from("Implements clause of exported class '{0}' has or is using private name '{1}'."), None, None, None) }
    pub fn extends_clause_of_exported_class_0_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4020, DiagnosticCategory::Error, String::from("extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020"), String::from("'extends' clause of exported class '{0}' has or is using private name '{1}'."), None, None, None) }
    pub fn extends_clause_of_exported_class_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4021, DiagnosticCategory::Error, String::from("extends_clause_of_exported_class_has_or_is_using_private_name_0_4021"), String::from("'extends' clause of exported class has or is using private name '{0}'."), None, None, None) }
    pub fn extends_clause_of_exported_interface_0_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4022, DiagnosticCategory::Error, String::from("extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022"), String::from("'extends' clause of exported interface '{0}' has or is using private name '{1}'."), None, None, None) }
    pub fn exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4023, DiagnosticCategory::Error, String::from("Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023"), String::from("Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn exported_variable_0_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4024, DiagnosticCategory::Error, String::from("Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024"), String::from("Exported variable '{0}' has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn exported_variable_0_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4025, DiagnosticCategory::Error, String::from("Exported_variable_0_has_or_is_using_private_name_1_4025"), String::from("Exported variable '{0}' has or is using private name '{1}'."), None, None, None) }
    pub fn public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4026, DiagnosticCategory::Error, String::from("Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026"), String::from("Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4027, DiagnosticCategory::Error, String::from("Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027"), String::from("Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn public_static_property_0_of_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4028, DiagnosticCategory::Error, String::from("Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028"), String::from("Public static property '{0}' of exported class has or is using private name '{1}'."), None, None, None) }
    pub fn public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4029, DiagnosticCategory::Error, String::from("Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029"), String::from("Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4030, DiagnosticCategory::Error, String::from("Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030"), String::from("Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn public_property_0_of_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4031, DiagnosticCategory::Error, String::from("Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031"), String::from("Public property '{0}' of exported class has or is using private name '{1}'."), None, None, None) }
    pub fn property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4032, DiagnosticCategory::Error, String::from("Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032"), String::from("Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn property_0_of_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4033, DiagnosticCategory::Error, String::from("Property_0_of_exported_interface_has_or_is_using_private_name_1_4033"), String::from("Property '{0}' of exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4034, DiagnosticCategory::Error, String::from("Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_mod_4034"), String::from("Parameter type of public static setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4035, DiagnosticCategory::Error, String::from("Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1_4035"), String::from("Parameter type of public static setter '{0}' from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4036, DiagnosticCategory::Error, String::from("Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4036"), String::from("Parameter type of public setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4037, DiagnosticCategory::Error, String::from("Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1_4037"), String::from("Parameter type of public setter '{0}' from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4038, DiagnosticCategory::Error, String::from("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_modul_4038"), String::from("Return type of public static getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4039, DiagnosticCategory::Error, String::from("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_4039"), String::from("Return type of public static getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4040, DiagnosticCategory::Error, String::from("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1_4040"), String::from("Return type of public static getter '{0}' from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4041, DiagnosticCategory::Error, String::from("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_4041"), String::from("Return type of public getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4042, DiagnosticCategory::Error, String::from("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4042"), String::from("Return type of public getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4043, DiagnosticCategory::Error, String::from("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1_4043"), String::from("Return type of public getter '{0}' from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1() -> DiagnosticMessage { diag(4044, DiagnosticCategory::Error, String::from("Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044"), String::from("Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'."), None, None, None) }
    pub fn return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4045, DiagnosticCategory::Error, String::from("Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045"), String::from("Return type of constructor signature from exported interface has or is using private name '{0}'."), None, None, None) }
    pub fn return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1() -> DiagnosticMessage { diag(4046, DiagnosticCategory::Error, String::from("Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046"), String::from("Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'."), None, None, None) }
    pub fn return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4047, DiagnosticCategory::Error, String::from("Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047"), String::from("Return type of call signature from exported interface has or is using private name '{0}'."), None, None, None) }
    pub fn return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1() -> DiagnosticMessage { diag(4048, DiagnosticCategory::Error, String::from("Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048"), String::from("Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'."), None, None, None) }
    pub fn return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4049, DiagnosticCategory::Error, String::from("Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049"), String::from("Return type of index signature from exported interface has or is using private name '{0}'."), None, None, None) }
    pub fn return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named() -> DiagnosticMessage { diag(4050, DiagnosticCategory::Error, String::from("Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050"), String::from("Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named."), None, None, None) }
    pub fn return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1() -> DiagnosticMessage { diag(4051, DiagnosticCategory::Error, String::from("Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051"), String::from("Return type of public static method from exported class has or is using name '{0}' from private module '{1}'."), None, None, None) }
    pub fn return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4052, DiagnosticCategory::Error, String::from("Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052"), String::from("Return type of public static method from exported class has or is using private name '{0}'."), None, None, None) }
    pub fn return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named() -> DiagnosticMessage { diag(4053, DiagnosticCategory::Error, String::from("Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053"), String::from("Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named."), None, None, None) }
    pub fn return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1() -> DiagnosticMessage { diag(4054, DiagnosticCategory::Error, String::from("Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054"), String::from("Return type of public method from exported class has or is using name '{0}' from private module '{1}'."), None, None, None) }
    pub fn return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4055, DiagnosticCategory::Error, String::from("Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055"), String::from("Return type of public method from exported class has or is using private name '{0}'."), None, None, None) }
    pub fn return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1() -> DiagnosticMessage { diag(4056, DiagnosticCategory::Error, String::from("Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056"), String::from("Return type of method from exported interface has or is using name '{0}' from private module '{1}'."), None, None, None) }
    pub fn return_type_of_method_from_exported_interface_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4057, DiagnosticCategory::Error, String::from("Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057"), String::from("Return type of method from exported interface has or is using private name '{0}'."), None, None, None) }
    pub fn return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named() -> DiagnosticMessage { diag(4058, DiagnosticCategory::Error, String::from("Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058"), String::from("Return type of exported function has or is using name '{0}' from external module {1} but cannot be named."), None, None, None) }
    pub fn return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1() -> DiagnosticMessage { diag(4059, DiagnosticCategory::Error, String::from("Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059"), String::from("Return type of exported function has or is using name '{0}' from private module '{1}'."), None, None, None) }
    pub fn return_type_of_exported_function_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4060, DiagnosticCategory::Error, String::from("Return_type_of_exported_function_has_or_is_using_private_name_0_4060"), String::from("Return type of exported function has or is using private name '{0}'."), None, None, None) }
    pub fn parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4061, DiagnosticCategory::Error, String::from("Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061"), String::from("Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4062, DiagnosticCategory::Error, String::from("Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062"), String::from("Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4063, DiagnosticCategory::Error, String::from("Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063"), String::from("Parameter '{0}' of constructor from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4064, DiagnosticCategory::Error, String::from("Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064"), String::from("Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4065, DiagnosticCategory::Error, String::from("Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065"), String::from("Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4066, DiagnosticCategory::Error, String::from("Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066"), String::from("Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4067, DiagnosticCategory::Error, String::from("Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067"), String::from("Parameter '{0}' of call signature from exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4068, DiagnosticCategory::Error, String::from("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068"), String::from("Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4069, DiagnosticCategory::Error, String::from("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069"), String::from("Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4070, DiagnosticCategory::Error, String::from("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070"), String::from("Parameter '{0}' of public static method from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4071, DiagnosticCategory::Error, String::from("Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071"), String::from("Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4072, DiagnosticCategory::Error, String::from("Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072"), String::from("Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4073, DiagnosticCategory::Error, String::from("Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073"), String::from("Parameter '{0}' of public method from exported class has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4074, DiagnosticCategory::Error, String::from("Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074"), String::from("Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4075, DiagnosticCategory::Error, String::from("Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075"), String::from("Parameter '{0}' of method from exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4076, DiagnosticCategory::Error, String::from("Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076"), String::from("Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4077, DiagnosticCategory::Error, String::from("Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077"), String::from("Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_exported_function_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4078, DiagnosticCategory::Error, String::from("Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078"), String::from("Parameter '{0}' of exported function has or is using private name '{1}'."), None, None, None) }
    pub fn exported_type_alias_0_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4081, DiagnosticCategory::Error, String::from("Exported_type_alias_0_has_or_is_using_private_name_1_4081"), String::from("Exported type alias '{0}' has or is using private name '{1}'."), None, None, None) }
    pub fn default_export_of_the_module_has_or_is_using_private_name_0() -> DiagnosticMessage { diag(4082, DiagnosticCategory::Error, String::from("Default_export_of_the_module_has_or_is_using_private_name_0_4082"), String::from("Default export of the module has or is using private name '{0}'."), None, None, None) }
    pub fn type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4083, DiagnosticCategory::Error, String::from("Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083"), String::from("Type parameter '{0}' of exported type alias has or is using private name '{1}'."), None, None, None) }
    pub fn exported_type_alias_0_has_or_is_using_private_name_1_from_module_2() -> DiagnosticMessage { diag(4084, DiagnosticCategory::Error, String::from("Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2_4084"), String::from("Exported type alias '{0}' has or is using private name '{1}' from module {2}."), None, None, None) }
    pub fn extends_clause_for_inferred_type_0_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4085, DiagnosticCategory::Error, String::from("Extends_clause_for_inferred_type_0_has_or_is_using_private_name_1_4085"), String::from("Extends clause for inferred type '{0}' has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4091, DiagnosticCategory::Error, String::from("Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091"), String::from("Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4092, DiagnosticCategory::Error, String::from("Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092"), String::from("Parameter '{0}' of index signature from exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn property_0_of_exported_anonymous_class_type_may_not_be_private_or_protected() -> DiagnosticMessage { diag(4094, DiagnosticCategory::Error, String::from("Property_0_of_exported_anonymous_class_type_may_not_be_private_or_protected_4094"), String::from("Property '{0}' of exported anonymous class type may not be private or protected."), None, None, None) }
    pub fn public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4095, DiagnosticCategory::Error, String::from("Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_4095"), String::from("Public static method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4096, DiagnosticCategory::Error, String::from("Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4096"), String::from("Public static method '{0}' of exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn public_static_method_0_of_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4097, DiagnosticCategory::Error, String::from("Public_static_method_0_of_exported_class_has_or_is_using_private_name_1_4097"), String::from("Public static method '{0}' of exported class has or is using private name '{1}'."), None, None, None) }
    pub fn public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4098, DiagnosticCategory::Error, String::from("Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4098"), String::from("Public method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), None, None, None) }
    pub fn public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4099, DiagnosticCategory::Error, String::from("Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4099"), String::from("Public method '{0}' of exported class has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn public_method_0_of_exported_class_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4100, DiagnosticCategory::Error, String::from("Public_method_0_of_exported_class_has_or_is_using_private_name_1_4100"), String::from("Public method '{0}' of exported class has or is using private name '{1}'."), None, None, None) }
    pub fn method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4101, DiagnosticCategory::Error, String::from("Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4101"), String::from("Method '{0}' of exported interface has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn method_0_of_exported_interface_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4102, DiagnosticCategory::Error, String::from("Method_0_of_exported_interface_has_or_is_using_private_name_1_4102"), String::from("Method '{0}' of exported interface has or is using private name '{1}'."), None, None, None) }
    pub fn type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1() -> DiagnosticMessage { diag(4103, DiagnosticCategory::Error, String::from("Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1_4103"), String::from("Type parameter '{0}' of exported mapped object type is using private name '{1}'."), None, None, None) }
    pub fn the_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1() -> DiagnosticMessage { diag(4104, DiagnosticCategory::Error, String::from("The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1_4104"), String::from("The type '{0}' is 'readonly' and cannot be assigned to the mutable type '{1}'."), None, None, None) }
    pub fn private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter() -> DiagnosticMessage { diag(4105, DiagnosticCategory::Error, String::from("Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter_4105"), String::from("Private or protected member '{0}' cannot be accessed on a type parameter."), None, None, None) }
    pub fn parameter_0_of_accessor_has_or_is_using_private_name_1() -> DiagnosticMessage { diag(4106, DiagnosticCategory::Error, String::from("Parameter_0_of_accessor_has_or_is_using_private_name_1_4106"), String::from("Parameter '{0}' of accessor has or is using private name '{1}'."), None, None, None) }
    pub fn parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2() -> DiagnosticMessage { diag(4107, DiagnosticCategory::Error, String::from("Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2_4107"), String::from("Parameter '{0}' of accessor has or is using name '{1}' from private module '{2}'."), None, None, None) }
    pub fn parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named() -> DiagnosticMessage { diag(4108, DiagnosticCategory::Error, String::from("Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4108"), String::from("Parameter '{0}' of accessor has or is using name '{1}' from external module '{2}' but cannot be named."), None, None, None) }
    pub fn type_arguments_for_0_circularly_reference_themselves() -> DiagnosticMessage { diag(4109, DiagnosticCategory::Error, String::from("Type_arguments_for_0_circularly_reference_themselves_4109"), String::from("Type arguments for '{0}' circularly reference themselves."), None, None, None) }
    pub fn tuple_type_arguments_circularly_reference_themselves() -> DiagnosticMessage { diag(4110, DiagnosticCategory::Error, String::from("Tuple_type_arguments_circularly_reference_themselves_4110"), String::from("Tuple type arguments circularly reference themselves."), None, None, None) }
    pub fn property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0() -> DiagnosticMessage { diag(4111, DiagnosticCategory::Error, String::from("Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0_4111"), String::from("Property '{0}' comes from an index signature, so it must be accessed with ['{0}']."), None, None, None) }
    pub fn this_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class() -> DiagnosticMessage { diag(4112, DiagnosticCategory::Error, String::from("This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another__4112"), String::from("This member cannot have an 'override' modifier because its containing class '{0}' does not extend another class."), None, None, None) }
    pub fn this_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0() -> DiagnosticMessage { diag(4113, DiagnosticCategory::Error, String::from("This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_4113"), String::from("This member cannot have an 'override' modifier because it is not declared in the base class '{0}'."), None, None, None) }
    pub fn this_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0() -> DiagnosticMessage { diag(4114, DiagnosticCategory::Error, String::from("This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0_4114"), String::from("This member must have an 'override' modifier because it overrides a member in the base class '{0}'."), None, None, None) }
    pub fn this_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0() -> DiagnosticMessage { diag(4115, DiagnosticCategory::Error, String::from("This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0_4115"), String::from("This parameter property must have an 'override' modifier because it overrides a member in base class '{0}'."), None, None, None) }
    pub fn this_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0() -> DiagnosticMessage { diag(4116, DiagnosticCategory::Error, String::from("This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared__4116"), String::from("This member must have an 'override' modifier because it overrides an abstract method that is declared in the base class '{0}'."), None, None, None) }
    pub fn this_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_did_you_mean_1() -> DiagnosticMessage { diag(4117, DiagnosticCategory::Error, String::from("This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you__4117"), String::from("This member cannot have an 'override' modifier because it is not declared in the base class '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn the_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized() -> DiagnosticMessage { diag(4118, DiagnosticCategory::Error, String::from("The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized_4118"), String::from("The type of this node cannot be serialized because its property '{0}' cannot be serialized."), None, None, None) }
    pub fn this_member_must_have_a_jsdoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0() -> DiagnosticMessage { diag(4119, DiagnosticCategory::Error, String::from("This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_4119"), String::from("This member must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."), None, None, None) }
    pub fn this_parameter_property_must_have_a_jsdoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0() -> DiagnosticMessage { diag(4120, DiagnosticCategory::Error, String::from("This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_4120"), String::from("This parameter property must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."), None, None, None) }
    pub fn this_member_cannot_have_a_jsdoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class() -> DiagnosticMessage { diag(4121, DiagnosticCategory::Error, String::from("This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_4121"), String::from("This member cannot have a JSDoc comment with an '@override' tag because its containing class '{0}' does not extend another class."), None, None, None) }
    pub fn this_member_cannot_have_a_jsdoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0() -> DiagnosticMessage { diag(4122, DiagnosticCategory::Error, String::from("This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4122"), String::from("This member cannot have a JSDoc comment with an '@override' tag because it is not declared in the base class '{0}'."), None, None, None) }
    pub fn this_member_cannot_have_a_jsdoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_did_you_mean_1() -> DiagnosticMessage { diag(4123, DiagnosticCategory::Error, String::from("This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4123"), String::from("This member cannot have a JSDoc comment with an 'override' tag because it is not declared in the base class '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn compiler_option_0_of_value_1_is_unstable_use_nightly_typescript_to_silence_this_error_try_updating_with_npm_install_d_typescript_next() -> DiagnosticMessage { diag(4124, DiagnosticCategory::Error, String::from("Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_w_4124"), String::from("Compiler option '{0}' of value '{1}' is unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."), None, None, None) }
    pub fn each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given() -> DiagnosticMessage { diag(4125, DiagnosticCategory::Error, String::from("Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given_4125"), String::from("Each declaration of '{0}.{1}' differs in its value, where '{2}' was expected but '{3}' was given."), None, None, None) }
    pub fn one_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value() -> DiagnosticMessage { diag(4126, DiagnosticCategory::Error, String::from("One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value_4126"), String::from("One value of '{0}.{1}' is the string '{2}', and the other is assumed to be an unknown numeric value."), None, None, None) }
    pub fn the_current_host_does_not_support_the_0_option() -> DiagnosticMessage { diag(5001, DiagnosticCategory::Error, String::from("The_current_host_does_not_support_the_0_option_5001"), String::from("The current host does not support the '{0}' option."), None, None, None) }
    pub fn cannot_find_the_common_subdirectory_path_for_the_input_files() -> DiagnosticMessage { diag(5009, DiagnosticCategory::Error, String::from("Cannot_find_the_common_subdirectory_path_for_the_input_files_5009"), String::from("Cannot find the common subdirectory path for the input files."), None, None, None) }
    pub fn file_specification_cannot_end_in_a_recursive_directory_wildcard_asterisk_asterisk_colon_0() -> DiagnosticMessage { diag(5010, DiagnosticCategory::Error, String::from("File_specification_cannot_end_in_a_recursive_directory_wildcard_asterisk_asterisk_colon_0_5010"), String::from("File specification cannot end in a recursive directory wildcard ('**'): '{0}'."), None, None, None) }
    pub fn cannot_read_file_0_colon_1() -> DiagnosticMessage { diag(5012, DiagnosticCategory::Error, String::from("Cannot_read_file_0_colon_1_5012"), String::from("Cannot read file '{0}': {1}."), None, None, None) }
    pub fn unknown_compiler_option_0() -> DiagnosticMessage { diag(5023, DiagnosticCategory::Error, String::from("Unknown_compiler_option_0_5023"), String::from("Unknown compiler option '{0}'."), None, None, None) }
    pub fn compiler_option_0_requires_a_value_of_type_1() -> DiagnosticMessage { diag(5024, DiagnosticCategory::Error, String::from("Compiler_option_0_requires_a_value_of_type_1_5024"), String::from("Compiler option '{0}' requires a value of type {1}."), None, None, None) }
    pub fn unknown_compiler_option_0_did_you_mean_1() -> DiagnosticMessage { diag(5025, DiagnosticCategory::Error, String::from("Unknown_compiler_option_0_Did_you_mean_1_5025"), String::from("Unknown compiler option '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn could_not_write_file_0_colon_1() -> DiagnosticMessage { diag(5033, DiagnosticCategory::Error, String::from("Could_not_write_file_0_colon_1_5033"), String::from("Could not write file '{0}': {1}."), None, None, None) }
    pub fn option_project_cannot_be_mixed_with_source_files_on_a_command_line() -> DiagnosticMessage { diag(5042, DiagnosticCategory::Error, String::from("Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042"), String::from("Option 'project' cannot be mixed with source files on a command line."), None, None, None) }
    pub fn option_isolatedmodules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_es2015_or_higher() -> DiagnosticMessage { diag(5047, DiagnosticCategory::Error, String::from("Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047"), String::from("Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher."), None, None, None) }
    pub fn option_0_can_only_be_used_when_either_option_inlinesourcemap_or_option_sourcemap_is_provided() -> DiagnosticMessage { diag(5051, DiagnosticCategory::Error, String::from("Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051"), String::from("Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided."), None, None, None) }
    pub fn option_0_cannot_be_specified_without_specifying_option_1() -> DiagnosticMessage { diag(5052, DiagnosticCategory::Error, String::from("Option_0_cannot_be_specified_without_specifying_option_1_5052"), String::from("Option '{0}' cannot be specified without specifying option '{1}'."), None, None, None) }
    pub fn option_0_cannot_be_specified_with_option_1() -> DiagnosticMessage { diag(5053, DiagnosticCategory::Error, String::from("Option_0_cannot_be_specified_with_option_1_5053"), String::from("Option '{0}' cannot be specified with option '{1}'."), None, None, None) }
    pub fn a_tsconfig_json_file_is_already_defined_at_colon_0() -> DiagnosticMessage { diag(5054, DiagnosticCategory::Error, String::from("A_tsconfig_json_file_is_already_defined_at_colon_0_5054"), String::from("A 'tsconfig.json' file is already defined at: '{0}'."), None, None, None) }
    pub fn cannot_write_file_0_because_it_would_overwrite_input_file() -> DiagnosticMessage { diag(5055, DiagnosticCategory::Error, String::from("Cannot_write_file_0_because_it_would_overwrite_input_file_5055"), String::from("Cannot write file '{0}' because it would overwrite input file."), None, None, None) }
    pub fn cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files() -> DiagnosticMessage { diag(5056, DiagnosticCategory::Error, String::from("Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056"), String::from("Cannot write file '{0}' because it would be overwritten by multiple input files."), None, None, None) }
    pub fn cannot_find_a_tsconfig_json_file_at_the_specified_directory_colon_0() -> DiagnosticMessage { diag(5057, DiagnosticCategory::Error, String::from("Cannot_find_a_tsconfig_json_file_at_the_specified_directory_colon_0_5057"), String::from("Cannot find a tsconfig.json file at the specified directory: '{0}'."), None, None, None) }
    pub fn the_specified_path_does_not_exist_colon_0() -> DiagnosticMessage { diag(5058, DiagnosticCategory::Error, String::from("The_specified_path_does_not_exist_colon_0_5058"), String::from("The specified path does not exist: '{0}'."), None, None, None) }
    pub fn invalid_value_for_reactnamespace_0_is_not_a_valid_identifier() -> DiagnosticMessage { diag(5059, DiagnosticCategory::Error, String::from("Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059"), String::from("Invalid value for '--reactNamespace'. '{0}' is not a valid identifier."), None, None, None) }
    pub fn pattern_0_can_have_at_most_one_asterisk_character() -> DiagnosticMessage { diag(5061, DiagnosticCategory::Error, String::from("Pattern_0_can_have_at_most_one_asterisk_character_5061"), String::from("Pattern '{0}' can have at most one '*' character."), None, None, None) }
    pub fn substitution_0_in_pattern_1_can_have_at_most_one_asterisk_character() -> DiagnosticMessage { diag(5062, DiagnosticCategory::Error, String::from("Substitution_0_in_pattern_1_can_have_at_most_one_asterisk_character_5062"), String::from("Substitution '{0}' in pattern '{1}' can have at most one '*' character."), None, None, None) }
    pub fn substitutions_for_pattern_0_should_be_an_array() -> DiagnosticMessage { diag(5063, DiagnosticCategory::Error, String::from("Substitutions_for_pattern_0_should_be_an_array_5063"), String::from("Substitutions for pattern '{0}' should be an array."), None, None, None) }
    pub fn substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2() -> DiagnosticMessage { diag(5064, DiagnosticCategory::Error, String::from("Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064"), String::from("Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'."), None, None, None) }
    pub fn file_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_asterisk_asterisk_colon_0() -> DiagnosticMessage { diag(5065, DiagnosticCategory::Error, String::from("File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065"), String::from("File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'."), None, None, None) }
    pub fn substitutions_for_pattern_0_shouldn_t_be_an_empty_array() -> DiagnosticMessage { diag(5066, DiagnosticCategory::Error, String::from("Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066"), String::from("Substitutions for pattern '{0}' shouldn't be an empty array."), None, None, None) }
    pub fn invalid_value_for_jsxfactory_0_is_not_a_valid_identifier_or_qualified_name() -> DiagnosticMessage { diag(5067, DiagnosticCategory::Error, String::from("Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067"), String::from("Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name."), None, None, None) }
    pub fn adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_typescript_and_javascript_files_learn_more_at_https_colon_slash_slashaka_ms_slashtsconfig() -> DiagnosticMessage { diag(5068, DiagnosticCategory::Error, String::from("Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__5068"), String::from("Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig."), None, None, None) }
    pub fn option_0_cannot_be_specified_without_specifying_option_1_or_option_2() -> DiagnosticMessage { diag(5069, DiagnosticCategory::Error, String::from("Option_0_cannot_be_specified_without_specifying_option_1_or_option_2_5069"), String::from("Option '{0}' cannot be specified without specifying option '{1}' or option '{2}'."), None, None, None) }
    pub fn option_resolvejsonmodule_cannot_be_specified_when_moduleresolution_is_set_to_classic() -> DiagnosticMessage { diag(5070, DiagnosticCategory::Error, String::from("Option_resolveJsonModule_cannot_be_specified_when_moduleResolution_is_set_to_classic_5070"), String::from("Option '--resolveJsonModule' cannot be specified when 'moduleResolution' is set to 'classic'."), None, None, None) }
    pub fn option_resolvejsonmodule_cannot_be_specified_when_module_is_set_to_none_system_or_umd() -> DiagnosticMessage { diag(5071, DiagnosticCategory::Error, String::from("Option_resolveJsonModule_cannot_be_specified_when_module_is_set_to_none_system_or_umd_5071"), String::from("Option '--resolveJsonModule' cannot be specified when 'module' is set to 'none', 'system', or 'umd'."), None, None, None) }
    pub fn unknown_build_option_0() -> DiagnosticMessage { diag(5072, DiagnosticCategory::Error, String::from("Unknown_build_option_0_5072"), String::from("Unknown build option '{0}'."), None, None, None) }
    pub fn build_option_0_requires_a_value_of_type_1() -> DiagnosticMessage { diag(5073, DiagnosticCategory::Error, String::from("Build_option_0_requires_a_value_of_type_1_5073"), String::from("Build option '{0}' requires a value of type {1}."), None, None, None) }
    pub fn option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsbuildinfofile_is_specified() -> DiagnosticMessage { diag(5074, DiagnosticCategory::Error, String::from("Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBui_5074"), String::from("Option '--incremental' can only be specified using tsconfig, emitting to single file or when option '--tsBuildInfoFile' is specified."), None, None, None) }
    pub fn _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2() -> DiagnosticMessage { diag(5075, DiagnosticCategory::Error, String::from("_0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_5075"), String::from("'{0}' is assignable to the constraint of type '{1}', but '{1}' could be instantiated with a different subtype of constraint '{2}'."), None, None, None) }
    pub fn _0_and_1_operations_cannot_be_mixed_without_parentheses() -> DiagnosticMessage { diag(5076, DiagnosticCategory::Error, String::from("_0_and_1_operations_cannot_be_mixed_without_parentheses_5076"), String::from("'{0}' and '{1}' operations cannot be mixed without parentheses."), None, None, None) }
    pub fn unknown_build_option_0_did_you_mean_1() -> DiagnosticMessage { diag(5077, DiagnosticCategory::Error, String::from("Unknown_build_option_0_Did_you_mean_1_5077"), String::from("Unknown build option '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn unknown_watch_option_0() -> DiagnosticMessage { diag(5078, DiagnosticCategory::Error, String::from("Unknown_watch_option_0_5078"), String::from("Unknown watch option '{0}'."), None, None, None) }
    pub fn unknown_watch_option_0_did_you_mean_1() -> DiagnosticMessage { diag(5079, DiagnosticCategory::Error, String::from("Unknown_watch_option_0_Did_you_mean_1_5079"), String::from("Unknown watch option '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn watch_option_0_requires_a_value_of_type_1() -> DiagnosticMessage { diag(5080, DiagnosticCategory::Error, String::from("Watch_option_0_requires_a_value_of_type_1_5080"), String::from("Watch option '{0}' requires a value of type {1}."), None, None, None) }
    pub fn cannot_find_a_tsconfig_json_file_at_the_current_directory_colon_0() -> DiagnosticMessage { diag(5081, DiagnosticCategory::Error, String::from("Cannot_find_a_tsconfig_json_file_at_the_current_directory_colon_0_5081"), String::from("Cannot find a tsconfig.json file at the current directory: {0}."), None, None, None) }
    pub fn _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1() -> DiagnosticMessage { diag(5082, DiagnosticCategory::Error, String::from("_0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1_5082"), String::from("'{0}' could be instantiated with an arbitrary type which could be unrelated to '{1}'."), None, None, None) }
    pub fn cannot_read_file_0() -> DiagnosticMessage { diag(5083, DiagnosticCategory::Error, String::from("Cannot_read_file_0_5083"), String::from("Cannot read file '{0}'."), None, None, None) }
    pub fn a_tuple_member_cannot_be_both_optional_and_rest() -> DiagnosticMessage { diag(5085, DiagnosticCategory::Error, String::from("A_tuple_member_cannot_be_both_optional_and_rest_5085"), String::from("A tuple member cannot be both optional and rest."), None, None, None) }
    pub fn a_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type() -> DiagnosticMessage { diag(5086, DiagnosticCategory::Error, String::from("A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_c_5086"), String::from("A labeled tuple element is declared as optional with a question mark after the name and before the colon, rather than after the type."), None, None, None) }
    pub fn a_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type() -> DiagnosticMessage { diag(5087, DiagnosticCategory::Error, String::from("A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type_5087"), String::from("A labeled tuple element is declared as rest with a '...' before the name, rather than before the type."), None, None, None) }
    pub fn the_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_a_type_annotation_is_necessary() -> DiagnosticMessage { diag(5088, DiagnosticCategory::Error, String::from("The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialize_5088"), String::from("The inferred type of '{0}' references a type with a cyclic structure which cannot be trivially serialized. A type annotation is necessary."), None, None, None) }
    pub fn option_0_cannot_be_specified_when_option_jsx_is_1() -> DiagnosticMessage { diag(5089, DiagnosticCategory::Error, String::from("Option_0_cannot_be_specified_when_option_jsx_is_1_5089"), String::from("Option '{0}' cannot be specified when option 'jsx' is '{1}'."), None, None, None) }
    pub fn non_relative_paths_are_not_allowed_when_baseurl_is_not_set_did_you_forget_a_leading_slash() -> DiagnosticMessage { diag(5090, DiagnosticCategory::Error, String::from("Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_slash_5090"), String::from("Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?"), None, None, None) }
    pub fn option_preserveconstenums_cannot_be_disabled_when_0_is_enabled() -> DiagnosticMessage { diag(5091, DiagnosticCategory::Error, String::from("Option_preserveConstEnums_cannot_be_disabled_when_0_is_enabled_5091"), String::from("Option 'preserveConstEnums' cannot be disabled when '{0}' is enabled."), None, None, None) }
    pub fn the_root_value_of_a_0_file_must_be_an_object() -> DiagnosticMessage { diag(5092, DiagnosticCategory::Error, String::from("The_root_value_of_a_0_file_must_be_an_object_5092"), String::from("The root value of a '{0}' file must be an object."), None, None, None) }
    pub fn compiler_option_0_may_only_be_used_with_build() -> DiagnosticMessage { diag(5093, DiagnosticCategory::Error, String::from("Compiler_option_0_may_only_be_used_with_build_5093"), String::from("Compiler option '--{0}' may only be used with '--build'."), None, None, None) }
    pub fn compiler_option_0_may_not_be_used_with_build() -> DiagnosticMessage { diag(5094, DiagnosticCategory::Error, String::from("Compiler_option_0_may_not_be_used_with_build_5094"), String::from("Compiler option '--{0}' may not be used with '--build'."), None, None, None) }
    pub fn option_0_can_only_be_used_when_module_is_set_to_preserve_or_to_es2015_or_later() -> DiagnosticMessage { diag(5095, DiagnosticCategory::Error, String::from("Option_0_can_only_be_used_when_module_is_set_to_preserve_or_to_es2015_or_later_5095"), String::from("Option '{0}' can only be used when 'module' is set to 'preserve' or to 'es2015' or later."), None, None, None) }
    pub fn option_allowimportingtsextensions_can_only_be_used_when_either_noemit_or_emitdeclarationonly_is_set() -> DiagnosticMessage { diag(5096, DiagnosticCategory::Error, String::from("Option_allowImportingTsExtensions_can_only_be_used_when_either_noEmit_or_emitDeclarationOnly_is_set_5096"), String::from("Option 'allowImportingTsExtensions' can only be used when either 'noEmit' or 'emitDeclarationOnly' is set."), None, None, None) }
    pub fn an_import_path_can_only_end_with_a_0_extension_when_allowimportingtsextensions_is_enabled() -> DiagnosticMessage { diag(5097, DiagnosticCategory::Error, String::from("An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled_5097"), String::from("An import path can only end with a '{0}' extension when 'allowImportingTsExtensions' is enabled."), None, None, None) }
    pub fn option_0_can_only_be_used_when_moduleresolution_is_set_to_node16_nodenext_or_bundler() -> DiagnosticMessage { diag(5098, DiagnosticCategory::Error, String::from("Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler_5098"), String::from("Option '{0}' can only be used when 'moduleResolution' is set to 'node16', 'nodenext', or 'bundler'."), None, None, None) }
    pub fn option_0_is_deprecated_and_will_stop_functioning_in_typescript_1_specify_compileroption_ignoredeprecations_colon_2_to_silence_this_error() -> DiagnosticMessage { diag(5101, DiagnosticCategory::Error, String::from("Option_0_is_deprecated_and_will_stop_functioning_in_TypeScript_1_Specify_compilerOption_ignoreDeprec_5101"), String::from("Option '{0}' is deprecated and will stop functioning in TypeScript {1}. Specify compilerOption '\"ignoreDeprecations\": \"{2}\"' to silence this error."), None, None, None) }
    pub fn option_0_has_been_removed_please_remove_it_from_your_configuration() -> DiagnosticMessage { diag(5102, DiagnosticCategory::Error, String::from("Option_0_has_been_removed_Please_remove_it_from_your_configuration_5102"), String::from("Option '{0}' has been removed. Please remove it from your configuration."), None, None, None) }
    pub fn invalid_value_for_ignoredeprecations() -> DiagnosticMessage { diag(5103, DiagnosticCategory::Error, String::from("Invalid_value_for_ignoreDeprecations_5103"), String::from("Invalid value for '--ignoreDeprecations'."), None, None, None) }
    pub fn option_0_is_redundant_and_cannot_be_specified_with_option_1() -> DiagnosticMessage { diag(5104, DiagnosticCategory::Error, String::from("Option_0_is_redundant_and_cannot_be_specified_with_option_1_5104"), String::from("Option '{0}' is redundant and cannot be specified with option '{1}'."), None, None, None) }
    pub fn option_verbatimmodulesyntax_cannot_be_used_when_module_is_set_to_umd_amd_or_system() -> DiagnosticMessage { diag(5105, DiagnosticCategory::Error, String::from("Option_verbatimModuleSyntax_cannot_be_used_when_module_is_set_to_UMD_AMD_or_System_5105"), String::from("Option 'verbatimModuleSyntax' cannot be used when 'module' is set to 'UMD', 'AMD', or 'System'."), None, None, None) }
    pub fn use_0_instead() -> DiagnosticMessage { diag(5106, DiagnosticCategory::Message, String::from("Use_0_instead_5106"), String::from("Use '{0}' instead."), None, None, None) }
    pub fn option_0_1_is_deprecated_and_will_stop_functioning_in_typescript_2_specify_compileroption_ignoredeprecations_colon_3_to_silence_this_error() -> DiagnosticMessage { diag(5107, DiagnosticCategory::Error, String::from("Option_0_1_is_deprecated_and_will_stop_functioning_in_TypeScript_2_Specify_compilerOption_ignoreDepr_5107"), String::from("Option '{0}={1}' is deprecated and will stop functioning in TypeScript {2}. Specify compilerOption '\"ignoreDeprecations\": \"{3}\"' to silence this error."), None, None, None) }
    pub fn option_0_1_has_been_removed_please_remove_it_from_your_configuration() -> DiagnosticMessage { diag(5108, DiagnosticCategory::Error, String::from("Option_0_1_has_been_removed_Please_remove_it_from_your_configuration_5108"), String::from("Option '{0}={1}' has been removed. Please remove it from your configuration."), None, None, None) }
    pub fn option_moduleresolution_must_be_set_to_0_or_left_unspecified_when_option_module_is_set_to_1() -> DiagnosticMessage { diag(5109, DiagnosticCategory::Error, String::from("Option_moduleResolution_must_be_set_to_0_or_left_unspecified_when_option_module_is_set_to_1_5109"), String::from("Option 'moduleResolution' must be set to '{0}' (or left unspecified) when option 'module' is set to '{1}'."), None, None, None) }
    pub fn option_module_must_be_set_to_0_when_option_moduleresolution_is_set_to_1() -> DiagnosticMessage { diag(5110, DiagnosticCategory::Error, String::from("Option_module_must_be_set_to_0_when_option_moduleResolution_is_set_to_1_5110"), String::from("Option 'module' must be set to '{0}' when option 'moduleResolution' is set to '{1}'."), None, None, None) }
    pub fn generates_a_sourcemap_for_each_corresponding_d_ts_file() -> DiagnosticMessage { diag(6000, DiagnosticCategory::Message, String::from("Generates_a_sourcemap_for_each_corresponding_d_ts_file_6000"), String::from("Generates a sourcemap for each corresponding '.d.ts' file."), None, None, None) }
    pub fn concatenate_and_emit_output_to_single_file() -> DiagnosticMessage { diag(6001, DiagnosticCategory::Message, String::from("Concatenate_and_emit_output_to_single_file_6001"), String::from("Concatenate and emit output to single file."), None, None, None) }
    pub fn generates_corresponding_d_ts_file() -> DiagnosticMessage { diag(6002, DiagnosticCategory::Message, String::from("Generates_corresponding_d_ts_file_6002"), String::from("Generates corresponding '.d.ts' file."), None, None, None) }
    pub fn specify_the_location_where_debugger_should_locate_typescript_files_instead_of_source_locations() -> DiagnosticMessage { diag(6004, DiagnosticCategory::Message, String::from("Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004"), String::from("Specify the location where debugger should locate TypeScript files instead of source locations."), None, None, None) }
    pub fn watch_input_files() -> DiagnosticMessage { diag(6005, DiagnosticCategory::Message, String::from("Watch_input_files_6005"), String::from("Watch input files."), None, None, None) }
    pub fn redirect_output_structure_to_the_directory() -> DiagnosticMessage { diag(6006, DiagnosticCategory::Message, String::from("Redirect_output_structure_to_the_directory_6006"), String::from("Redirect output structure to the directory."), None, None, None) }
    pub fn do_not_erase_const_enum_declarations_in_generated_code() -> DiagnosticMessage { diag(6007, DiagnosticCategory::Message, String::from("Do_not_erase_const_enum_declarations_in_generated_code_6007"), String::from("Do not erase const enum declarations in generated code."), None, None, None) }
    pub fn do_not_emit_outputs_if_any_errors_were_reported() -> DiagnosticMessage { diag(6008, DiagnosticCategory::Message, String::from("Do_not_emit_outputs_if_any_errors_were_reported_6008"), String::from("Do not emit outputs if any errors were reported."), None, None, None) }
    pub fn do_not_emit_comments_to_output() -> DiagnosticMessage { diag(6009, DiagnosticCategory::Message, String::from("Do_not_emit_comments_to_output_6009"), String::from("Do not emit comments to output."), None, None, None) }
    pub fn do_not_emit_outputs() -> DiagnosticMessage { diag(6010, DiagnosticCategory::Message, String::from("Do_not_emit_outputs_6010"), String::from("Do not emit outputs."), None, None, None) }
    pub fn allow_default_imports_from_modules_with_no_default_export_this_does_not_affect_code_emit_just_typechecking() -> DiagnosticMessage { diag(6011, DiagnosticCategory::Message, String::from("Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011"), String::from("Allow default imports from modules with no default export. This does not affect code emit, just typechecking."), None, None, None) }
    pub fn skip_type_checking_of_declaration_files() -> DiagnosticMessage { diag(6012, DiagnosticCategory::Message, String::from("Skip_type_checking_of_declaration_files_6012"), String::from("Skip type checking of declaration files."), None, None, None) }
    pub fn do_not_resolve_the_real_path_of_symlinks() -> DiagnosticMessage { diag(6013, DiagnosticCategory::Message, String::from("Do_not_resolve_the_real_path_of_symlinks_6013"), String::from("Do not resolve the real path of symlinks."), None, None, None) }
    pub fn only_emit_d_ts_declaration_files() -> DiagnosticMessage { diag(6014, DiagnosticCategory::Message, String::from("Only_emit_d_ts_declaration_files_6014"), String::from("Only emit '.d.ts' declaration files."), None, None, None) }
    pub fn specify_ecmascript_target_version() -> DiagnosticMessage { diag(6015, DiagnosticCategory::Message, String::from("Specify_ECMAScript_target_version_6015"), String::from("Specify ECMAScript target version."), None, None, None) }
    pub fn specify_module_code_generation() -> DiagnosticMessage { diag(6016, DiagnosticCategory::Message, String::from("Specify_module_code_generation_6016"), String::from("Specify module code generation."), None, None, None) }
    pub fn print_this_message() -> DiagnosticMessage { diag(6017, DiagnosticCategory::Message, String::from("Print_this_message_6017"), String::from("Print this message."), None, None, None) }
    pub fn print_the_compiler_s_version() -> DiagnosticMessage { diag(6019, DiagnosticCategory::Message, String::from("Print_the_compiler_s_version_6019"), String::from("Print the compiler's version."), None, None, None) }
    pub fn compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json() -> DiagnosticMessage { diag(6020, DiagnosticCategory::Message, String::from("Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020"), String::from("Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."), None, None, None) }
    pub fn syntax_colon_0() -> DiagnosticMessage { diag(6023, DiagnosticCategory::Message, String::from("Syntax_colon_0_6023"), String::from("Syntax: {0}"), None, None, None) }
    pub fn options() -> DiagnosticMessage { diag(6024, DiagnosticCategory::Message, String::from("options_6024"), String::from("options"), None, None, None) }
    pub fn file() -> DiagnosticMessage { diag(6025, DiagnosticCategory::Message, String::from("file_6025"), String::from("file"), None, None, None) }
    pub fn examples_colon_0() -> DiagnosticMessage { diag(6026, DiagnosticCategory::Message, String::from("Examples_colon_0_6026"), String::from("Examples: {0}"), None, None, None) }
    pub fn options_colon() -> DiagnosticMessage { diag(6027, DiagnosticCategory::Message, String::from("Options_colon_6027"), String::from("Options:"), None, None, None) }
    pub fn version_0() -> DiagnosticMessage { diag(6029, DiagnosticCategory::Message, String::from("Version_0_6029"), String::from("Version {0}"), None, None, None) }
    pub fn insert_command_line_options_and_files_from_a_file() -> DiagnosticMessage { diag(6030, DiagnosticCategory::Message, String::from("Insert_command_line_options_and_files_from_a_file_6030"), String::from("Insert command line options and files from a file."), None, None, None) }
    pub fn starting_compilation_in_watch_mode() -> DiagnosticMessage { diag(6031, DiagnosticCategory::Message, String::from("Starting_compilation_in_watch_mode_6031"), String::from("Starting compilation in watch mode..."), None, None, None) }
    pub fn file_change_detected_starting_incremental_compilation() -> DiagnosticMessage { diag(6032, DiagnosticCategory::Message, String::from("File_change_detected_Starting_incremental_compilation_6032"), String::from("File change detected. Starting incremental compilation..."), None, None, None) }
    pub fn kind() -> DiagnosticMessage { diag(6034, DiagnosticCategory::Message, String::from("KIND_6034"), String::from("KIND"), None, None, None) }
    pub fn file() -> DiagnosticMessage { diag(6035, DiagnosticCategory::Message, String::from("FILE_6035"), String::from("FILE"), None, None, None) }
    pub fn version() -> DiagnosticMessage { diag(6036, DiagnosticCategory::Message, String::from("VERSION_6036"), String::from("VERSION"), None, None, None) }
    pub fn location() -> DiagnosticMessage { diag(6037, DiagnosticCategory::Message, String::from("LOCATION_6037"), String::from("LOCATION"), None, None, None) }
    pub fn directory() -> DiagnosticMessage { diag(6038, DiagnosticCategory::Message, String::from("DIRECTORY_6038"), String::from("DIRECTORY"), None, None, None) }
    pub fn strategy() -> DiagnosticMessage { diag(6039, DiagnosticCategory::Message, String::from("STRATEGY_6039"), String::from("STRATEGY"), None, None, None) }
    pub fn file_or_directory() -> DiagnosticMessage { diag(6040, DiagnosticCategory::Message, String::from("FILE_OR_DIRECTORY_6040"), String::from("FILE OR DIRECTORY"), None, None, None) }
    pub fn errors_files() -> DiagnosticMessage { diag(6041, DiagnosticCategory::Message, String::from("Errors_Files_6041"), String::from("Errors  Files"), None, None, None) }
    pub fn generates_corresponding_map_file() -> DiagnosticMessage { diag(6043, DiagnosticCategory::Message, String::from("Generates_corresponding_map_file_6043"), String::from("Generates corresponding '.map' file."), None, None, None) }
    pub fn compiler_option_0_expects_an_argument() -> DiagnosticMessage { diag(6044, DiagnosticCategory::Error, String::from("Compiler_option_0_expects_an_argument_6044"), String::from("Compiler option '{0}' expects an argument."), None, None, None) }
    pub fn unterminated_quoted_string_in_response_file_0() -> DiagnosticMessage { diag(6045, DiagnosticCategory::Error, String::from("Unterminated_quoted_string_in_response_file_0_6045"), String::from("Unterminated quoted string in response file '{0}'."), None, None, None) }
    pub fn argument_for_0_option_must_be_colon_1() -> DiagnosticMessage { diag(6046, DiagnosticCategory::Error, String::from("Argument_for_0_option_must_be_colon_1_6046"), String::from("Argument for '{0}' option must be: {1}."), None, None, None) }
    pub fn locale_must_be_of_the_form_language_or_language_territory_for_example_0_or_1() -> DiagnosticMessage { diag(6048, DiagnosticCategory::Error, String::from("Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048"), String::from("Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'."), None, None, None) }
    pub fn unable_to_open_file_0() -> DiagnosticMessage { diag(6050, DiagnosticCategory::Error, String::from("Unable_to_open_file_0_6050"), String::from("Unable to open file '{0}'."), None, None, None) }
    pub fn corrupted_locale_file_0() -> DiagnosticMessage { diag(6051, DiagnosticCategory::Error, String::from("Corrupted_locale_file_0_6051"), String::from("Corrupted locale file {0}."), None, None, None) }
    pub fn raise_error_on_expressions_and_declarations_with_an_implied_any_type() -> DiagnosticMessage { diag(6052, DiagnosticCategory::Message, String::from("Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052"), String::from("Raise error on expressions and declarations with an implied 'any' type."), None, None, None) }
    pub fn file_0_not_found() -> DiagnosticMessage { diag(6053, DiagnosticCategory::Error, String::from("File_0_not_found_6053"), String::from("File '{0}' not found."), None, None, None) }
    pub fn file_0_has_an_unsupported_extension_the_only_supported_extensions_are_1() -> DiagnosticMessage { diag(6054, DiagnosticCategory::Error, String::from("File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1_6054"), String::from("File '{0}' has an unsupported extension. The only supported extensions are {1}."), None, None, None) }
    pub fn suppress_noimplicitany_errors_for_indexing_objects_lacking_index_signatures() -> DiagnosticMessage { diag(6055, DiagnosticCategory::Message, String::from("Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055"), String::from("Suppress noImplicitAny errors for indexing objects lacking index signatures."), None, None, None) }
    pub fn do_not_emit_declarations_for_code_that_has_an_internal_annotation() -> DiagnosticMessage { diag(6056, DiagnosticCategory::Message, String::from("Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056"), String::from("Do not emit declarations for code that has an '@internal' annotation."), None, None, None) }
    pub fn specify_the_root_directory_of_input_files_use_to_control_the_output_directory_structure_with_outdir() -> DiagnosticMessage { diag(6058, DiagnosticCategory::Message, String::from("Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058"), String::from("Specify the root directory of input files. Use to control the output directory structure with --outDir."), None, None, None) }
    pub fn file_0_is_not_under_rootdir_1_rootdir_is_expected_to_contain_all_source_files() -> DiagnosticMessage { diag(6059, DiagnosticCategory::Error, String::from("File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059"), String::from("File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files."), None, None, None) }
    pub fn specify_the_end_of_line_sequence_to_be_used_when_emitting_files_colon_crlf_dos_or_lf_unix() -> DiagnosticMessage { diag(6060, DiagnosticCategory::Message, String::from("Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_colon_CRLF_dos_or_LF_unix_6060"), String::from("Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix)."), None, None, None) }
    pub fn newline() -> DiagnosticMessage { diag(6061, DiagnosticCategory::Message, String::from("NEWLINE_6061"), String::from("NEWLINE"), None, None, None) }
    pub fn option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line() -> DiagnosticMessage { diag(6064, DiagnosticCategory::Error, String::from("Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line_6064"), String::from("Option '{0}' can only be specified in 'tsconfig.json' file or set to 'null' on command line."), None, None, None) }
    pub fn enables_experimental_support_for_es7_decorators() -> DiagnosticMessage { diag(6065, DiagnosticCategory::Message, String::from("Enables_experimental_support_for_ES7_decorators_6065"), String::from("Enables experimental support for ES7 decorators."), None, None, None) }
    pub fn enables_experimental_support_for_emitting_type_metadata_for_decorators() -> DiagnosticMessage { diag(6066, DiagnosticCategory::Message, String::from("Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066"), String::from("Enables experimental support for emitting type metadata for decorators."), None, None, None) }
    pub fn initializes_a_typescript_project_and_creates_a_tsconfig_json_file() -> DiagnosticMessage { diag(6070, DiagnosticCategory::Message, String::from("Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070"), String::from("Initializes a TypeScript project and creates a tsconfig.json file."), None, None, None) }
    pub fn successfully_created_a_tsconfig_json_file() -> DiagnosticMessage { diag(6071, DiagnosticCategory::Message, String::from("Successfully_created_a_tsconfig_json_file_6071"), String::from("Successfully created a tsconfig.json file."), None, None, None) }
    pub fn suppress_excess_property_checks_for_object_literals() -> DiagnosticMessage { diag(6072, DiagnosticCategory::Message, String::from("Suppress_excess_property_checks_for_object_literals_6072"), String::from("Suppress excess property checks for object literals."), None, None, None) }
    pub fn stylize_errors_and_messages_using_color_and_context_experimental() -> DiagnosticMessage { diag(6073, DiagnosticCategory::Message, String::from("Stylize_errors_and_messages_using_color_and_context_experimental_6073"), String::from("Stylize errors and messages using color and context (experimental)."), None, None, None) }
    pub fn do_not_report_errors_on_unused_labels() -> DiagnosticMessage { diag(6074, DiagnosticCategory::Message, String::from("Do_not_report_errors_on_unused_labels_6074"), String::from("Do not report errors on unused labels."), None, None, None) }
    pub fn report_error_when_not_all_code_paths_in_function_return_a_value() -> DiagnosticMessage { diag(6075, DiagnosticCategory::Message, String::from("Report_error_when_not_all_code_paths_in_function_return_a_value_6075"), String::from("Report error when not all code paths in function return a value."), None, None, None) }
    pub fn report_errors_for_fallthrough_cases_in_switch_statement() -> DiagnosticMessage { diag(6076, DiagnosticCategory::Message, String::from("Report_errors_for_fallthrough_cases_in_switch_statement_6076"), String::from("Report errors for fallthrough cases in switch statement."), None, None, None) }
    pub fn do_not_report_errors_on_unreachable_code() -> DiagnosticMessage { diag(6077, DiagnosticCategory::Message, String::from("Do_not_report_errors_on_unreachable_code_6077"), String::from("Do not report errors on unreachable code."), None, None, None) }
    pub fn disallow_inconsistently_cased_references_to_the_same_file() -> DiagnosticMessage { diag(6078, DiagnosticCategory::Message, String::from("Disallow_inconsistently_cased_references_to_the_same_file_6078"), String::from("Disallow inconsistently-cased references to the same file."), None, None, None) }
    pub fn specify_library_files_to_be_included_in_the_compilation() -> DiagnosticMessage { diag(6079, DiagnosticCategory::Message, String::from("Specify_library_files_to_be_included_in_the_compilation_6079"), String::from("Specify library files to be included in the compilation."), None, None, None) }
    pub fn specify_jsx_code_generation() -> DiagnosticMessage { diag(6080, DiagnosticCategory::Message, String::from("Specify_JSX_code_generation_6080"), String::from("Specify JSX code generation."), None, None, None) }
    pub fn only_amd_and_system_modules_are_supported_alongside_0() -> DiagnosticMessage { diag(6082, DiagnosticCategory::Error, String::from("Only_amd_and_system_modules_are_supported_alongside_0_6082"), String::from("Only 'amd' and 'system' modules are supported alongside --{0}."), None, None, None) }
    pub fn base_directory_to_resolve_non_absolute_module_names() -> DiagnosticMessage { diag(6083, DiagnosticCategory::Message, String::from("Base_directory_to_resolve_non_absolute_module_names_6083"), String::from("Base directory to resolve non-absolute module names."), None, None, None) }
    pub fn deprecated_use_jsxfactory_instead_specify_the_object_invoked_for_createelement_when_targeting_react_jsx_emit() -> DiagnosticMessage { diag(6084, DiagnosticCategory::Message, String::from("Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084"), String::from("[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit"), None, None, None) }
    pub fn enable_tracing_of_the_name_resolution_process() -> DiagnosticMessage { diag(6085, DiagnosticCategory::Message, String::from("Enable_tracing_of_the_name_resolution_process_6085"), String::from("Enable tracing of the name resolution process."), None, None, None) }
    pub fn resolving_module_0_from_1() -> DiagnosticMessage { diag(6086, DiagnosticCategory::Message, String::from("Resolving_module_0_from_1_6086"), String::from("======== Resolving module '{0}' from '{1}'. ========"), None, None, None) }
    pub fn explicitly_specified_module_resolution_kind_colon_0() -> DiagnosticMessage { diag(6087, DiagnosticCategory::Message, String::from("Explicitly_specified_module_resolution_kind_colon_0_6087"), String::from("Explicitly specified module resolution kind: '{0}'."), None, None, None) }
    pub fn module_resolution_kind_is_not_specified_using_0() -> DiagnosticMessage { diag(6088, DiagnosticCategory::Message, String::from("Module_resolution_kind_is_not_specified_using_0_6088"), String::from("Module resolution kind is not specified, using '{0}'."), None, None, None) }
    pub fn module_name_0_was_successfully_resolved_to_1() -> DiagnosticMessage { diag(6089, DiagnosticCategory::Message, String::from("Module_name_0_was_successfully_resolved_to_1_6089"), String::from("======== Module name '{0}' was successfully resolved to '{1}'. ========"), None, None, None) }
    pub fn module_name_0_was_not_resolved() -> DiagnosticMessage { diag(6090, DiagnosticCategory::Message, String::from("Module_name_0_was_not_resolved_6090"), String::from("======== Module name '{0}' was not resolved. ========"), None, None, None) }
    pub fn paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0() -> DiagnosticMessage { diag(6091, DiagnosticCategory::Message, String::from("paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091"), String::from("'paths' option is specified, looking for a pattern to match module name '{0}'."), None, None, None) }
    pub fn module_name_0_matched_pattern_1() -> DiagnosticMessage { diag(6092, DiagnosticCategory::Message, String::from("Module_name_0_matched_pattern_1_6092"), String::from("Module name '{0}', matched pattern '{1}'."), None, None, None) }
    pub fn trying_substitution_0_candidate_module_location_colon_1() -> DiagnosticMessage { diag(6093, DiagnosticCategory::Message, String::from("Trying_substitution_0_candidate_module_location_colon_1_6093"), String::from("Trying substitution '{0}', candidate module location: '{1}'."), None, None, None) }
    pub fn resolving_module_name_0_relative_to_base_url_1_2() -> DiagnosticMessage { diag(6094, DiagnosticCategory::Message, String::from("Resolving_module_name_0_relative_to_base_url_1_2_6094"), String::from("Resolving module name '{0}' relative to base url '{1}' - '{2}'."), None, None, None) }
    pub fn loading_module_as_file_slash_folder_candidate_module_location_0_target_file_types_colon_1() -> DiagnosticMessage { diag(6095, DiagnosticCategory::Message, String::from("Loading_module_as_file_slash_folder_candidate_module_location_0_target_file_types_colon_1_6095"), String::from("Loading module as file / folder, candidate module location '{0}', target file types: {1}."), None, None, None) }
    pub fn file_0_does_not_exist() -> DiagnosticMessage { diag(6096, DiagnosticCategory::Message, String::from("File_0_does_not_exist_6096"), String::from("File '{0}' does not exist."), None, None, None) }
    pub fn file_0_exists_use_it_as_a_name_resolution_result() -> DiagnosticMessage { diag(6097, DiagnosticCategory::Message, String::from("File_0_exists_use_it_as_a_name_resolution_result_6097"), String::from("File '{0}' exists - use it as a name resolution result."), None, None, None) }
    pub fn loading_module_0_from_node_modules_folder_target_file_types_colon_1() -> DiagnosticMessage { diag(6098, DiagnosticCategory::Message, String::from("Loading_module_0_from_node_modules_folder_target_file_types_colon_1_6098"), String::from("Loading module '{0}' from 'node_modules' folder, target file types: {1}."), None, None, None) }
    pub fn found_package_json_at_0() -> DiagnosticMessage { diag(6099, DiagnosticCategory::Message, String::from("Found_package_json_at_0_6099"), String::from("Found 'package.json' at '{0}'."), None, None, None) }
    pub fn package_json_does_not_have_a_0_field() -> DiagnosticMessage { diag(6100, DiagnosticCategory::Message, String::from("package_json_does_not_have_a_0_field_6100"), String::from("'package.json' does not have a '{0}' field."), None, None, None) }
    pub fn package_json_has_0_field_1_that_references_2() -> DiagnosticMessage { diag(6101, DiagnosticCategory::Message, String::from("package_json_has_0_field_1_that_references_2_6101"), String::from("'package.json' has '{0}' field '{1}' that references '{2}'."), None, None, None) }
    pub fn allow_javascript_files_to_be_compiled() -> DiagnosticMessage { diag(6102, DiagnosticCategory::Message, String::from("Allow_javascript_files_to_be_compiled_6102"), String::from("Allow javascript files to be compiled."), None, None, None) }
    pub fn checking_if_0_is_the_longest_matching_prefix_for_1_2() -> DiagnosticMessage { diag(6104, DiagnosticCategory::Message, String::from("Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104"), String::from("Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'."), None, None, None) }
    pub fn expected_type_of_0_field_in_package_json_to_be_1_got_2() -> DiagnosticMessage { diag(6105, DiagnosticCategory::Message, String::from("Expected_type_of_0_field_in_package_json_to_be_1_got_2_6105"), String::from("Expected type of '{0}' field in 'package.json' to be '{1}', got '{2}'."), None, None, None) }
    pub fn baseurl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1() -> DiagnosticMessage { diag(6106, DiagnosticCategory::Message, String::from("baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106"), String::from("'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'."), None, None, None) }
    pub fn rootdirs_option_is_set_using_it_to_resolve_relative_module_name_0() -> DiagnosticMessage { diag(6107, DiagnosticCategory::Message, String::from("rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107"), String::from("'rootDirs' option is set, using it to resolve relative module name '{0}'."), None, None, None) }
    pub fn longest_matching_prefix_for_0_is_1() -> DiagnosticMessage { diag(6108, DiagnosticCategory::Message, String::from("Longest_matching_prefix_for_0_is_1_6108"), String::from("Longest matching prefix for '{0}' is '{1}'."), None, None, None) }
    pub fn loading_0_from_the_root_dir_1_candidate_location_2() -> DiagnosticMessage { diag(6109, DiagnosticCategory::Message, String::from("Loading_0_from_the_root_dir_1_candidate_location_2_6109"), String::from("Loading '{0}' from the root dir '{1}', candidate location '{2}'."), None, None, None) }
    pub fn trying_other_entries_in_rootdirs() -> DiagnosticMessage { diag(6110, DiagnosticCategory::Message, String::from("Trying_other_entries_in_rootDirs_6110"), String::from("Trying other entries in 'rootDirs'."), None, None, None) }
    pub fn module_resolution_using_rootdirs_has_failed() -> DiagnosticMessage { diag(6111, DiagnosticCategory::Message, String::from("Module_resolution_using_rootDirs_has_failed_6111"), String::from("Module resolution using 'rootDirs' has failed."), None, None, None) }
    pub fn do_not_emit_use_strict_directives_in_module_output() -> DiagnosticMessage { diag(6112, DiagnosticCategory::Message, String::from("Do_not_emit_use_strict_directives_in_module_output_6112"), String::from("Do not emit 'use strict' directives in module output."), None, None, None) }
    pub fn enable_strict_null_checks() -> DiagnosticMessage { diag(6113, DiagnosticCategory::Message, String::from("Enable_strict_null_checks_6113"), String::from("Enable strict null checks."), None, None, None) }
    pub fn unknown_option_excludes_did_you_mean_exclude() -> DiagnosticMessage { diag(6114, DiagnosticCategory::Error, String::from("Unknown_option_excludes_Did_you_mean_exclude_6114"), String::from("Unknown option 'excludes'. Did you mean 'exclude'?"), None, None, None) }
    pub fn raise_error_on_this_expressions_with_an_implied_any_type() -> DiagnosticMessage { diag(6115, DiagnosticCategory::Message, String::from("Raise_error_on_this_expressions_with_an_implied_any_type_6115"), String::from("Raise error on 'this' expressions with an implied 'any' type."), None, None, None) }
    pub fn resolving_type_reference_directive_0_containing_file_1_root_directory_2() -> DiagnosticMessage { diag(6116, DiagnosticCategory::Message, String::from("Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116"), String::from("======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========"), None, None, None) }
    pub fn type_reference_directive_0_was_successfully_resolved_to_1_primary_colon_2() -> DiagnosticMessage { diag(6119, DiagnosticCategory::Message, String::from("Type_reference_directive_0_was_successfully_resolved_to_1_primary_colon_2_6119"), String::from("======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========"), None, None, None) }
    pub fn type_reference_directive_0_was_not_resolved() -> DiagnosticMessage { diag(6120, DiagnosticCategory::Message, String::from("Type_reference_directive_0_was_not_resolved_6120"), String::from("======== Type reference directive '{0}' was not resolved. ========"), None, None, None) }
    pub fn resolving_with_primary_search_path_0() -> DiagnosticMessage { diag(6121, DiagnosticCategory::Message, String::from("Resolving_with_primary_search_path_0_6121"), String::from("Resolving with primary search path '{0}'."), None, None, None) }
    pub fn root_directory_cannot_be_determined_skipping_primary_search_paths() -> DiagnosticMessage { diag(6122, DiagnosticCategory::Message, String::from("Root_directory_cannot_be_determined_skipping_primary_search_paths_6122"), String::from("Root directory cannot be determined, skipping primary search paths."), None, None, None) }
    pub fn resolving_type_reference_directive_0_containing_file_1_root_directory_not_set() -> DiagnosticMessage { diag(6123, DiagnosticCategory::Message, String::from("Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123"), String::from("======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========"), None, None, None) }
    pub fn type_declaration_files_to_be_included_in_compilation() -> DiagnosticMessage { diag(6124, DiagnosticCategory::Message, String::from("Type_declaration_files_to_be_included_in_compilation_6124"), String::from("Type declaration files to be included in compilation."), None, None, None) }
    pub fn looking_up_in_node_modules_folder_initial_location_0() -> DiagnosticMessage { diag(6125, DiagnosticCategory::Message, String::from("Looking_up_in_node_modules_folder_initial_location_0_6125"), String::from("Looking up in 'node_modules' folder, initial location '{0}'."), None, None, None) }
    pub fn containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder() -> DiagnosticMessage { diag(6126, DiagnosticCategory::Message, String::from("Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126"), String::from("Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder."), None, None, None) }
    pub fn resolving_type_reference_directive_0_containing_file_not_set_root_directory_1() -> DiagnosticMessage { diag(6127, DiagnosticCategory::Message, String::from("Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127"), String::from("======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========"), None, None, None) }
    pub fn resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set() -> DiagnosticMessage { diag(6128, DiagnosticCategory::Message, String::from("Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128"), String::from("======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========"), None, None, None) }
    pub fn resolving_real_path_for_0_result_1() -> DiagnosticMessage { diag(6130, DiagnosticCategory::Message, String::from("Resolving_real_path_for_0_result_1_6130"), String::from("Resolving real path for '{0}', result '{1}'."), None, None, None) }
    pub fn cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system() -> DiagnosticMessage { diag(6131, DiagnosticCategory::Error, String::from("Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131"), String::from("Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'."), None, None, None) }
    pub fn file_name_0_has_a_1_extension_stripping_it() -> DiagnosticMessage { diag(6132, DiagnosticCategory::Message, String::from("File_name_0_has_a_1_extension_stripping_it_6132"), String::from("File name '{0}' has a '{1}' extension - stripping it."), None, None, None) }
    pub fn _0_is_declared_but_its_value_is_never_read() -> DiagnosticMessage { diag(6133, DiagnosticCategory::Error, String::from("_0_is_declared_but_its_value_is_never_read_6133"), String::from("'{0}' is declared but its value is never read."), Some(true), None, None) }
    pub fn report_errors_on_unused_locals() -> DiagnosticMessage { diag(6134, DiagnosticCategory::Message, String::from("Report_errors_on_unused_locals_6134"), String::from("Report errors on unused locals."), None, None, None) }
    pub fn report_errors_on_unused_parameters() -> DiagnosticMessage { diag(6135, DiagnosticCategory::Message, String::from("Report_errors_on_unused_parameters_6135"), String::from("Report errors on unused parameters."), None, None, None) }
    pub fn the_maximum_dependency_depth_to_search_under_node_modules_and_load_javascript_files() -> DiagnosticMessage { diag(6136, DiagnosticCategory::Message, String::from("The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136"), String::from("The maximum dependency depth to search under node_modules and load JavaScript files."), None, None, None) }
    pub fn cannot_import_type_declaration_files_consider_importing_0_instead_of_1() -> DiagnosticMessage { diag(6137, DiagnosticCategory::Error, String::from("Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137"), String::from("Cannot import type declaration files. Consider importing '{0}' instead of '{1}'."), None, None, None) }
    pub fn property_0_is_declared_but_its_value_is_never_read() -> DiagnosticMessage { diag(6138, DiagnosticCategory::Error, String::from("Property_0_is_declared_but_its_value_is_never_read_6138"), String::from("Property '{0}' is declared but its value is never read."), Some(true), None, None) }
    pub fn import_emit_helpers_from_tslib() -> DiagnosticMessage { diag(6139, DiagnosticCategory::Message, String::from("Import_emit_helpers_from_tslib_6139"), String::from("Import emit helpers from 'tslib'."), None, None, None) }
    pub fn auto_discovery_for_typings_is_enabled_in_project_0_running_extra_resolution_pass_for_module_1_using_cache_location_2() -> DiagnosticMessage { diag(6140, DiagnosticCategory::Error, String::from("Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140"), String::from("Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'."), None, None, None) }
    pub fn parse_in_strict_mode_and_emit_use_strict_for_each_source_file() -> DiagnosticMessage { diag(6141, DiagnosticCategory::Message, String::from("Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141"), String::from("Parse in strict mode and emit \"use strict\" for each source file."), None, None, None) }
    pub fn module_0_was_resolved_to_1_but_jsx_is_not_set() -> DiagnosticMessage { diag(6142, DiagnosticCategory::Error, String::from("Module_0_was_resolved_to_1_but_jsx_is_not_set_6142"), String::from("Module '{0}' was resolved to '{1}', but '--jsx' is not set."), None, None, None) }
    pub fn module_0_was_resolved_as_locally_declared_ambient_module_in_file_1() -> DiagnosticMessage { diag(6144, DiagnosticCategory::Message, String::from("Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144"), String::from("Module '{0}' was resolved as locally declared ambient module in file '{1}'."), None, None, None) }
    pub fn specify_the_jsx_factory_function_to_use_when_targeting_react_jsx_emit_e_g_react_createelement_or_h() -> DiagnosticMessage { diag(6146, DiagnosticCategory::Message, String::from("Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146"), String::from("Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'."), None, None, None) }
    pub fn resolution_for_module_0_was_found_in_cache_from_location_1() -> DiagnosticMessage { diag(6147, DiagnosticCategory::Message, String::from("Resolution_for_module_0_was_found_in_cache_from_location_1_6147"), String::from("Resolution for module '{0}' was found in cache from location '{1}'."), None, None, None) }
    pub fn directory_0_does_not_exist_skipping_all_lookups_in_it() -> DiagnosticMessage { diag(6148, DiagnosticCategory::Message, String::from("Directory_0_does_not_exist_skipping_all_lookups_in_it_6148"), String::from("Directory '{0}' does not exist, skipping all lookups in it."), None, None, None) }
    pub fn show_diagnostic_information() -> DiagnosticMessage { diag(6149, DiagnosticCategory::Message, String::from("Show_diagnostic_information_6149"), String::from("Show diagnostic information."), None, None, None) }
    pub fn show_verbose_diagnostic_information() -> DiagnosticMessage { diag(6150, DiagnosticCategory::Message, String::from("Show_verbose_diagnostic_information_6150"), String::from("Show verbose diagnostic information."), None, None, None) }
    pub fn emit_a_single_file_with_source_maps_instead_of_having_a_separate_file() -> DiagnosticMessage { diag(6151, DiagnosticCategory::Message, String::from("Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151"), String::from("Emit a single file with source maps instead of having a separate file."), None, None, None) }
    pub fn emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlinesourcemap_or_sourcemap_to_be_set() -> DiagnosticMessage { diag(6152, DiagnosticCategory::Message, String::from("Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152"), String::from("Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set."), None, None, None) }
    pub fn transpile_each_file_as_a_separate_module_similar_to_ts_transpilemodule() -> DiagnosticMessage { diag(6153, DiagnosticCategory::Message, String::from("Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153"), String::from("Transpile each file as a separate module (similar to 'ts.transpileModule')."), None, None, None) }
    pub fn print_names_of_generated_files_part_of_the_compilation() -> DiagnosticMessage { diag(6154, DiagnosticCategory::Message, String::from("Print_names_of_generated_files_part_of_the_compilation_6154"), String::from("Print names of generated files part of the compilation."), None, None, None) }
    pub fn print_names_of_files_part_of_the_compilation() -> DiagnosticMessage { diag(6155, DiagnosticCategory::Message, String::from("Print_names_of_files_part_of_the_compilation_6155"), String::from("Print names of files part of the compilation."), None, None, None) }
    pub fn the_locale_used_when_displaying_messages_to_the_user_e_g_en_us() -> DiagnosticMessage { diag(6156, DiagnosticCategory::Message, String::from("The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156"), String::from("The locale used when displaying messages to the user (e.g. 'en-us')"), None, None, None) }
    pub fn do_not_generate_custom_helper_functions_like_extends_in_compiled_output() -> DiagnosticMessage { diag(6157, DiagnosticCategory::Message, String::from("Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157"), String::from("Do not generate custom helper functions like '__extends' in compiled output."), None, None, None) }
    pub fn do_not_include_the_default_library_file_lib_d_ts() -> DiagnosticMessage { diag(6158, DiagnosticCategory::Message, String::from("Do_not_include_the_default_library_file_lib_d_ts_6158"), String::from("Do not include the default library file (lib.d.ts)."), None, None, None) }
    pub fn do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files() -> DiagnosticMessage { diag(6159, DiagnosticCategory::Message, String::from("Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159"), String::from("Do not add triple-slash references or imported modules to the list of compiled files."), None, None, None) }
    pub fn deprecated_use_skiplibcheck_instead_skip_type_checking_of_default_library_declaration_files() -> DiagnosticMessage { diag(6160, DiagnosticCategory::Message, String::from("Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160"), String::from("[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files."), None, None, None) }
    pub fn list_of_folders_to_include_type_definitions_from() -> DiagnosticMessage { diag(6161, DiagnosticCategory::Message, String::from("List_of_folders_to_include_type_definitions_from_6161"), String::from("List of folders to include type definitions from."), None, None, None) }
    pub fn disable_size_limitations_on_javascript_projects() -> DiagnosticMessage { diag(6162, DiagnosticCategory::Message, String::from("Disable_size_limitations_on_JavaScript_projects_6162"), String::from("Disable size limitations on JavaScript projects."), None, None, None) }
    pub fn the_character_set_of_the_input_files() -> DiagnosticMessage { diag(6163, DiagnosticCategory::Message, String::from("The_character_set_of_the_input_files_6163"), String::from("The character set of the input files."), None, None, None) }
    pub fn skipping_module_0_that_looks_like_an_absolute_uri_target_file_types_colon_1() -> DiagnosticMessage { diag(6164, DiagnosticCategory::Message, String::from("Skipping_module_0_that_looks_like_an_absolute_URI_target_file_types_colon_1_6164"), String::from("Skipping module '{0}' that looks like an absolute URI, target file types: {1}."), None, None, None) }
    pub fn do_not_truncate_error_messages() -> DiagnosticMessage { diag(6165, DiagnosticCategory::Message, String::from("Do_not_truncate_error_messages_6165"), String::from("Do not truncate error messages."), None, None, None) }
    pub fn output_directory_for_generated_declaration_files() -> DiagnosticMessage { diag(6166, DiagnosticCategory::Message, String::from("Output_directory_for_generated_declaration_files_6166"), String::from("Output directory for generated declaration files."), None, None, None) }
    pub fn a_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseurl() -> DiagnosticMessage { diag(6167, DiagnosticCategory::Message, String::from("A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167"), String::from("A series of entries which re-map imports to lookup locations relative to the 'baseUrl'."), None, None, None) }
    pub fn list_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime() -> DiagnosticMessage { diag(6168, DiagnosticCategory::Message, String::from("List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168"), String::from("List of root folders whose combined content represents the structure of the project at runtime."), None, None, None) }
    pub fn show_all_compiler_options() -> DiagnosticMessage { diag(6169, DiagnosticCategory::Message, String::from("Show_all_compiler_options_6169"), String::from("Show all compiler options."), None, None, None) }
    pub fn deprecated_use_outfile_instead_concatenate_and_emit_output_to_single_file() -> DiagnosticMessage { diag(6170, DiagnosticCategory::Message, String::from("Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170"), String::from("[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file"), None, None, None) }
    pub fn command_line_options() -> DiagnosticMessage { diag(6171, DiagnosticCategory::Message, String::from("Command_line_Options_6171"), String::from("Command-line Options"), None, None, None) }
    pub fn provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_es5() -> DiagnosticMessage { diag(6179, DiagnosticCategory::Message, String::from("Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_6179"), String::from("Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5'."), None, None, None) }
    pub fn enable_all_strict_type_checking_options() -> DiagnosticMessage { diag(6180, DiagnosticCategory::Message, String::from("Enable_all_strict_type_checking_options_6180"), String::from("Enable all strict type-checking options."), None, None, None) }
    pub fn scoped_package_detected_looking_in_0() -> DiagnosticMessage { diag(6182, DiagnosticCategory::Message, String::from("Scoped_package_detected_looking_in_0_6182"), String::from("Scoped package detected, looking in '{0}'"), None, None, None) }
    pub fn reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2() -> DiagnosticMessage { diag(6183, DiagnosticCategory::Message, String::from("Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_6183"), String::from("Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."), None, None, None) }
    pub fn reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_package_id_3() -> DiagnosticMessage { diag(6184, DiagnosticCategory::Message, String::from("Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package__6184"), String::from("Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."), None, None, None) }
    pub fn enable_strict_checking_of_function_types() -> DiagnosticMessage { diag(6186, DiagnosticCategory::Message, String::from("Enable_strict_checking_of_function_types_6186"), String::from("Enable strict checking of function types."), None, None, None) }
    pub fn enable_strict_checking_of_property_initialization_in_classes() -> DiagnosticMessage { diag(6187, DiagnosticCategory::Message, String::from("Enable_strict_checking_of_property_initialization_in_classes_6187"), String::from("Enable strict checking of property initialization in classes."), None, None, None) }
    pub fn numeric_separators_are_not_allowed_here() -> DiagnosticMessage { diag(6188, DiagnosticCategory::Error, String::from("Numeric_separators_are_not_allowed_here_6188"), String::from("Numeric separators are not allowed here."), None, None, None) }
    pub fn multiple_consecutive_numeric_separators_are_not_permitted() -> DiagnosticMessage { diag(6189, DiagnosticCategory::Error, String::from("Multiple_consecutive_numeric_separators_are_not_permitted_6189"), String::from("Multiple consecutive numeric separators are not permitted."), None, None, None) }
    pub fn whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen() -> DiagnosticMessage { diag(6191, DiagnosticCategory::Message, String::from("Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191"), String::from("Whether to keep outdated console output in watch mode instead of clearing the screen."), None, None, None) }
    pub fn all_imports_in_import_declaration_are_unused() -> DiagnosticMessage { diag(6192, DiagnosticCategory::Error, String::from("All_imports_in_import_declaration_are_unused_6192"), String::from("All imports in import declaration are unused."), Some(true), None, None) }
    pub fn found_1_error_watching_for_file_changes() -> DiagnosticMessage { diag(6193, DiagnosticCategory::Message, String::from("Found_1_error_Watching_for_file_changes_6193"), String::from("Found 1 error. Watching for file changes."), None, None, None) }
    pub fn found_0_errors_watching_for_file_changes() -> DiagnosticMessage { diag(6194, DiagnosticCategory::Message, String::from("Found_0_errors_Watching_for_file_changes_6194"), String::from("Found {0} errors. Watching for file changes."), None, None, None) }
    pub fn resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols() -> DiagnosticMessage { diag(6195, DiagnosticCategory::Message, String::from("Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols_6195"), String::from("Resolve 'keyof' to string valued property names only (no numbers or symbols)."), None, None, None) }
    pub fn _0_is_declared_but_never_used() -> DiagnosticMessage { diag(6196, DiagnosticCategory::Error, String::from("_0_is_declared_but_never_used_6196"), String::from("'{0}' is declared but never used."), Some(true), None, None) }
    pub fn include_modules_imported_with_json_extension() -> DiagnosticMessage { diag(6197, DiagnosticCategory::Message, String::from("Include_modules_imported_with_json_extension_6197"), String::from("Include modules imported with '.json' extension"), None, None, None) }
    pub fn all_destructured_elements_are_unused() -> DiagnosticMessage { diag(6198, DiagnosticCategory::Error, String::from("All_destructured_elements_are_unused_6198"), String::from("All destructured elements are unused."), Some(true), None, None) }
    pub fn all_variables_are_unused() -> DiagnosticMessage { diag(6199, DiagnosticCategory::Error, String::from("All_variables_are_unused_6199"), String::from("All variables are unused."), Some(true), None, None) }
    pub fn definitions_of_the_following_identifiers_conflict_with_those_in_another_file_colon_0() -> DiagnosticMessage { diag(6200, DiagnosticCategory::Error, String::from("Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_colon_0_6200"), String::from("Definitions of the following identifiers conflict with those in another file: {0}"), None, None, None) }
    pub fn conflicts_are_in_this_file() -> DiagnosticMessage { diag(6201, DiagnosticCategory::Message, String::from("Conflicts_are_in_this_file_6201"), String::from("Conflicts are in this file."), None, None, None) }
    pub fn project_references_may_not_form_a_circular_graph_cycle_detected_colon_0() -> DiagnosticMessage { diag(6202, DiagnosticCategory::Error, String::from("Project_references_may_not_form_a_circular_graph_Cycle_detected_colon_0_6202"), String::from("Project references may not form a circular graph. Cycle detected: {0}"), None, None, None) }
    pub fn _0_was_also_declared_here() -> DiagnosticMessage { diag(6203, DiagnosticCategory::Message, String::from("_0_was_also_declared_here_6203"), String::from("'{0}' was also declared here."), None, None, None) }
    pub fn and_here() -> DiagnosticMessage { diag(6204, DiagnosticCategory::Message, String::from("and_here_6204"), String::from("and here."), None, None, None) }
    pub fn all_type_parameters_are_unused() -> DiagnosticMessage { diag(6205, DiagnosticCategory::Error, String::from("All_type_parameters_are_unused_6205"), String::from("All type parameters are unused."), None, None, None) }
    pub fn package_json_has_a_typesversions_field_with_version_specific_path_mappings() -> DiagnosticMessage { diag(6206, DiagnosticCategory::Message, String::from("package_json_has_a_typesVersions_field_with_version_specific_path_mappings_6206"), String::from("'package.json' has a 'typesVersions' field with version-specific path mappings."), None, None, None) }
    pub fn package_json_does_not_have_a_typesversions_entry_that_matches_version_0() -> DiagnosticMessage { diag(6207, DiagnosticCategory::Message, String::from("package_json_does_not_have_a_typesVersions_entry_that_matches_version_0_6207"), String::from("'package.json' does not have a 'typesVersions' entry that matches version '{0}'."), None, None, None) }
    pub fn package_json_has_a_typesversions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2() -> DiagnosticMessage { diag(6208, DiagnosticCategory::Message, String::from("package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_ma_6208"), String::from("'package.json' has a 'typesVersions' entry '{0}' that matches compiler version '{1}', looking for a pattern to match module name '{2}'."), None, None, None) }
    pub fn package_json_has_a_typesversions_entry_0_that_is_not_a_valid_semver_range() -> DiagnosticMessage { diag(6209, DiagnosticCategory::Message, String::from("package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range_6209"), String::from("'package.json' has a 'typesVersions' entry '{0}' that is not a valid semver range."), None, None, None) }
    pub fn an_argument_for_0_was_not_provided() -> DiagnosticMessage { diag(6210, DiagnosticCategory::Message, String::from("An_argument_for_0_was_not_provided_6210"), String::from("An argument for '{0}' was not provided."), None, None, None) }
    pub fn an_argument_matching_this_binding_pattern_was_not_provided() -> DiagnosticMessage { diag(6211, DiagnosticCategory::Message, String::from("An_argument_matching_this_binding_pattern_was_not_provided_6211"), String::from("An argument matching this binding pattern was not provided."), None, None, None) }
    pub fn did_you_mean_to_call_this_expression() -> DiagnosticMessage { diag(6212, DiagnosticCategory::Message, String::from("Did_you_mean_to_call_this_expression_6212"), String::from("Did you mean to call this expression?"), None, None, None) }
    pub fn did_you_mean_to_use_new_with_this_expression() -> DiagnosticMessage { diag(6213, DiagnosticCategory::Message, String::from("Did_you_mean_to_use_new_with_this_expression_6213"), String::from("Did you mean to use 'new' with this expression?"), None, None, None) }
    pub fn enable_strict_bind_call_and_apply_methods_on_functions() -> DiagnosticMessage { diag(6214, DiagnosticCategory::Message, String::from("Enable_strict_bind_call_and_apply_methods_on_functions_6214"), String::from("Enable strict 'bind', 'call', and 'apply' methods on functions."), None, None, None) }
    pub fn using_compiler_options_of_project_reference_redirect_0() -> DiagnosticMessage { diag(6215, DiagnosticCategory::Message, String::from("Using_compiler_options_of_project_reference_redirect_0_6215"), String::from("Using compiler options of project reference redirect '{0}'."), None, None, None) }
    pub fn found_1_error() -> DiagnosticMessage { diag(6216, DiagnosticCategory::Message, String::from("Found_1_error_6216"), String::from("Found 1 error."), None, None, None) }
    pub fn found_0_errors() -> DiagnosticMessage { diag(6217, DiagnosticCategory::Message, String::from("Found_0_errors_6217"), String::from("Found {0} errors."), None, None, None) }
    pub fn module_name_0_was_successfully_resolved_to_1_with_package_id_2() -> DiagnosticMessage { diag(6218, DiagnosticCategory::Message, String::from("Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2_6218"), String::from("======== Module name '{0}' was successfully resolved to '{1}' with Package ID '{2}'. ========"), None, None, None) }
    pub fn type_reference_directive_0_was_successfully_resolved_to_1_with_package_id_2_primary_colon_3() -> DiagnosticMessage { diag(6219, DiagnosticCategory::Message, String::from("Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_colon_3_6219"), String::from("======== Type reference directive '{0}' was successfully resolved to '{1}' with Package ID '{2}', primary: {3}. ========"), None, None, None) }
    pub fn package_json_had_a_falsy_0_field() -> DiagnosticMessage { diag(6220, DiagnosticCategory::Message, String::from("package_json_had_a_falsy_0_field_6220"), String::from("'package.json' had a falsy '{0}' field."), None, None, None) }
    pub fn disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects() -> DiagnosticMessage { diag(6221, DiagnosticCategory::Message, String::from("Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects_6221"), String::from("Disable use of source files instead of declaration files from referenced projects."), None, None, None) }
    pub fn emit_class_fields_with_define_instead_of_set() -> DiagnosticMessage { diag(6222, DiagnosticCategory::Message, String::from("Emit_class_fields_with_Define_instead_of_Set_6222"), String::from("Emit class fields with Define instead of Set."), None, None, None) }
    pub fn generates_a_cpu_profile() -> DiagnosticMessage { diag(6223, DiagnosticCategory::Message, String::from("Generates_a_CPU_profile_6223"), String::from("Generates a CPU profile."), None, None, None) }
    pub fn disable_solution_searching_for_this_project() -> DiagnosticMessage { diag(6224, DiagnosticCategory::Message, String::from("Disable_solution_searching_for_this_project_6224"), String::from("Disable solution searching for this project."), None, None, None) }
    pub fn specify_strategy_for_watching_file_colon_fixedpollinginterval_default_prioritypollinginterval_dynamicprioritypolling_fixedchunksizepolling_usefsevents_usefseventsonparentdirectory() -> DiagnosticMessage { diag(6225, DiagnosticCategory::Message, String::from("Specify_strategy_for_watching_file_colon_FixedPollingInterval_default_PriorityPollingInterval_Dynami_6225"), String::from("Specify strategy for watching file: 'FixedPollingInterval' (default), 'PriorityPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling', 'UseFsEvents', 'UseFsEventsOnParentDirectory'."), None, None, None) }
    pub fn specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_colon_usefsevents_default_fixedpollinginterval_dynamicprioritypolling_fixedchunksizepolling() -> DiagnosticMessage { diag(6226, DiagnosticCategory::Message, String::from("Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively__6226"), String::from("Specify strategy for watching directory on platforms that don't support recursive watching natively: 'UseFsEvents' (default), 'FixedPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling'."), None, None, None) }
    pub fn specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_colon_fixedinterval_default_priorityinterval_dynamicpriority_fixedchunksize() -> DiagnosticMessage { diag(6227, DiagnosticCategory::Message, String::from("Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_colon_6227"), String::from("Specify strategy for creating a polling watch when it fails to create using file system events: 'FixedInterval' (default), 'PriorityInterval', 'DynamicPriority', 'FixedChunkSize'."), None, None, None) }
    pub fn tag_0_expects_at_least_1_arguments_but_the_jsx_factory_2_provides_at_most_3() -> DiagnosticMessage { diag(6229, DiagnosticCategory::Error, String::from("Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3_6229"), String::from("Tag '{0}' expects at least '{1}' arguments, but the JSX factory '{2}' provides at most '{3}'."), None, None, None) }
    pub fn option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line() -> DiagnosticMessage { diag(6230, DiagnosticCategory::Error, String::from("Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line_6230"), String::from("Option '{0}' can only be specified in 'tsconfig.json' file or set to 'false' or 'null' on command line."), None, None, None) }
    pub fn could_not_resolve_the_path_0_with_the_extensions_colon_1() -> DiagnosticMessage { diag(6231, DiagnosticCategory::Error, String::from("Could_not_resolve_the_path_0_with_the_extensions_colon_1_6231"), String::from("Could not resolve the path '{0}' with the extensions: {1}."), None, None, None) }
    pub fn declaration_augments_declaration_in_another_file_this_cannot_be_serialized() -> DiagnosticMessage { diag(6232, DiagnosticCategory::Error, String::from("Declaration_augments_declaration_in_another_file_This_cannot_be_serialized_6232"), String::from("Declaration augments declaration in another file. This cannot be serialized."), None, None, None) }
    pub fn this_is_the_declaration_being_augmented_consider_moving_the_augmenting_declaration_into_the_same_file() -> DiagnosticMessage { diag(6233, DiagnosticCategory::Error, String::from("This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_fil_6233"), String::from("This is the declaration being augmented. Consider moving the augmenting declaration into the same file."), None, None, None) }
    pub fn this_expression_is_not_callable_because_it_is_a_get_accessor_did_you_mean_to_use_it_without() -> DiagnosticMessage { diag(6234, DiagnosticCategory::Error, String::from("This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without_6234"), String::from("This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?"), None, None, None) }
    pub fn disable_loading_referenced_projects() -> DiagnosticMessage { diag(6235, DiagnosticCategory::Message, String::from("Disable_loading_referenced_projects_6235"), String::from("Disable loading referenced projects."), None, None, None) }
    pub fn arguments_for_the_rest_parameter_0_were_not_provided() -> DiagnosticMessage { diag(6236, DiagnosticCategory::Error, String::from("Arguments_for_the_rest_parameter_0_were_not_provided_6236"), String::from("Arguments for the rest parameter '{0}' were not provided."), None, None, None) }
    pub fn generates_an_event_trace_and_a_list_of_types() -> DiagnosticMessage { diag(6237, DiagnosticCategory::Message, String::from("Generates_an_event_trace_and_a_list_of_types_6237"), String::from("Generates an event trace and a list of types."), None, None, None) }
    pub fn specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react() -> DiagnosticMessage { diag(6238, DiagnosticCategory::Error, String::from("Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react_6238"), String::from("Specify the module specifier to be used to import the 'jsx' and 'jsxs' factory functions from. eg, react"), None, None, None) }
    pub fn file_0_exists_according_to_earlier_cached_lookups() -> DiagnosticMessage { diag(6239, DiagnosticCategory::Message, String::from("File_0_exists_according_to_earlier_cached_lookups_6239"), String::from("File '{0}' exists according to earlier cached lookups."), None, None, None) }
    pub fn file_0_does_not_exist_according_to_earlier_cached_lookups() -> DiagnosticMessage { diag(6240, DiagnosticCategory::Message, String::from("File_0_does_not_exist_according_to_earlier_cached_lookups_6240"), String::from("File '{0}' does not exist according to earlier cached lookups."), None, None, None) }
    pub fn resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1() -> DiagnosticMessage { diag(6241, DiagnosticCategory::Message, String::from("Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1_6241"), String::from("Resolution for type reference directive '{0}' was found in cache from location '{1}'."), None, None, None) }
    pub fn resolving_type_reference_directive_0_containing_file_1() -> DiagnosticMessage { diag(6242, DiagnosticCategory::Message, String::from("Resolving_type_reference_directive_0_containing_file_1_6242"), String::from("======== Resolving type reference directive '{0}', containing file '{1}'. ========"), None, None, None) }
    pub fn interpret_optional_property_types_as_written_rather_than_adding_undefined() -> DiagnosticMessage { diag(6243, DiagnosticCategory::Message, String::from("Interpret_optional_property_types_as_written_rather_than_adding_undefined_6243"), String::from("Interpret optional property types as written, rather than adding 'undefined'."), None, None, None) }
    pub fn modules() -> DiagnosticMessage { diag(6244, DiagnosticCategory::Message, String::from("Modules_6244"), String::from("Modules"), None, None, None) }
    pub fn file_management() -> DiagnosticMessage { diag(6245, DiagnosticCategory::Message, String::from("File_Management_6245"), String::from("File Management"), None, None, None) }
    pub fn emit() -> DiagnosticMessage { diag(6246, DiagnosticCategory::Message, String::from("Emit_6246"), String::from("Emit"), None, None, None) }
    pub fn javascript_support() -> DiagnosticMessage { diag(6247, DiagnosticCategory::Message, String::from("JavaScript_Support_6247"), String::from("JavaScript Support"), None, None, None) }
    pub fn type_checking() -> DiagnosticMessage { diag(6248, DiagnosticCategory::Message, String::from("Type_Checking_6248"), String::from("Type Checking"), None, None, None) }
    pub fn editor_support() -> DiagnosticMessage { diag(6249, DiagnosticCategory::Message, String::from("Editor_Support_6249"), String::from("Editor Support"), None, None, None) }
    pub fn watch_and_build_modes() -> DiagnosticMessage { diag(6250, DiagnosticCategory::Message, String::from("Watch_and_Build_Modes_6250"), String::from("Watch and Build Modes"), None, None, None) }
    pub fn compiler_diagnostics() -> DiagnosticMessage { diag(6251, DiagnosticCategory::Message, String::from("Compiler_Diagnostics_6251"), String::from("Compiler Diagnostics"), None, None, None) }
    pub fn interop_constraints() -> DiagnosticMessage { diag(6252, DiagnosticCategory::Message, String::from("Interop_Constraints_6252"), String::from("Interop Constraints"), None, None, None) }
    pub fn backwards_compatibility() -> DiagnosticMessage { diag(6253, DiagnosticCategory::Message, String::from("Backwards_Compatibility_6253"), String::from("Backwards Compatibility"), None, None, None) }
    pub fn language_and_environment() -> DiagnosticMessage { diag(6254, DiagnosticCategory::Message, String::from("Language_and_Environment_6254"), String::from("Language and Environment"), None, None, None) }
    pub fn projects() -> DiagnosticMessage { diag(6255, DiagnosticCategory::Message, String::from("Projects_6255"), String::from("Projects"), None, None, None) }
    pub fn output_formatting() -> DiagnosticMessage { diag(6256, DiagnosticCategory::Message, String::from("Output_Formatting_6256"), String::from("Output Formatting"), None, None, None) }
    pub fn completeness() -> DiagnosticMessage { diag(6257, DiagnosticCategory::Message, String::from("Completeness_6257"), String::from("Completeness"), None, None, None) }
    pub fn _0_should_be_set_inside_the_compileroptions_object_of_the_config_json_file() -> DiagnosticMessage { diag(6258, DiagnosticCategory::Error, String::from("_0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file_6258"), String::from("'{0}' should be set inside the 'compilerOptions' object of the config json file"), None, None, None) }
    pub fn found_1_error_in_0() -> DiagnosticMessage { diag(6259, DiagnosticCategory::Message, String::from("Found_1_error_in_0_6259"), String::from("Found 1 error in {0}"), None, None, None) }
    pub fn found_0_errors_in_the_same_file_starting_at_colon_1() -> DiagnosticMessage { diag(6260, DiagnosticCategory::Message, String::from("Found_0_errors_in_the_same_file_starting_at_colon_1_6260"), String::from("Found {0} errors in the same file, starting at: {1}"), None, None, None) }
    pub fn found_0_errors_in_1_files() -> DiagnosticMessage { diag(6261, DiagnosticCategory::Message, String::from("Found_0_errors_in_1_files_6261"), String::from("Found {0} errors in {1} files."), None, None, None) }
    pub fn file_name_0_has_a_1_extension_looking_up_2_instead() -> DiagnosticMessage { diag(6262, DiagnosticCategory::Message, String::from("File_name_0_has_a_1_extension_looking_up_2_instead_6262"), String::from("File name '{0}' has a '{1}' extension - looking up '{2}' instead."), None, None, None) }
    pub fn module_0_was_resolved_to_1_but_allowarbitraryextensions_is_not_set() -> DiagnosticMessage { diag(6263, DiagnosticCategory::Error, String::from("Module_0_was_resolved_to_1_but_allowArbitraryExtensions_is_not_set_6263"), String::from("Module '{0}' was resolved to '{1}', but '--allowArbitraryExtensions' is not set."), None, None, None) }
    pub fn enable_importing_files_with_any_extension_provided_a_declaration_file_is_present() -> DiagnosticMessage { diag(6264, DiagnosticCategory::Message, String::from("Enable_importing_files_with_any_extension_provided_a_declaration_file_is_present_6264"), String::from("Enable importing files with any extension, provided a declaration file is present."), None, None, None) }
    pub fn resolving_type_reference_directive_for_program_that_specifies_custom_typeroots_skipping_lookup_in_node_modules_folder() -> DiagnosticMessage { diag(6265, DiagnosticCategory::Message, String::from("Resolving_type_reference_directive_for_program_that_specifies_custom_typeRoots_skipping_lookup_in_no_6265"), String::from("Resolving type reference directive for program that specifies custom typeRoots, skipping lookup in 'node_modules' folder."), None, None, None) }
    pub fn option_0_can_only_be_specified_on_command_line() -> DiagnosticMessage { diag(6266, DiagnosticCategory::Error, String::from("Option_0_can_only_be_specified_on_command_line_6266"), String::from("Option '{0}' can only be specified on command line."), None, None, None) }
    pub fn directory_0_has_no_containing_package_json_scope_imports_will_not_resolve() -> DiagnosticMessage { diag(6270, DiagnosticCategory::Message, String::from("Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve_6270"), String::from("Directory '{0}' has no containing package.json scope. Imports will not resolve."), None, None, None) }
    pub fn import_specifier_0_does_not_exist_in_package_json_scope_at_path_1() -> DiagnosticMessage { diag(6271, DiagnosticCategory::Message, String::from("Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6271"), String::from("Import specifier '{0}' does not exist in package.json scope at path '{1}'."), None, None, None) }
    pub fn invalid_import_specifier_0_has_no_possible_resolutions() -> DiagnosticMessage { diag(6272, DiagnosticCategory::Message, String::from("Invalid_import_specifier_0_has_no_possible_resolutions_6272"), String::from("Invalid import specifier '{0}' has no possible resolutions."), None, None, None) }
    pub fn package_json_scope_0_has_no_imports_defined() -> DiagnosticMessage { diag(6273, DiagnosticCategory::Message, String::from("package_json_scope_0_has_no_imports_defined_6273"), String::from("package.json scope '{0}' has no imports defined."), None, None, None) }
    pub fn package_json_scope_0_explicitly_maps_specifier_1_to_null() -> DiagnosticMessage { diag(6274, DiagnosticCategory::Message, String::from("package_json_scope_0_explicitly_maps_specifier_1_to_null_6274"), String::from("package.json scope '{0}' explicitly maps specifier '{1}' to null."), None, None, None) }
    pub fn package_json_scope_0_has_invalid_type_for_target_of_specifier_1() -> DiagnosticMessage { diag(6275, DiagnosticCategory::Message, String::from("package_json_scope_0_has_invalid_type_for_target_of_specifier_1_6275"), String::from("package.json scope '{0}' has invalid type for target of specifier '{1}'"), None, None, None) }
    pub fn export_specifier_0_does_not_exist_in_package_json_scope_at_path_1() -> DiagnosticMessage { diag(6276, DiagnosticCategory::Message, String::from("Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6276"), String::from("Export specifier '{0}' does not exist in package.json scope at path '{1}'."), None, None, None) }
    pub fn resolution_of_non_relative_name_failed_trying_with_modern_node_resolution_features_disabled_to_see_if_npm_library_needs_configuration_update() -> DiagnosticMessage { diag(6277, DiagnosticCategory::Message, String::from("Resolution_of_non_relative_name_failed_trying_with_modern_Node_resolution_features_disabled_to_see_i_6277"), String::from("Resolution of non-relative name failed; trying with modern Node resolution features disabled to see if npm library needs configuration update."), None, None, None) }
    pub fn there_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_the_1_library_may_need_to_update_its_package_json_or_typings() -> DiagnosticMessage { diag(6278, DiagnosticCategory::Message, String::from("There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The__6278"), String::from("There are types at '{0}', but this result could not be resolved when respecting package.json \"exports\". The '{1}' library may need to update its package.json or typings."), None, None, None) }
    pub fn resolution_of_non_relative_name_failed_trying_with_moduleresolution_bundler_to_see_if_project_may_need_configuration_update() -> DiagnosticMessage { diag(6279, DiagnosticCategory::Message, String::from("Resolution_of_non_relative_name_failed_trying_with_moduleResolution_bundler_to_see_if_project_may_ne_6279"), String::from("Resolution of non-relative name failed; trying with '--moduleResolution bundler' to see if project may need configuration update."), None, None, None) }
    pub fn there_are_types_at_0_but_this_result_could_not_be_resolved_under_your_current_moduleresolution_setting_consider_updating_to_node16_nodenext_or_bundler() -> DiagnosticMessage { diag(6280, DiagnosticCategory::Message, String::from("There_are_types_at_0_but_this_result_could_not_be_resolved_under_your_current_moduleResolution_setti_6280"), String::from("There are types at '{0}', but this result could not be resolved under your current 'moduleResolution' setting. Consider updating to 'node16', 'nodenext', or 'bundler'."), None, None, None) }
    pub fn package_json_has_a_peerdependencies_field() -> DiagnosticMessage { diag(6281, DiagnosticCategory::Message, String::from("package_json_has_a_peerDependencies_field_6281"), String::from("'package.json' has a 'peerDependencies' field."), None, None, None) }
    pub fn found_peerdependency_0_with_1_version() -> DiagnosticMessage { diag(6282, DiagnosticCategory::Message, String::from("Found_peerDependency_0_with_1_version_6282"), String::from("Found peerDependency '{0}' with '{1}' version."), None, None, None) }
    pub fn failed_to_find_peerdependency_0() -> DiagnosticMessage { diag(6283, DiagnosticCategory::Message, String::from("Failed_to_find_peerDependency_0_6283"), String::from("Failed to find peerDependency '{0}'."), None, None, None) }
    pub fn enable_project_compilation() -> DiagnosticMessage { diag(6302, DiagnosticCategory::Message, String::from("Enable_project_compilation_6302"), String::from("Enable project compilation"), None, None, None) }
    pub fn composite_projects_may_not_disable_declaration_emit() -> DiagnosticMessage { diag(6304, DiagnosticCategory::Error, String::from("Composite_projects_may_not_disable_declaration_emit_6304"), String::from("Composite projects may not disable declaration emit."), None, None, None) }
    pub fn output_file_0_has_not_been_built_from_source_file_1() -> DiagnosticMessage { diag(6305, DiagnosticCategory::Error, String::from("Output_file_0_has_not_been_built_from_source_file_1_6305"), String::from("Output file '{0}' has not been built from source file '{1}'."), None, None, None) }
    pub fn referenced_project_0_must_have_setting_composite_colon_true() -> DiagnosticMessage { diag(6306, DiagnosticCategory::Error, String::from("Referenced_project_0_must_have_setting_composite_colon_true_6306"), String::from("Referenced project '{0}' must have setting \"composite\": true."), None, None, None) }
    pub fn file_0_is_not_listed_within_the_file_list_of_project_1_projects_must_list_all_files_or_use_an_include_pattern() -> DiagnosticMessage { diag(6307, DiagnosticCategory::Error, String::from("File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_includ_6307"), String::from("File '{0}' is not listed within the file list of project '{1}'. Projects must list all files or use an 'include' pattern."), None, None, None) }
    pub fn referenced_project_0_may_not_disable_emit() -> DiagnosticMessage { diag(6310, DiagnosticCategory::Error, String::from("Referenced_project_0_may_not_disable_emit_6310"), String::from("Referenced project '{0}' may not disable emit."), None, None, None) }
    pub fn project_0_is_out_of_date_because_output_1_is_older_than_input_2() -> DiagnosticMessage { diag(6350, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_output_1_is_older_than_input_2_6350"), String::from("Project '{0}' is out of date because output '{1}' is older than input '{2}'"), None, None, None) }
    pub fn project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2() -> DiagnosticMessage { diag(6351, DiagnosticCategory::Message, String::from("Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2_6351"), String::from("Project '{0}' is up to date because newest input '{1}' is older than output '{2}'"), None, None, None) }
    pub fn project_0_is_out_of_date_because_output_file_1_does_not_exist() -> DiagnosticMessage { diag(6352, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_output_file_1_does_not_exist_6352"), String::from("Project '{0}' is out of date because output file '{1}' does not exist"), None, None, None) }
    pub fn project_0_is_out_of_date_because_its_dependency_1_is_out_of_date() -> DiagnosticMessage { diag(6353, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date_6353"), String::from("Project '{0}' is out of date because its dependency '{1}' is out of date"), None, None, None) }
    pub fn project_0_is_up_to_date_with_d_ts_files_from_its_dependencies() -> DiagnosticMessage { diag(6354, DiagnosticCategory::Message, String::from("Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies_6354"), String::from("Project '{0}' is up to date with .d.ts files from its dependencies"), None, None, None) }
    pub fn projects_in_this_build_colon_0() -> DiagnosticMessage { diag(6355, DiagnosticCategory::Message, String::from("Projects_in_this_build_colon_0_6355"), String::from("Projects in this build: {0}"), None, None, None) }
    pub fn a_non_dry_build_would_delete_the_following_files_colon_0() -> DiagnosticMessage { diag(6356, DiagnosticCategory::Message, String::from("A_non_dry_build_would_delete_the_following_files_colon_0_6356"), String::from("A non-dry build would delete the following files: {0}"), None, None, None) }
    pub fn a_non_dry_build_would_build_project_0() -> DiagnosticMessage { diag(6357, DiagnosticCategory::Message, String::from("A_non_dry_build_would_build_project_0_6357"), String::from("A non-dry build would build project '{0}'"), None, None, None) }
    pub fn building_project_0() -> DiagnosticMessage { diag(6358, DiagnosticCategory::Message, String::from("Building_project_0_6358"), String::from("Building project '{0}'..."), None, None, None) }
    pub fn updating_output_timestamps_of_project_0() -> DiagnosticMessage { diag(6359, DiagnosticCategory::Message, String::from("Updating_output_timestamps_of_project_0_6359"), String::from("Updating output timestamps of project '{0}'..."), None, None, None) }
    pub fn project_0_is_up_to_date() -> DiagnosticMessage { diag(6361, DiagnosticCategory::Message, String::from("Project_0_is_up_to_date_6361"), String::from("Project '{0}' is up to date"), None, None, None) }
    pub fn skipping_build_of_project_0_because_its_dependency_1_has_errors() -> DiagnosticMessage { diag(6362, DiagnosticCategory::Message, String::from("Skipping_build_of_project_0_because_its_dependency_1_has_errors_6362"), String::from("Skipping build of project '{0}' because its dependency '{1}' has errors"), None, None, None) }
    pub fn project_0_can_t_be_built_because_its_dependency_1_has_errors() -> DiagnosticMessage { diag(6363, DiagnosticCategory::Message, String::from("Project_0_can_t_be_built_because_its_dependency_1_has_errors_6363"), String::from("Project '{0}' can't be built because its dependency '{1}' has errors"), None, None, None) }
    pub fn build_one_or_more_projects_and_their_dependencies_if_out_of_date() -> DiagnosticMessage { diag(6364, DiagnosticCategory::Message, String::from("Build_one_or_more_projects_and_their_dependencies_if_out_of_date_6364"), String::from("Build one or more projects and their dependencies, if out of date"), None, None, None) }
    pub fn delete_the_outputs_of_all_projects() -> DiagnosticMessage { diag(6365, DiagnosticCategory::Message, String::from("Delete_the_outputs_of_all_projects_6365"), String::from("Delete the outputs of all projects."), None, None, None) }
    pub fn show_what_would_be_built_or_deleted_if_specified_with_clean() -> DiagnosticMessage { diag(6367, DiagnosticCategory::Message, String::from("Show_what_would_be_built_or_deleted_if_specified_with_clean_6367"), String::from("Show what would be built (or deleted, if specified with '--clean')"), None, None, None) }
    pub fn option_build_must_be_the_first_command_line_argument() -> DiagnosticMessage { diag(6369, DiagnosticCategory::Error, String::from("Option_build_must_be_the_first_command_line_argument_6369"), String::from("Option '--build' must be the first command line argument."), None, None, None) }
    pub fn options_0_and_1_cannot_be_combined() -> DiagnosticMessage { diag(6370, DiagnosticCategory::Error, String::from("Options_0_and_1_cannot_be_combined_6370"), String::from("Options '{0}' and '{1}' cannot be combined."), None, None, None) }
    pub fn updating_unchanged_output_timestamps_of_project_0() -> DiagnosticMessage { diag(6371, DiagnosticCategory::Message, String::from("Updating_unchanged_output_timestamps_of_project_0_6371"), String::from("Updating unchanged output timestamps of project '{0}'..."), None, None, None) }
    pub fn a_non_dry_build_would_update_timestamps_for_output_of_project_0() -> DiagnosticMessage { diag(6374, DiagnosticCategory::Message, String::from("A_non_dry_build_would_update_timestamps_for_output_of_project_0_6374"), String::from("A non-dry build would update timestamps for output of project '{0}'"), None, None, None) }
    pub fn cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1() -> DiagnosticMessage { diag(6377, DiagnosticCategory::Error, String::from("Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1_6377"), String::from("Cannot write file '{0}' because it will overwrite '.tsbuildinfo' file generated by referenced project '{1}'"), None, None, None) }
    pub fn composite_projects_may_not_disable_incremental_compilation() -> DiagnosticMessage { diag(6379, DiagnosticCategory::Error, String::from("Composite_projects_may_not_disable_incremental_compilation_6379"), String::from("Composite projects may not disable incremental compilation."), None, None, None) }
    pub fn specify_file_to_store_incremental_compilation_information() -> DiagnosticMessage { diag(6380, DiagnosticCategory::Message, String::from("Specify_file_to_store_incremental_compilation_information_6380"), String::from("Specify file to store incremental compilation information"), None, None, None) }
    pub fn project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2() -> DiagnosticMessage { diag(6381, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_curren_6381"), String::from("Project '{0}' is out of date because output for it was generated with version '{1}' that differs with current version '{2}'"), None, None, None) }
    pub fn skipping_build_of_project_0_because_its_dependency_1_was_not_built() -> DiagnosticMessage { diag(6382, DiagnosticCategory::Message, String::from("Skipping_build_of_project_0_because_its_dependency_1_was_not_built_6382"), String::from("Skipping build of project '{0}' because its dependency '{1}' was not built"), None, None, None) }
    pub fn project_0_can_t_be_built_because_its_dependency_1_was_not_built() -> DiagnosticMessage { diag(6383, DiagnosticCategory::Message, String::from("Project_0_can_t_be_built_because_its_dependency_1_was_not_built_6383"), String::from("Project '{0}' can't be built because its dependency '{1}' was not built"), None, None, None) }
    pub fn have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it() -> DiagnosticMessage { diag(6384, DiagnosticCategory::Message, String::from("Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_di_6384"), String::from("Have recompiles in '--incremental' and '--watch' assume that changes within a file will only affect files directly depending on it."), None, None, None) }
    pub fn _0_is_deprecated() -> DiagnosticMessage { diag(6385, DiagnosticCategory::Suggestion, String::from("_0_is_deprecated_6385"), String::from("'{0}' is deprecated."), None, None, Some(true)) }
    pub fn performance_timings_for_diagnostics_or_extendeddiagnostics_are_not_available_in_this_session_a_native_implementation_of_the_web_performance_api_could_not_be_found() -> DiagnosticMessage { diag(6386, DiagnosticCategory::Message, String::from("Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_nativ_6386"), String::from("Performance timings for '--diagnostics' or '--extendedDiagnostics' are not available in this session. A native implementation of the Web Performance API could not be found."), None, None, None) }
    pub fn the_signature_0_of_1_is_deprecated() -> DiagnosticMessage { diag(6387, DiagnosticCategory::Suggestion, String::from("The_signature_0_of_1_is_deprecated_6387"), String::from("The signature '{0}' of '{1}' is deprecated."), None, None, Some(true)) }
    pub fn project_0_is_being_forcibly_rebuilt() -> DiagnosticMessage { diag(6388, DiagnosticCategory::Message, String::from("Project_0_is_being_forcibly_rebuilt_6388"), String::from("Project '{0}' is being forcibly rebuilt"), None, None, None) }
    pub fn reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved() -> DiagnosticMessage { diag(6389, DiagnosticCategory::Message, String::from("Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved_6389"), String::from("Reusing resolution of module '{0}' from '{1}' of old program, it was not resolved."), None, None, None) }
    pub fn reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2() -> DiagnosticMessage { diag(6390, DiagnosticCategory::Message, String::from("Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6390"), String::from("Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."), None, None, None) }
    pub fn reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_package_id_3() -> DiagnosticMessage { diag(6391, DiagnosticCategory::Message, String::from("Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6391"), String::from("Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."), None, None, None) }
    pub fn reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved() -> DiagnosticMessage { diag(6392, DiagnosticCategory::Message, String::from("Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved_6392"), String::from("Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was not resolved."), None, None, None) }
    pub fn reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3() -> DiagnosticMessage { diag(6393, DiagnosticCategory::Message, String::from("Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6393"), String::from("Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."), None, None, None) }
    pub fn reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_package_id_4() -> DiagnosticMessage { diag(6394, DiagnosticCategory::Message, String::from("Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6394"), String::from("Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."), None, None, None) }
    pub fn reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved() -> DiagnosticMessage { diag(6395, DiagnosticCategory::Message, String::from("Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved_6395"), String::from("Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was not resolved."), None, None, None) }
    pub fn reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3() -> DiagnosticMessage { diag(6396, DiagnosticCategory::Message, String::from("Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6396"), String::from("Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."), None, None, None) }
    pub fn reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_package_id_4() -> DiagnosticMessage { diag(6397, DiagnosticCategory::Message, String::from("Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6397"), String::from("Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."), None, None, None) }
    pub fn reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved() -> DiagnosticMessage { diag(6398, DiagnosticCategory::Message, String::from("Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_re_6398"), String::from("Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was not resolved."), None, None, None) }
    pub fn project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitted() -> DiagnosticMessage { diag(6399, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitte_6399"), String::from("Project '{0}' is out of date because buildinfo file '{1}' indicates that some of the changes were not emitted"), None, None, None) }
    pub fn project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_files() -> DiagnosticMessage { diag(6400, DiagnosticCategory::Message, String::from("Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_fil_6400"), String::from("Project '{0}' is up to date but needs to update timestamps of output files that are older than input files"), None, None, None) }
    pub fn project_0_is_out_of_date_because_there_was_error_reading_file_1() -> DiagnosticMessage { diag(6401, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_there_was_error_reading_file_1_6401"), String::from("Project '{0}' is out of date because there was error reading file '{1}'"), None, None, None) }
    pub fn resolving_in_0_mode_with_conditions_1() -> DiagnosticMessage { diag(6402, DiagnosticCategory::Message, String::from("Resolving_in_0_mode_with_conditions_1_6402"), String::from("Resolving in {0} mode with conditions {1}."), None, None, None) }
    pub fn matched_0_condition_1() -> DiagnosticMessage { diag(6403, DiagnosticCategory::Message, String::from("Matched_0_condition_1_6403"), String::from("Matched '{0}' condition '{1}'."), None, None, None) }
    pub fn using_0_subpath_1_with_target_2() -> DiagnosticMessage { diag(6404, DiagnosticCategory::Message, String::from("Using_0_subpath_1_with_target_2_6404"), String::from("Using '{0}' subpath '{1}' with target '{2}'."), None, None, None) }
    pub fn saw_non_matching_condition_0() -> DiagnosticMessage { diag(6405, DiagnosticCategory::Message, String::from("Saw_non_matching_condition_0_6405"), String::from("Saw non-matching condition '{0}'."), None, None, None) }
    pub fn project_0_is_out_of_date_because_buildinfo_file_1_indicates_there_is_change_in_compileroptions() -> DiagnosticMessage { diag(6406, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_buildinfo_file_1_indicates_there_is_change_in_compilerOptions_6406"), String::from("Project '{0}' is out of date because buildinfo file '{1}' indicates there is change in compilerOptions"), None, None, None) }
    pub fn allow_imports_to_include_typescript_file_extensions_requires_moduleresolution_bundler_and_either_noemit_or_emitdeclarationonly_to_be_set() -> DiagnosticMessage { diag(6407, DiagnosticCategory::Message, String::from("Allow_imports_to_include_TypeScript_file_extensions_Requires_moduleResolution_bundler_and_either_noE_6407"), String::from("Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set."), None, None, None) }
    pub fn use_the_package_json_exports_field_when_resolving_package_imports() -> DiagnosticMessage { diag(6408, DiagnosticCategory::Message, String::from("Use_the_package_json_exports_field_when_resolving_package_imports_6408"), String::from("Use the package.json 'exports' field when resolving package imports."), None, None, None) }
    pub fn use_the_package_json_imports_field_when_resolving_imports() -> DiagnosticMessage { diag(6409, DiagnosticCategory::Message, String::from("Use_the_package_json_imports_field_when_resolving_imports_6409"), String::from("Use the package.json 'imports' field when resolving imports."), None, None, None) }
    pub fn conditions_to_set_in_addition_to_the_resolver_specific_defaults_when_resolving_imports() -> DiagnosticMessage { diag(6410, DiagnosticCategory::Message, String::from("Conditions_to_set_in_addition_to_the_resolver_specific_defaults_when_resolving_imports_6410"), String::from("Conditions to set in addition to the resolver-specific defaults when resolving imports."), None, None, None) }
    pub fn true_when_moduleresolution_is_node16_nodenext_or_bundler_otherwise_false() -> DiagnosticMessage { diag(6411, DiagnosticCategory::Message, String::from("true_when_moduleResolution_is_node16_nodenext_or_bundler_otherwise_false_6411"), String::from("`true` when 'moduleResolution' is 'node16', 'nodenext', or 'bundler'; otherwise `false`."), None, None, None) }
    pub fn project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_file_2_was_root_file_of_compilation_but_not_any_more() -> DiagnosticMessage { diag(6412, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_file_2_was_root_file_of_compilation_6412"), String::from("Project '{0}' is out of date because buildinfo file '{1}' indicates that file '{2}' was root file of compilation but not any more."), None, None, None) }
    pub fn entering_conditional_exports() -> DiagnosticMessage { diag(6413, DiagnosticCategory::Message, String::from("Entering_conditional_exports_6413"), String::from("Entering conditional exports."), None, None, None) }
    pub fn resolved_under_condition_0() -> DiagnosticMessage { diag(6414, DiagnosticCategory::Message, String::from("Resolved_under_condition_0_6414"), String::from("Resolved under condition '{0}'."), None, None, None) }
    pub fn failed_to_resolve_under_condition_0() -> DiagnosticMessage { diag(6415, DiagnosticCategory::Message, String::from("Failed_to_resolve_under_condition_0_6415"), String::from("Failed to resolve under condition '{0}'."), None, None, None) }
    pub fn exiting_conditional_exports() -> DiagnosticMessage { diag(6416, DiagnosticCategory::Message, String::from("Exiting_conditional_exports_6416"), String::from("Exiting conditional exports."), None, None, None) }
    pub fn searching_all_ancestor_node_modules_directories_for_preferred_extensions_colon_0() -> DiagnosticMessage { diag(6417, DiagnosticCategory::Message, String::from("Searching_all_ancestor_node_modules_directories_for_preferred_extensions_colon_0_6417"), String::from("Searching all ancestor node_modules directories for preferred extensions: {0}."), None, None, None) }
    pub fn searching_all_ancestor_node_modules_directories_for_fallback_extensions_colon_0() -> DiagnosticMessage { diag(6418, DiagnosticCategory::Message, String::from("Searching_all_ancestor_node_modules_directories_for_fallback_extensions_colon_0_6418"), String::from("Searching all ancestor node_modules directories for fallback extensions: {0}."), None, None, None) }
    pub fn project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_program_needs_to_report_errors() -> DiagnosticMessage { diag(6419, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_program_needs_to_report_errors_6419"), String::from("Project '{0}' is out of date because buildinfo file '{1}' indicates that program needs to report errors."), None, None, None) }
    pub fn project_0_is_out_of_date_because_1() -> DiagnosticMessage { diag(6420, DiagnosticCategory::Message, String::from("Project_0_is_out_of_date_because_1_6420"), String::from("Project '{0}' is out of date because {1}."), None, None, None) }
    pub fn the_expected_type_comes_from_property_0_which_is_declared_here_on_type_1() -> DiagnosticMessage { diag(6500, DiagnosticCategory::Message, String::from("The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1_6500"), String::from("The expected type comes from property '{0}' which is declared here on type '{1}'"), None, None, None) }
    pub fn the_expected_type_comes_from_this_index_signature() -> DiagnosticMessage { diag(6501, DiagnosticCategory::Message, String::from("The_expected_type_comes_from_this_index_signature_6501"), String::from("The expected type comes from this index signature."), None, None, None) }
    pub fn the_expected_type_comes_from_the_return_type_of_this_signature() -> DiagnosticMessage { diag(6502, DiagnosticCategory::Message, String::from("The_expected_type_comes_from_the_return_type_of_this_signature_6502"), String::from("The expected type comes from the return type of this signature."), None, None, None) }
    pub fn print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing() -> DiagnosticMessage { diag(6503, DiagnosticCategory::Message, String::from("Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing_6503"), String::from("Print names of files that are part of the compilation and then stop processing."), None, None, None) }
    pub fn file_0_is_a_javascript_file_did_you_mean_to_enable_the_allowjs_option() -> DiagnosticMessage { diag(6504, DiagnosticCategory::Error, String::from("File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option_6504"), String::from("File '{0}' is a JavaScript file. Did you mean to enable the 'allowJs' option?"), None, None, None) }
    pub fn print_names_of_files_and_the_reason_they_are_part_of_the_compilation() -> DiagnosticMessage { diag(6505, DiagnosticCategory::Message, String::from("Print_names_of_files_and_the_reason_they_are_part_of_the_compilation_6505"), String::from("Print names of files and the reason they are part of the compilation."), None, None, None) }
    pub fn consider_adding_a_declare_modifier_to_this_class() -> DiagnosticMessage { diag(6506, DiagnosticCategory::Message, String::from("Consider_adding_a_declare_modifier_to_this_class_6506"), String::from("Consider adding a 'declare' modifier to this class."), None, None, None) }
    pub fn allow_javascript_files_to_be_a_part_of_your_program_use_the_checkjs_option_to_get_errors_from_these_files() -> DiagnosticMessage { diag(6600, DiagnosticCategory::Message, String::from("Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these__6600"), String::from("Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files."), None, None, None) }
    pub fn allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export() -> DiagnosticMessage { diag(6601, DiagnosticCategory::Message, String::from("Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export_6601"), String::from("Allow 'import x from y' when a module doesn't have a default export."), None, None, None) }
    pub fn allow_accessing_umd_globals_from_modules() -> DiagnosticMessage { diag(6602, DiagnosticCategory::Message, String::from("Allow_accessing_UMD_globals_from_modules_6602"), String::from("Allow accessing UMD globals from modules."), None, None, None) }
    pub fn disable_error_reporting_for_unreachable_code() -> DiagnosticMessage { diag(6603, DiagnosticCategory::Message, String::from("Disable_error_reporting_for_unreachable_code_6603"), String::from("Disable error reporting for unreachable code."), None, None, None) }
    pub fn disable_error_reporting_for_unused_labels() -> DiagnosticMessage { diag(6604, DiagnosticCategory::Message, String::from("Disable_error_reporting_for_unused_labels_6604"), String::from("Disable error reporting for unused labels."), None, None, None) }
    pub fn ensure_use_strict_is_always_emitted() -> DiagnosticMessage { diag(6605, DiagnosticCategory::Message, String::from("Ensure_use_strict_is_always_emitted_6605"), String::from("Ensure 'use strict' is always emitted."), None, None, None) }
    pub fn have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it() -> DiagnosticMessage { diag(6606, DiagnosticCategory::Message, String::from("Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_wi_6606"), String::from("Have recompiles in projects that use 'incremental' and 'watch' mode assume that changes within a file will only affect files directly depending on it."), None, None, None) }
    pub fn specify_the_base_directory_to_resolve_non_relative_module_names() -> DiagnosticMessage { diag(6607, DiagnosticCategory::Message, String::from("Specify_the_base_directory_to_resolve_non_relative_module_names_6607"), String::from("Specify the base directory to resolve non-relative module names."), None, None, None) }
    pub fn no_longer_supported_in_early_versions_manually_set_the_text_encoding_for_reading_files() -> DiagnosticMessage { diag(6608, DiagnosticCategory::Message, String::from("No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files_6608"), String::from("No longer supported. In early versions, manually set the text encoding for reading files."), None, None, None) }
    pub fn enable_error_reporting_in_type_checked_javascript_files() -> DiagnosticMessage { diag(6609, DiagnosticCategory::Message, String::from("Enable_error_reporting_in_type_checked_JavaScript_files_6609"), String::from("Enable error reporting in type-checked JavaScript files."), None, None, None) }
    pub fn enable_constraints_that_allow_a_typescript_project_to_be_used_with_project_references() -> DiagnosticMessage { diag(6611, DiagnosticCategory::Message, String::from("Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references_6611"), String::from("Enable constraints that allow a TypeScript project to be used with project references."), None, None, None) }
    pub fn generate_d_ts_files_from_typescript_and_javascript_files_in_your_project() -> DiagnosticMessage { diag(6612, DiagnosticCategory::Message, String::from("Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project_6612"), String::from("Generate .d.ts files from TypeScript and JavaScript files in your project."), None, None, None) }
    pub fn specify_the_output_directory_for_generated_declaration_files() -> DiagnosticMessage { diag(6613, DiagnosticCategory::Message, String::from("Specify_the_output_directory_for_generated_declaration_files_6613"), String::from("Specify the output directory for generated declaration files."), None, None, None) }
    pub fn create_sourcemaps_for_d_ts_files() -> DiagnosticMessage { diag(6614, DiagnosticCategory::Message, String::from("Create_sourcemaps_for_d_ts_files_6614"), String::from("Create sourcemaps for d.ts files."), None, None, None) }
    pub fn output_compiler_performance_information_after_building() -> DiagnosticMessage { diag(6615, DiagnosticCategory::Message, String::from("Output_compiler_performance_information_after_building_6615"), String::from("Output compiler performance information after building."), None, None, None) }
    pub fn disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project() -> DiagnosticMessage { diag(6616, DiagnosticCategory::Message, String::from("Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project_6616"), String::from("Disables inference for type acquisition by looking at filenames in a project."), None, None, None) }
    pub fn reduce_the_number_of_projects_loaded_automatically_by_typescript() -> DiagnosticMessage { diag(6617, DiagnosticCategory::Message, String::from("Reduce_the_number_of_projects_loaded_automatically_by_TypeScript_6617"), String::from("Reduce the number of projects loaded automatically by TypeScript."), None, None, None) }
    pub fn remove_the_20mb_cap_on_total_source_code_size_for_javascript_files_in_the_typescript_language_server() -> DiagnosticMessage { diag(6618, DiagnosticCategory::Message, String::from("Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server_6618"), String::from("Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server."), None, None, None) }
    pub fn opt_a_project_out_of_multi_project_reference_checking_when_editing() -> DiagnosticMessage { diag(6619, DiagnosticCategory::Message, String::from("Opt_a_project_out_of_multi_project_reference_checking_when_editing_6619"), String::from("Opt a project out of multi-project reference checking when editing."), None, None, None) }
    pub fn disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects() -> DiagnosticMessage { diag(6620, DiagnosticCategory::Message, String::from("Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects_6620"), String::from("Disable preferring source files instead of declaration files when referencing composite projects."), None, None, None) }
    pub fn emit_more_compliant_but_verbose_and_less_performant_javascript_for_iteration() -> DiagnosticMessage { diag(6621, DiagnosticCategory::Message, String::from("Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration_6621"), String::from("Emit more compliant, but verbose and less performant JavaScript for iteration."), None, None, None) }
    pub fn emit_a_utf_8_byte_order_mark_bom_in_the_beginning_of_output_files() -> DiagnosticMessage { diag(6622, DiagnosticCategory::Message, String::from("Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6622"), String::from("Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."), None, None, None) }
    pub fn only_output_d_ts_files_and_not_javascript_files() -> DiagnosticMessage { diag(6623, DiagnosticCategory::Message, String::from("Only_output_d_ts_files_and_not_JavaScript_files_6623"), String::from("Only output d.ts files and not JavaScript files."), None, None, None) }
    pub fn emit_design_type_metadata_for_decorated_declarations_in_source_files() -> DiagnosticMessage { diag(6624, DiagnosticCategory::Message, String::from("Emit_design_type_metadata_for_decorated_declarations_in_source_files_6624"), String::from("Emit design-type metadata for decorated declarations in source files."), None, None, None) }
    pub fn disable_the_type_acquisition_for_javascript_projects() -> DiagnosticMessage { diag(6625, DiagnosticCategory::Message, String::from("Disable_the_type_acquisition_for_JavaScript_projects_6625"), String::from("Disable the type acquisition for JavaScript projects"), None, None, None) }
    pub fn emit_additional_javascript_to_ease_support_for_importing_commonjs_modules_this_enables_allowsyntheticdefaultimports_for_type_compatibility() -> DiagnosticMessage { diag(6626, DiagnosticCategory::Message, String::from("Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheti_6626"), String::from("Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility."), None, None, None) }
    pub fn filters_results_from_the_include_option() -> DiagnosticMessage { diag(6627, DiagnosticCategory::Message, String::from("Filters_results_from_the_include_option_6627"), String::from("Filters results from the `include` option."), None, None, None) }
    pub fn remove_a_list_of_directories_from_the_watch_process() -> DiagnosticMessage { diag(6628, DiagnosticCategory::Message, String::from("Remove_a_list_of_directories_from_the_watch_process_6628"), String::from("Remove a list of directories from the watch process."), None, None, None) }
    pub fn remove_a_list_of_files_from_the_watch_mode_s_processing() -> DiagnosticMessage { diag(6629, DiagnosticCategory::Message, String::from("Remove_a_list_of_files_from_the_watch_mode_s_processing_6629"), String::from("Remove a list of files from the watch mode's processing."), None, None, None) }
    pub fn enable_experimental_support_for_legacy_experimental_decorators() -> DiagnosticMessage { diag(6630, DiagnosticCategory::Message, String::from("Enable_experimental_support_for_legacy_experimental_decorators_6630"), String::from("Enable experimental support for legacy experimental decorators."), None, None, None) }
    pub fn print_files_read_during_the_compilation_including_why_it_was_included() -> DiagnosticMessage { diag(6631, DiagnosticCategory::Message, String::from("Print_files_read_during_the_compilation_including_why_it_was_included_6631"), String::from("Print files read during the compilation including why it was included."), None, None, None) }
    pub fn output_more_detailed_compiler_performance_information_after_building() -> DiagnosticMessage { diag(6632, DiagnosticCategory::Message, String::from("Output_more_detailed_compiler_performance_information_after_building_6632"), String::from("Output more detailed compiler performance information after building."), None, None, None) }
    pub fn specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_are_inherited() -> DiagnosticMessage { diag(6633, DiagnosticCategory::Message, String::from("Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_a_6633"), String::from("Specify one or more path or node module references to base configuration files from which settings are inherited."), None, None, None) }
    pub fn specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers() -> DiagnosticMessage { diag(6634, DiagnosticCategory::Message, String::from("Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers_6634"), String::from("Specify what approach the watcher should use if the system runs out of native file watchers."), None, None, None) }
    pub fn include_a_list_of_files_this_does_not_support_glob_patterns_as_opposed_to_include() -> DiagnosticMessage { diag(6635, DiagnosticCategory::Message, String::from("Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include_6635"), String::from("Include a list of files. This does not support glob patterns, as opposed to `include`."), None, None, None) }
    pub fn build_all_projects_including_those_that_appear_to_be_up_to_date() -> DiagnosticMessage { diag(6636, DiagnosticCategory::Message, String::from("Build_all_projects_including_those_that_appear_to_be_up_to_date_6636"), String::from("Build all projects, including those that appear to be up to date."), None, None, None) }
    pub fn ensure_that_casing_is_correct_in_imports() -> DiagnosticMessage { diag(6637, DiagnosticCategory::Message, String::from("Ensure_that_casing_is_correct_in_imports_6637"), String::from("Ensure that casing is correct in imports."), None, None, None) }
    pub fn emit_a_v8_cpu_profile_of_the_compiler_run_for_debugging() -> DiagnosticMessage { diag(6638, DiagnosticCategory::Message, String::from("Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging_6638"), String::from("Emit a v8 CPU profile of the compiler run for debugging."), None, None, None) }
    pub fn allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file() -> DiagnosticMessage { diag(6639, DiagnosticCategory::Message, String::from("Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file_6639"), String::from("Allow importing helper functions from tslib once per project, instead of including them per-file."), None, None, None) }
    pub fn skip_building_downstream_projects_on_error_in_upstream_project() -> DiagnosticMessage { diag(6640, DiagnosticCategory::Message, String::from("Skip_building_downstream_projects_on_error_in_upstream_project_6640"), String::from("Skip building downstream projects on error in upstream project."), None, None, None) }
    pub fn specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation() -> DiagnosticMessage { diag(6641, DiagnosticCategory::Message, String::from("Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation_6641"), String::from("Specify a list of glob patterns that match files to be included in compilation."), None, None, None) }
    pub fn save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects() -> DiagnosticMessage { diag(6642, DiagnosticCategory::Message, String::from("Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects_6642"), String::from("Save .tsbuildinfo files to allow for incremental compilation of projects."), None, None, None) }
    pub fn include_sourcemap_files_inside_the_emitted_javascript() -> DiagnosticMessage { diag(6643, DiagnosticCategory::Message, String::from("Include_sourcemap_files_inside_the_emitted_JavaScript_6643"), String::from("Include sourcemap files inside the emitted JavaScript."), None, None, None) }
    pub fn include_source_code_in_the_sourcemaps_inside_the_emitted_javascript() -> DiagnosticMessage { diag(6644, DiagnosticCategory::Message, String::from("Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript_6644"), String::from("Include source code in the sourcemaps inside the emitted JavaScript."), None, None, None) }
    pub fn ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports() -> DiagnosticMessage { diag(6645, DiagnosticCategory::Message, String::from("Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports_6645"), String::from("Ensure that each file can be safely transpiled without relying on other imports."), None, None, None) }
    pub fn specify_what_jsx_code_is_generated() -> DiagnosticMessage { diag(6646, DiagnosticCategory::Message, String::from("Specify_what_JSX_code_is_generated_6646"), String::from("Specify what JSX code is generated."), None, None, None) }
    pub fn specify_the_jsx_factory_function_used_when_targeting_react_jsx_emit_e_g_react_createelement_or_h() -> DiagnosticMessage { diag(6647, DiagnosticCategory::Message, String::from("Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h_6647"), String::from("Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'."), None, None, None) }
    pub fn specify_the_jsx_fragment_reference_used_for_fragments_when_targeting_react_jsx_emit_e_g_react_fragment_or_fragment() -> DiagnosticMessage { diag(6648, DiagnosticCategory::Message, String::from("Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragme_6648"), String::from("Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'."), None, None, None) }
    pub fn specify_module_specifier_used_to_import_the_jsx_factory_functions_when_using_jsx_colon_react_jsx_asterisk() -> DiagnosticMessage { diag(6649, DiagnosticCategory::Message, String::from("Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_colon_react_jsx_ast_6649"), String::from("Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'."), None, None, None) }
    pub fn make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_legacy_option() -> DiagnosticMessage { diag(6650, DiagnosticCategory::Message, String::from("Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option_6650"), String::from("Make keyof only return strings instead of string, numbers or symbols. Legacy option."), None, None, None) }
    pub fn specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment() -> DiagnosticMessage { diag(6651, DiagnosticCategory::Message, String::from("Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment_6651"), String::from("Specify a set of bundled library declaration files that describe the target runtime environment."), None, None, None) }
    pub fn print_the_names_of_emitted_files_after_a_compilation() -> DiagnosticMessage { diag(6652, DiagnosticCategory::Message, String::from("Print_the_names_of_emitted_files_after_a_compilation_6652"), String::from("Print the names of emitted files after a compilation."), None, None, None) }
    pub fn print_all_of_the_files_read_during_the_compilation() -> DiagnosticMessage { diag(6653, DiagnosticCategory::Message, String::from("Print_all_of_the_files_read_during_the_compilation_6653"), String::from("Print all of the files read during the compilation."), None, None, None) }
    pub fn set_the_language_of_the_messaging_from_typescript_this_does_not_affect_emit() -> DiagnosticMessage { diag(6654, DiagnosticCategory::Message, String::from("Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit_6654"), String::from("Set the language of the messaging from TypeScript. This does not affect emit."), None, None, None) }
    pub fn specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations() -> DiagnosticMessage { diag(6655, DiagnosticCategory::Message, String::from("Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6655"), String::from("Specify the location where debugger should locate map files instead of generated locations."), None, None, None) }
    pub fn specify_the_maximum_folder_depth_used_for_checking_javascript_files_from_node_modules_only_applicable_with_allowjs() -> DiagnosticMessage { diag(6656, DiagnosticCategory::Message, String::from("Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicabl_6656"), String::from("Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'."), None, None, None) }
    pub fn specify_what_module_code_is_generated() -> DiagnosticMessage { diag(6657, DiagnosticCategory::Message, String::from("Specify_what_module_code_is_generated_6657"), String::from("Specify what module code is generated."), None, None, None) }
    pub fn specify_how_typescript_looks_up_a_file_from_a_given_module_specifier() -> DiagnosticMessage { diag(6658, DiagnosticCategory::Message, String::from("Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier_6658"), String::from("Specify how TypeScript looks up a file from a given module specifier."), None, None, None) }
    pub fn set_the_newline_character_for_emitting_files() -> DiagnosticMessage { diag(6659, DiagnosticCategory::Message, String::from("Set_the_newline_character_for_emitting_files_6659"), String::from("Set the newline character for emitting files."), None, None, None) }
    pub fn disable_emitting_files_from_a_compilation() -> DiagnosticMessage { diag(6660, DiagnosticCategory::Message, String::from("Disable_emitting_files_from_a_compilation_6660"), String::from("Disable emitting files from a compilation."), None, None, None) }
    pub fn disable_generating_custom_helper_functions_like_extends_in_compiled_output() -> DiagnosticMessage { diag(6661, DiagnosticCategory::Message, String::from("Disable_generating_custom_helper_functions_like_extends_in_compiled_output_6661"), String::from("Disable generating custom helper functions like '__extends' in compiled output."), None, None, None) }
    pub fn disable_emitting_files_if_any_type_checking_errors_are_reported() -> DiagnosticMessage { diag(6662, DiagnosticCategory::Message, String::from("Disable_emitting_files_if_any_type_checking_errors_are_reported_6662"), String::from("Disable emitting files if any type checking errors are reported."), None, None, None) }
    pub fn disable_truncating_types_in_error_messages() -> DiagnosticMessage { diag(6663, DiagnosticCategory::Message, String::from("Disable_truncating_types_in_error_messages_6663"), String::from("Disable truncating types in error messages."), None, None, None) }
    pub fn enable_error_reporting_for_fallthrough_cases_in_switch_statements() -> DiagnosticMessage { diag(6664, DiagnosticCategory::Message, String::from("Enable_error_reporting_for_fallthrough_cases_in_switch_statements_6664"), String::from("Enable error reporting for fallthrough cases in switch statements."), None, None, None) }
    pub fn enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type() -> DiagnosticMessage { diag(6665, DiagnosticCategory::Message, String::from("Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type_6665"), String::from("Enable error reporting for expressions and declarations with an implied 'any' type."), None, None, None) }
    pub fn ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier() -> DiagnosticMessage { diag(6666, DiagnosticCategory::Message, String::from("Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier_6666"), String::from("Ensure overriding members in derived classes are marked with an override modifier."), None, None, None) }
    pub fn enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function() -> DiagnosticMessage { diag(6667, DiagnosticCategory::Message, String::from("Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function_6667"), String::from("Enable error reporting for codepaths that do not explicitly return in a function."), None, None, None) }
    pub fn enable_error_reporting_when_this_is_given_the_type_any() -> DiagnosticMessage { diag(6668, DiagnosticCategory::Message, String::from("Enable_error_reporting_when_this_is_given_the_type_any_6668"), String::from("Enable error reporting when 'this' is given the type 'any'."), None, None, None) }
    pub fn disable_adding_use_strict_directives_in_emitted_javascript_files() -> DiagnosticMessage { diag(6669, DiagnosticCategory::Message, String::from("Disable_adding_use_strict_directives_in_emitted_JavaScript_files_6669"), String::from("Disable adding 'use strict' directives in emitted JavaScript files."), None, None, None) }
    pub fn disable_including_any_library_files_including_the_default_lib_d_ts() -> DiagnosticMessage { diag(6670, DiagnosticCategory::Message, String::from("Disable_including_any_library_files_including_the_default_lib_d_ts_6670"), String::from("Disable including any library files, including the default lib.d.ts."), None, None, None) }
    pub fn enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type() -> DiagnosticMessage { diag(6671, DiagnosticCategory::Message, String::from("Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type_6671"), String::from("Enforces using indexed accessors for keys declared using an indexed type."), None, None, None) }
    pub fn disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_typescript_should_add_to_a_project() -> DiagnosticMessage { diag(6672, DiagnosticCategory::Message, String::from("Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add__6672"), String::from("Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project."), None, None, None) }
    pub fn disable_strict_checking_of_generic_signatures_in_function_types() -> DiagnosticMessage { diag(6673, DiagnosticCategory::Message, String::from("Disable_strict_checking_of_generic_signatures_in_function_types_6673"), String::from("Disable strict checking of generic signatures in function types."), None, None, None) }
    pub fn add_undefined_to_a_type_when_accessed_using_an_index() -> DiagnosticMessage { diag(6674, DiagnosticCategory::Message, String::from("Add_undefined_to_a_type_when_accessed_using_an_index_6674"), String::from("Add 'undefined' to a type when accessed using an index."), None, None, None) }
    pub fn enable_error_reporting_when_local_variables_aren_t_read() -> DiagnosticMessage { diag(6675, DiagnosticCategory::Message, String::from("Enable_error_reporting_when_local_variables_aren_t_read_6675"), String::from("Enable error reporting when local variables aren't read."), None, None, None) }
    pub fn raise_an_error_when_a_function_parameter_isn_t_read() -> DiagnosticMessage { diag(6676, DiagnosticCategory::Message, String::from("Raise_an_error_when_a_function_parameter_isn_t_read_6676"), String::from("Raise an error when a function parameter isn't read."), None, None, None) }
    pub fn deprecated_setting_use_outfile_instead() -> DiagnosticMessage { diag(6677, DiagnosticCategory::Message, String::from("Deprecated_setting_Use_outFile_instead_6677"), String::from("Deprecated setting. Use 'outFile' instead."), None, None, None) }
    pub fn specify_an_output_folder_for_all_emitted_files() -> DiagnosticMessage { diag(6678, DiagnosticCategory::Message, String::from("Specify_an_output_folder_for_all_emitted_files_6678"), String::from("Specify an output folder for all emitted files."), None, None, None) }
    pub fn specify_a_file_that_bundles_all_outputs_into_one_javascript_file_if_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output() -> DiagnosticMessage { diag(6679, DiagnosticCategory::Message, String::from("Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designa_6679"), String::from("Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output."), None, None, None) }
    pub fn specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations() -> DiagnosticMessage { diag(6680, DiagnosticCategory::Message, String::from("Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations_6680"), String::from("Specify a set of entries that re-map imports to additional lookup locations."), None, None, None) }
    pub fn specify_a_list_of_language_service_plugins_to_include() -> DiagnosticMessage { diag(6681, DiagnosticCategory::Message, String::from("Specify_a_list_of_language_service_plugins_to_include_6681"), String::from("Specify a list of language service plugins to include."), None, None, None) }
    pub fn disable_erasing_const_enum_declarations_in_generated_code() -> DiagnosticMessage { diag(6682, DiagnosticCategory::Message, String::from("Disable_erasing_const_enum_declarations_in_generated_code_6682"), String::from("Disable erasing 'const enum' declarations in generated code."), None, None, None) }
    pub fn disable_resolving_symlinks_to_their_realpath_this_correlates_to_the_same_flag_in_node() -> DiagnosticMessage { diag(6683, DiagnosticCategory::Message, String::from("Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node_6683"), String::from("Disable resolving symlinks to their realpath. This correlates to the same flag in node."), None, None, None) }
    pub fn disable_wiping_the_console_in_watch_mode() -> DiagnosticMessage { diag(6684, DiagnosticCategory::Message, String::from("Disable_wiping_the_console_in_watch_mode_6684"), String::from("Disable wiping the console in watch mode."), None, None, None) }
    pub fn enable_color_and_formatting_in_typescript_s_output_to_make_compiler_errors_easier_to_read() -> DiagnosticMessage { diag(6685, DiagnosticCategory::Message, String::from("Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read_6685"), String::from("Enable color and formatting in TypeScript's output to make compiler errors easier to read."), None, None, None) }
    pub fn specify_the_object_invoked_for_createelement_this_only_applies_when_targeting_react_jsx_emit() -> DiagnosticMessage { diag(6686, DiagnosticCategory::Message, String::from("Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit_6686"), String::from("Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit."), None, None, None) }
    pub fn specify_an_array_of_objects_that_specify_paths_for_projects_used_in_project_references() -> DiagnosticMessage { diag(6687, DiagnosticCategory::Message, String::from("Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references_6687"), String::from("Specify an array of objects that specify paths for projects. Used in project references."), None, None, None) }
    pub fn disable_emitting_comments() -> DiagnosticMessage { diag(6688, DiagnosticCategory::Message, String::from("Disable_emitting_comments_6688"), String::from("Disable emitting comments."), None, None, None) }
    pub fn enable_importing_json_files() -> DiagnosticMessage { diag(6689, DiagnosticCategory::Message, String::from("Enable_importing_json_files_6689"), String::from("Enable importing .json files."), None, None, None) }
    pub fn specify_the_root_folder_within_your_source_files() -> DiagnosticMessage { diag(6690, DiagnosticCategory::Message, String::from("Specify_the_root_folder_within_your_source_files_6690"), String::from("Specify the root folder within your source files."), None, None, None) }
    pub fn allow_multiple_folders_to_be_treated_as_one_when_resolving_modules() -> DiagnosticMessage { diag(6691, DiagnosticCategory::Message, String::from("Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules_6691"), String::from("Allow multiple folders to be treated as one when resolving modules."), None, None, None) }
    pub fn skip_type_checking_d_ts_files_that_are_included_with_typescript() -> DiagnosticMessage { diag(6692, DiagnosticCategory::Message, String::from("Skip_type_checking_d_ts_files_that_are_included_with_TypeScript_6692"), String::from("Skip type checking .d.ts files that are included with TypeScript."), None, None, None) }
    pub fn skip_type_checking_all_d_ts_files() -> DiagnosticMessage { diag(6693, DiagnosticCategory::Message, String::from("Skip_type_checking_all_d_ts_files_6693"), String::from("Skip type checking all .d.ts files."), None, None, None) }
    pub fn create_source_map_files_for_emitted_javascript_files() -> DiagnosticMessage { diag(6694, DiagnosticCategory::Message, String::from("Create_source_map_files_for_emitted_JavaScript_files_6694"), String::from("Create source map files for emitted JavaScript files."), None, None, None) }
    pub fn specify_the_root_path_for_debuggers_to_find_the_reference_source_code() -> DiagnosticMessage { diag(6695, DiagnosticCategory::Message, String::from("Specify_the_root_path_for_debuggers_to_find_the_reference_source_code_6695"), String::from("Specify the root path for debuggers to find the reference source code."), None, None, None) }
    pub fn check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function() -> DiagnosticMessage { diag(6697, DiagnosticCategory::Message, String::from("Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function_6697"), String::from("Check that the arguments for 'bind', 'call', and 'apply' methods match the original function."), None, None, None) }
    pub fn when_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible() -> DiagnosticMessage { diag(6698, DiagnosticCategory::Message, String::from("When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible_6698"), String::from("When assigning functions, check to ensure parameters and the return values are subtype-compatible."), None, None, None) }
    pub fn when_type_checking_take_into_account_null_and_undefined() -> DiagnosticMessage { diag(6699, DiagnosticCategory::Message, String::from("When_type_checking_take_into_account_null_and_undefined_6699"), String::from("When type checking, take into account 'null' and 'undefined'."), None, None, None) }
    pub fn check_for_class_properties_that_are_declared_but_not_set_in_the_constructor() -> DiagnosticMessage { diag(6700, DiagnosticCategory::Message, String::from("Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor_6700"), String::from("Check for class properties that are declared but not set in the constructor."), None, None, None) }
    pub fn disable_emitting_declarations_that_have_internal_in_their_jsdoc_comments() -> DiagnosticMessage { diag(6701, DiagnosticCategory::Message, String::from("Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments_6701"), String::from("Disable emitting declarations that have '@internal' in their JSDoc comments."), None, None, None) }
    pub fn disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals() -> DiagnosticMessage { diag(6702, DiagnosticCategory::Message, String::from("Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals_6702"), String::from("Disable reporting of excess property errors during the creation of object literals."), None, None, None) }
    pub fn suppress_noimplicitany_errors_when_indexing_objects_that_lack_index_signatures() -> DiagnosticMessage { diag(6703, DiagnosticCategory::Message, String::from("Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures_6703"), String::from("Suppress 'noImplicitAny' errors when indexing objects that lack index signatures."), None, None, None) }
    pub fn synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively() -> DiagnosticMessage { diag(6704, DiagnosticCategory::Message, String::from("Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_supp_6704"), String::from("Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively."), None, None, None) }
    pub fn set_the_javascript_language_version_for_emitted_javascript_and_include_compatible_library_declarations() -> DiagnosticMessage { diag(6705, DiagnosticCategory::Message, String::from("Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declaratio_6705"), String::from("Set the JavaScript language version for emitted JavaScript and include compatible library declarations."), None, None, None) }
    pub fn log_paths_used_during_the_moduleresolution_process() -> DiagnosticMessage { diag(6706, DiagnosticCategory::Message, String::from("Log_paths_used_during_the_moduleResolution_process_6706"), String::from("Log paths used during the 'moduleResolution' process."), None, None, None) }
    pub fn specify_the_path_to_tsbuildinfo_incremental_compilation_file() -> DiagnosticMessage { diag(6707, DiagnosticCategory::Message, String::from("Specify_the_path_to_tsbuildinfo_incremental_compilation_file_6707"), String::from("Specify the path to .tsbuildinfo incremental compilation file."), None, None, None) }
    pub fn specify_options_for_automatic_acquisition_of_declaration_files() -> DiagnosticMessage { diag(6709, DiagnosticCategory::Message, String::from("Specify_options_for_automatic_acquisition_of_declaration_files_6709"), String::from("Specify options for automatic acquisition of declaration files."), None, None, None) }
    pub fn specify_multiple_folders_that_act_like_slashnode_modules_slash_types() -> DiagnosticMessage { diag(6710, DiagnosticCategory::Message, String::from("Specify_multiple_folders_that_act_like_slashnode_modules_slash_types_6710"), String::from("Specify multiple folders that act like './node_modules/@types'."), None, None, None) }
    pub fn specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file() -> DiagnosticMessage { diag(6711, DiagnosticCategory::Message, String::from("Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file_6711"), String::from("Specify type package names to be included without being referenced in a source file."), None, None, None) }
    pub fn emit_ecmascript_standard_compliant_class_fields() -> DiagnosticMessage { diag(6712, DiagnosticCategory::Message, String::from("Emit_ECMAScript_standard_compliant_class_fields_6712"), String::from("Emit ECMAScript-standard-compliant class fields."), None, None, None) }
    pub fn enable_verbose_logging() -> DiagnosticMessage { diag(6713, DiagnosticCategory::Message, String::from("Enable_verbose_logging_6713"), String::from("Enable verbose logging."), None, None, None) }
    pub fn specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality() -> DiagnosticMessage { diag(6714, DiagnosticCategory::Message, String::from("Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality_6714"), String::from("Specify how directories are watched on systems that lack recursive file-watching functionality."), None, None, None) }
    pub fn specify_how_the_typescript_watch_mode_works() -> DiagnosticMessage { diag(6715, DiagnosticCategory::Message, String::from("Specify_how_the_TypeScript_watch_mode_works_6715"), String::from("Specify how the TypeScript watch mode works."), None, None, None) }
    pub fn require_undeclared_properties_from_index_signatures_to_use_element_accesses() -> DiagnosticMessage { diag(6717, DiagnosticCategory::Message, String::from("Require_undeclared_properties_from_index_signatures_to_use_element_accesses_6717"), String::from("Require undeclared properties from index signatures to use element accesses."), None, None, None) }
    pub fn specify_emit_slashchecking_behavior_for_imports_that_are_only_used_for_types() -> DiagnosticMessage { diag(6718, DiagnosticCategory::Message, String::from("Specify_emit_slashchecking_behavior_for_imports_that_are_only_used_for_types_6718"), String::from("Specify emit/checking behavior for imports that are only used for types."), None, None, None) }
    pub fn require_sufficient_annotation_on_exports_so_other_tools_can_trivially_generate_declaration_files() -> DiagnosticMessage { diag(6719, DiagnosticCategory::Message, String::from("Require_sufficient_annotation_on_exports_so_other_tools_can_trivially_generate_declaration_files_6719"), String::from("Require sufficient annotation on exports so other tools can trivially generate declaration files."), None, None, None) }
    pub fn built_in_iterators_are_instantiated_with_a_treturn_type_of_undefined_instead_of_any() -> DiagnosticMessage { diag(6720, DiagnosticCategory::Message, String::from("Built_in_iterators_are_instantiated_with_a_TReturn_type_of_undefined_instead_of_any_6720"), String::from("Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'."), None, None, None) }
    pub fn default_catch_clause_variables_as_unknown_instead_of_any() -> DiagnosticMessage { diag(6803, DiagnosticCategory::Message, String::from("Default_catch_clause_variables_as_unknown_instead_of_any_6803"), String::from("Default catch clause variables as 'unknown' instead of 'any'."), None, None, None) }
    pub fn do_not_transform_or_elide_any_imports_or_exports_not_marked_as_type_only_ensuring_they_are_written_in_the_output_file_s_format_based_on_the_module_setting() -> DiagnosticMessage { diag(6804, DiagnosticCategory::Message, String::from("Do_not_transform_or_elide_any_imports_or_exports_not_marked_as_type_only_ensuring_they_are_written_i_6804"), String::from("Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting."), None, None, None) }
    pub fn disable_full_type_checking_only_critical_parse_and_emit_errors_will_be_reported() -> DiagnosticMessage { diag(6805, DiagnosticCategory::Message, String::from("Disable_full_type_checking_only_critical_parse_and_emit_errors_will_be_reported_6805"), String::from("Disable full type checking (only critical parse and emit errors will be reported)."), None, None, None) }
    pub fn check_side_effect_imports() -> DiagnosticMessage { diag(6806, DiagnosticCategory::Message, String::from("Check_side_effect_imports_6806"), String::from("Check side effect imports."), None, None, None) }
    pub fn this_operation_can_be_simplified_this_shift_is_identical_to_0_1_2() -> DiagnosticMessage { diag(6807, DiagnosticCategory::Error, String::from("This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2_6807"), String::from("This operation can be simplified. This shift is identical to `{0} {1} {2}`."), None, None, None) }
    pub fn one_of_colon() -> DiagnosticMessage { diag(6900, DiagnosticCategory::Message, String::from("one_of_colon_6900"), String::from("one of:"), None, None, None) }
    pub fn one_or_more_colon() -> DiagnosticMessage { diag(6901, DiagnosticCategory::Message, String::from("one_or_more_colon_6901"), String::from("one or more:"), None, None, None) }
    pub fn type_colon() -> DiagnosticMessage { diag(6902, DiagnosticCategory::Message, String::from("type_colon_6902"), String::from("type:"), None, None, None) }
    pub fn default_colon() -> DiagnosticMessage { diag(6903, DiagnosticCategory::Message, String::from("default_colon_6903"), String::from("default:"), None, None, None) }
    pub fn module_system_or_esmoduleinterop() -> DiagnosticMessage { diag(6904, DiagnosticCategory::Message, String::from("module_system_or_esModuleInterop_6904"), String::from("module === \"system\" or esModuleInterop"), None, None, None) }
    pub fn false_unless_strict_is_set() -> DiagnosticMessage { diag(6905, DiagnosticCategory::Message, String::from("false_unless_strict_is_set_6905"), String::from("`false`, unless `strict` is set"), None, None, None) }
    pub fn false_unless_composite_is_set() -> DiagnosticMessage { diag(6906, DiagnosticCategory::Message, String::from("false_unless_composite_is_set_6906"), String::from("`false`, unless `composite` is set"), None, None, None) }
    pub fn node_modules_bower_components_jspm_packages_plus_the_value_of_outdir_if_one_is_specified() -> DiagnosticMessage { diag(6907, DiagnosticCategory::Message, String::from("node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified_6907"), String::from("`[\"node_modules\", \"bower_components\", \"jspm_packages\"]`, plus the value of `outDir` if one is specified."), None, None, None) }
    pub fn if_files_is_specified_otherwise_asterisk_asterisk_slash_asterisk() -> DiagnosticMessage { diag(6908, DiagnosticCategory::Message, String::from("if_files_is_specified_otherwise_asterisk_asterisk_slash_asterisk_6908"), String::from("`[]` if `files` is specified, otherwise `[\"**/*\"]`"), None, None, None) }
    pub fn true_if_composite_false_otherwise() -> DiagnosticMessage { diag(6909, DiagnosticCategory::Message, String::from("true_if_composite_false_otherwise_6909"), String::from("`true` if `composite`, `false` otherwise"), None, None, None) }
    pub fn module_amd_or_umd_or_system_or_es6_then_classic_otherwise_node() -> DiagnosticMessage { diag(69010, DiagnosticCategory::Message, String::from("module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node_69010"), String::from("module === `AMD` or `UMD` or `System` or `ES6`, then `Classic`, Otherwise `Node`"), None, None, None) }
    pub fn computed_from_the_list_of_input_files() -> DiagnosticMessage { diag(6911, DiagnosticCategory::Message, String::from("Computed_from_the_list_of_input_files_6911"), String::from("Computed from the list of input files"), None, None, None) }
    pub fn platform_specific() -> DiagnosticMessage { diag(6912, DiagnosticCategory::Message, String::from("Platform_specific_6912"), String::from("Platform specific"), None, None, None) }
    pub fn you_can_learn_about_all_of_the_compiler_options_at_0() -> DiagnosticMessage { diag(6913, DiagnosticCategory::Message, String::from("You_can_learn_about_all_of_the_compiler_options_at_0_6913"), String::from("You can learn about all of the compiler options at {0}"), None, None, None) }
    pub fn including_watch_w_will_start_watching_the_current_project_for_the_file_changes_once_set_you_can_config_watch_mode_with_colon() -> DiagnosticMessage { diag(6914, DiagnosticCategory::Message, String::from("Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_conf_6914"), String::from("Including --watch, -w will start watching the current project for the file changes. Once set, you can config watch mode with:"), None, None, None) }
    pub fn using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_this_is_used_to_trigger_building_composite_projects_which_you_can_learn_more_about_at_0() -> DiagnosticMessage { diag(6915, DiagnosticCategory::Message, String::from("Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_tr_6915"), String::from("Using --build, -b will make tsc behave more like a build orchestrator than a compiler. This is used to trigger building composite projects which you can learn more about at {0}"), None, None, None) }
    pub fn common_commands() -> DiagnosticMessage { diag(6916, DiagnosticCategory::Message, String::from("COMMON_COMMANDS_6916"), String::from("COMMON COMMANDS"), None, None, None) }
    pub fn all_compiler_options() -> DiagnosticMessage { diag(6917, DiagnosticCategory::Message, String::from("ALL_COMPILER_OPTIONS_6917"), String::from("ALL COMPILER OPTIONS"), None, None, None) }
    pub fn watch_options() -> DiagnosticMessage { diag(6918, DiagnosticCategory::Message, String::from("WATCH_OPTIONS_6918"), String::from("WATCH OPTIONS"), None, None, None) }
    pub fn build_options() -> DiagnosticMessage { diag(6919, DiagnosticCategory::Message, String::from("BUILD_OPTIONS_6919"), String::from("BUILD OPTIONS"), None, None, None) }
    pub fn common_compiler_options() -> DiagnosticMessage { diag(6920, DiagnosticCategory::Message, String::from("COMMON_COMPILER_OPTIONS_6920"), String::from("COMMON COMPILER OPTIONS"), None, None, None) }
    pub fn command_line_flags() -> DiagnosticMessage { diag(6921, DiagnosticCategory::Message, String::from("COMMAND_LINE_FLAGS_6921"), String::from("COMMAND LINE FLAGS"), None, None, None) }
    pub fn tsc_colon_the_typescript_compiler() -> DiagnosticMessage { diag(6922, DiagnosticCategory::Message, String::from("tsc_colon_The_TypeScript_Compiler_6922"), String::from("tsc: The TypeScript Compiler"), None, None, None) }
    pub fn compiles_the_current_project_tsconfig_json_in_the_working_directory() -> DiagnosticMessage { diag(6923, DiagnosticCategory::Message, String::from("Compiles_the_current_project_tsconfig_json_in_the_working_directory_6923"), String::from("Compiles the current project (tsconfig.json in the working directory.)"), None, None, None) }
    pub fn ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options() -> DiagnosticMessage { diag(6924, DiagnosticCategory::Message, String::from("Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options_6924"), String::from("Ignoring tsconfig.json, compiles the specified files with default compiler options."), None, None, None) }
    pub fn build_a_composite_project_in_the_working_directory() -> DiagnosticMessage { diag(6925, DiagnosticCategory::Message, String::from("Build_a_composite_project_in_the_working_directory_6925"), String::from("Build a composite project in the working directory."), None, None, None) }
    pub fn creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory() -> DiagnosticMessage { diag(6926, DiagnosticCategory::Message, String::from("Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory_6926"), String::from("Creates a tsconfig.json with the recommended settings in the working directory."), None, None, None) }
    pub fn compiles_the_typescript_project_located_at_the_specified_path() -> DiagnosticMessage { diag(6927, DiagnosticCategory::Message, String::from("Compiles_the_TypeScript_project_located_at_the_specified_path_6927"), String::from("Compiles the TypeScript project located at the specified path."), None, None, None) }
    pub fn an_expanded_version_of_this_information_showing_all_possible_compiler_options() -> DiagnosticMessage { diag(6928, DiagnosticCategory::Message, String::from("An_expanded_version_of_this_information_showing_all_possible_compiler_options_6928"), String::from("An expanded version of this information, showing all possible compiler options"), None, None, None) }
    pub fn compiles_the_current_project_with_additional_settings() -> DiagnosticMessage { diag(6929, DiagnosticCategory::Message, String::from("Compiles_the_current_project_with_additional_settings_6929"), String::from("Compiles the current project, with additional settings."), None, None, None) }
    pub fn true_for_es2022_and_above_including_esnext() -> DiagnosticMessage { diag(6930, DiagnosticCategory::Message, String::from("true_for_ES2022_and_above_including_ESNext_6930"), String::from("`true` for ES2022 and above, including ESNext."), None, None, None) }
    pub fn list_of_file_name_suffixes_to_search_when_resolving_a_module() -> DiagnosticMessage { diag(6931, DiagnosticCategory::Error, String::from("List_of_file_name_suffixes_to_search_when_resolving_a_module_6931"), String::from("List of file name suffixes to search when resolving a module."), None, None, None) }
    pub fn variable_0_implicitly_has_an_1_type() -> DiagnosticMessage { diag(7005, DiagnosticCategory::Error, String::from("Variable_0_implicitly_has_an_1_type_7005"), String::from("Variable '{0}' implicitly has an '{1}' type."), None, None, None) }
    pub fn parameter_0_implicitly_has_an_1_type() -> DiagnosticMessage { diag(7006, DiagnosticCategory::Error, String::from("Parameter_0_implicitly_has_an_1_type_7006"), String::from("Parameter '{0}' implicitly has an '{1}' type."), None, None, None) }
    pub fn member_0_implicitly_has_an_1_type() -> DiagnosticMessage { diag(7008, DiagnosticCategory::Error, String::from("Member_0_implicitly_has_an_1_type_7008"), String::from("Member '{0}' implicitly has an '{1}' type."), None, None, None) }
    pub fn new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type() -> DiagnosticMessage { diag(7009, DiagnosticCategory::Error, String::from("new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009"), String::from("'new' expression, whose target lacks a construct signature, implicitly has an 'any' type."), None, None, None) }
    pub fn _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type() -> DiagnosticMessage { diag(7010, DiagnosticCategory::Error, String::from("_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010"), String::from("'{0}', which lacks return-type annotation, implicitly has an '{1}' return type."), None, None, None) }
    pub fn function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type() -> DiagnosticMessage { diag(7011, DiagnosticCategory::Error, String::from("Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011"), String::from("Function expression, which lacks return-type annotation, implicitly has an '{0}' return type."), None, None, None) }
    pub fn this_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation() -> DiagnosticMessage { diag(7012, DiagnosticCategory::Error, String::from("This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation_7012"), String::from("This overload implicitly returns the type '{0}' because it lacks a return type annotation."), None, None, None) }
    pub fn construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type() -> DiagnosticMessage { diag(7013, DiagnosticCategory::Error, String::from("Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013"), String::from("Construct signature, which lacks return-type annotation, implicitly has an 'any' return type."), None, None, None) }
    pub fn function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type() -> DiagnosticMessage { diag(7014, DiagnosticCategory::Error, String::from("Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7014"), String::from("Function type, which lacks return-type annotation, implicitly has an '{0}' return type."), None, None, None) }
    pub fn element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number() -> DiagnosticMessage { diag(7015, DiagnosticCategory::Error, String::from("Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015"), String::from("Element implicitly has an 'any' type because index expression is not of type 'number'."), None, None, None) }
    pub fn could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type() -> DiagnosticMessage { diag(7016, DiagnosticCategory::Error, String::from("Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016"), String::from("Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type."), None, None, None) }
    pub fn element_implicitly_has_an_any_type_because_type_0_has_no_index_signature() -> DiagnosticMessage { diag(7017, DiagnosticCategory::Error, String::from("Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017"), String::from("Element implicitly has an 'any' type because type '{0}' has no index signature."), None, None, None) }
    pub fn object_literal_s_property_0_implicitly_has_an_1_type() -> DiagnosticMessage { diag(7018, DiagnosticCategory::Error, String::from("Object_literal_s_property_0_implicitly_has_an_1_type_7018"), String::from("Object literal's property '{0}' implicitly has an '{1}' type."), None, None, None) }
    pub fn rest_parameter_0_implicitly_has_an_any_type() -> DiagnosticMessage { diag(7019, DiagnosticCategory::Error, String::from("Rest_parameter_0_implicitly_has_an_any_type_7019"), String::from("Rest parameter '{0}' implicitly has an 'any[]' type."), None, None, None) }
    pub fn call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type() -> DiagnosticMessage { diag(7020, DiagnosticCategory::Error, String::from("Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020"), String::from("Call signature, which lacks return-type annotation, implicitly has an 'any' return type."), None, None, None) }
    pub fn _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer() -> DiagnosticMessage { diag(7022, DiagnosticCategory::Error, String::from("_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022"), String::from("'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer."), None, None, None) }
    pub fn _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions() -> DiagnosticMessage { diag(7023, DiagnosticCategory::Error, String::from("_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023"), String::from("'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."), None, None, None) }
    pub fn function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions() -> DiagnosticMessage { diag(7024, DiagnosticCategory::Error, String::from("Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024"), String::from("Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."), None, None, None) }
    pub fn generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_consider_supplying_a_return_type_annotation() -> DiagnosticMessage { diag(7025, DiagnosticCategory::Error, String::from("Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_retu_7025"), String::from("Generator implicitly has yield type '{0}' because it does not yield any values. Consider supplying a return type annotation."), None, None, None) }
    pub fn jsx_element_implicitly_has_type_any_because_no_interface_jsx_0_exists() -> DiagnosticMessage { diag(7026, DiagnosticCategory::Error, String::from("JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026"), String::from("JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists."), None, None, None) }
    pub fn unreachable_code_detected() -> DiagnosticMessage { diag(7027, DiagnosticCategory::Error, String::from("Unreachable_code_detected_7027"), String::from("Unreachable code detected."), Some(true), None, None) }
    pub fn unused_label() -> DiagnosticMessage { diag(7028, DiagnosticCategory::Error, String::from("Unused_label_7028"), String::from("Unused label."), Some(true), None, None) }
    pub fn fallthrough_case_in_switch() -> DiagnosticMessage { diag(7029, DiagnosticCategory::Error, String::from("Fallthrough_case_in_switch_7029"), String::from("Fallthrough case in switch."), None, None, None) }
    pub fn not_all_code_paths_return_a_value() -> DiagnosticMessage { diag(7030, DiagnosticCategory::Error, String::from("Not_all_code_paths_return_a_value_7030"), String::from("Not all code paths return a value."), None, None, None) }
    pub fn binding_element_0_implicitly_has_an_1_type() -> DiagnosticMessage { diag(7031, DiagnosticCategory::Error, String::from("Binding_element_0_implicitly_has_an_1_type_7031"), String::from("Binding element '{0}' implicitly has an '{1}' type."), None, None, None) }
    pub fn property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation() -> DiagnosticMessage { diag(7032, DiagnosticCategory::Error, String::from("Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032"), String::from("Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation."), None, None, None) }
    pub fn property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation() -> DiagnosticMessage { diag(7033, DiagnosticCategory::Error, String::from("Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033"), String::from("Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation."), None, None, None) }
    pub fn variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined() -> DiagnosticMessage { diag(7034, DiagnosticCategory::Error, String::from("Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034"), String::from("Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined."), None, None, None) }
    pub fn try_npm_i_save_dev_types_slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0() -> DiagnosticMessage { diag(7035, DiagnosticCategory::Error, String::from("Try_npm_i_save_dev_types_slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare__7035"), String::from("Try `npm i --save-dev @types/{1}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`"), None, None, None) }
    pub fn dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0() -> DiagnosticMessage { diag(7036, DiagnosticCategory::Error, String::from("Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036"), String::from("Dynamic import's specifier must be of type 'string', but here has type '{0}'."), None, None, None) }
    pub fn enables_emit_interoperability_between_commonjs_and_es_modules_via_creation_of_namespace_objects_for_all_imports_implies_allowsyntheticdefaultimports() -> DiagnosticMessage { diag(7037, DiagnosticCategory::Message, String::from("Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for__7037"), String::from("Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'."), None, None, None) }
    pub fn type_originates_at_this_import_a_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_consider_using_a_default_import_or_import_require_here_instead() -> DiagnosticMessage { diag(7038, DiagnosticCategory::Message, String::from("Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cau_7038"), String::from("Type originates at this import. A namespace-style import cannot be called or constructed, and will cause a failure at runtime. Consider using a default import or import require here instead."), None, None, None) }
    pub fn mapped_object_type_implicitly_has_an_any_template_type() -> DiagnosticMessage { diag(7039, DiagnosticCategory::Error, String::from("Mapped_object_type_implicitly_has_an_any_template_type_7039"), String::from("Mapped object type implicitly has an 'any' template type."), None, None, None) }
    pub fn if_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_colon_slash_slashgithub_com_slashdefinitelytyped_slashdefinitelytyped_slashtree_slashmaster_slashtypes_slash_1() -> DiagnosticMessage { diag(7040, DiagnosticCategory::Error, String::from("If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_colon_s_7040"), String::from("If the '{0}' package actually exposes this module, consider sending a pull request to amend 'https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}'"), None, None, None) }
    pub fn the_containing_arrow_function_captures_the_global_value_of_this() -> DiagnosticMessage { diag(7041, DiagnosticCategory::Error, String::from("The_containing_arrow_function_captures_the_global_value_of_this_7041"), String::from("The containing arrow function captures the global value of 'this'."), None, None, None) }
    pub fn module_0_was_resolved_to_1_but_resolvejsonmodule_is_not_used() -> DiagnosticMessage { diag(7042, DiagnosticCategory::Error, String::from("Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used_7042"), String::from("Module '{0}' was resolved to '{1}', but '--resolveJsonModule' is not used."), None, None, None) }
    pub fn variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage() -> DiagnosticMessage { diag(7043, DiagnosticCategory::Suggestion, String::from("Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7043"), String::from("Variable '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), None, None, None) }
    pub fn parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage() -> DiagnosticMessage { diag(7044, DiagnosticCategory::Suggestion, String::from("Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7044"), String::from("Parameter '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), None, None, None) }
    pub fn member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage() -> DiagnosticMessage { diag(7045, DiagnosticCategory::Suggestion, String::from("Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7045"), String::from("Member '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), None, None, None) }
    pub fn variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage() -> DiagnosticMessage { diag(7046, DiagnosticCategory::Suggestion, String::from("Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage_7046"), String::from("Variable '{0}' implicitly has type '{1}' in some locations, but a better type may be inferred from usage."), None, None, None) }
    pub fn rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage() -> DiagnosticMessage { diag(7047, DiagnosticCategory::Suggestion, String::from("Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage_7047"), String::from("Rest parameter '{0}' implicitly has an 'any[]' type, but a better type may be inferred from usage."), None, None, None) }
    pub fn property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage() -> DiagnosticMessage { diag(7048, DiagnosticCategory::Suggestion, String::from("Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage_7048"), String::from("Property '{0}' implicitly has type 'any', but a better type for its get accessor may be inferred from usage."), None, None, None) }
    pub fn property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage() -> DiagnosticMessage { diag(7049, DiagnosticCategory::Suggestion, String::from("Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage_7049"), String::from("Property '{0}' implicitly has type 'any', but a better type for its set accessor may be inferred from usage."), None, None, None) }
    pub fn _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage() -> DiagnosticMessage { diag(7050, DiagnosticCategory::Suggestion, String::from("_0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage_7050"), String::from("'{0}' implicitly has an '{1}' return type, but a better type may be inferred from usage."), None, None, None) }
    pub fn parameter_has_a_name_but_no_type_did_you_mean_0_colon_1() -> DiagnosticMessage { diag(7051, DiagnosticCategory::Error, String::from("Parameter_has_a_name_but_no_type_Did_you_mean_0_colon_1_7051"), String::from("Parameter has a name but no type. Did you mean '{0}: {1}'?"), None, None, None) }
    pub fn element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_did_you_mean_to_call_1() -> DiagnosticMessage { diag(7052, DiagnosticCategory::Error, String::from("Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1_7052"), String::from("Element implicitly has an 'any' type because type '{0}' has no index signature. Did you mean to call '{1}'?"), None, None, None) }
    pub fn element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1() -> DiagnosticMessage { diag(7053, DiagnosticCategory::Error, String::from("Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1_7053"), String::from("Element implicitly has an 'any' type because expression of type '{0}' can't be used to index type '{1}'."), None, None, None) }
    pub fn no_index_signature_with_a_parameter_of_type_0_was_found_on_type_1() -> DiagnosticMessage { diag(7054, DiagnosticCategory::Error, String::from("No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1_7054"), String::from("No index signature with a parameter of type '{0}' was found on type '{1}'."), None, None, None) }
    pub fn _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type() -> DiagnosticMessage { diag(7055, DiagnosticCategory::Error, String::from("_0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type_7055"), String::from("'{0}', which lacks return-type annotation, implicitly has an '{1}' yield type."), None, None, None) }
    pub fn the_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_an_explicit_type_annotation_is_needed() -> DiagnosticMessage { diag(7056, DiagnosticCategory::Error, String::from("The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_ty_7056"), String::from("The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed."), None, None, None) }
    pub fn yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation() -> DiagnosticMessage { diag(7057, DiagnosticCategory::Error, String::from("yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_t_7057"), String::from("'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation."), None, None, None) }
    pub fn if_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1() -> DiagnosticMessage { diag(7058, DiagnosticCategory::Error, String::from("If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_decl_7058"), String::from("If the '{0}' package actually exposes this module, try adding a new declaration (.d.ts) file containing `declare module '{1}';`"), None, None, None) }
    pub fn this_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_use_an_as_expression_instead() -> DiagnosticMessage { diag(7059, DiagnosticCategory::Error, String::from("This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead_7059"), String::from("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."), None, None, None) }
    pub fn this_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_add_a_trailing_comma_or_explicit_constraint() -> DiagnosticMessage { diag(7060, DiagnosticCategory::Error, String::from("This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_cons_7060"), String::from("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma or explicit constraint."), None, None, None) }
    pub fn a_mapped_type_may_not_declare_properties_or_methods() -> DiagnosticMessage { diag(7061, DiagnosticCategory::Error, String::from("A_mapped_type_may_not_declare_properties_or_methods_7061"), String::from("A mapped type may not declare properties or methods."), None, None, None) }
    pub fn you_cannot_rename_this_element() -> DiagnosticMessage { diag(8000, DiagnosticCategory::Error, String::from("You_cannot_rename_this_element_8000"), String::from("You cannot rename this element."), None, None, None) }
    pub fn you_cannot_rename_elements_that_are_defined_in_the_standard_typescript_library() -> DiagnosticMessage { diag(8001, DiagnosticCategory::Error, String::from("You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001"), String::from("You cannot rename elements that are defined in the standard TypeScript library."), None, None, None) }
    pub fn import_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8002, DiagnosticCategory::Error, String::from("import_can_only_be_used_in_TypeScript_files_8002"), String::from("'import ... =' can only be used in TypeScript files."), None, None, None) }
    pub fn export_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8003, DiagnosticCategory::Error, String::from("export_can_only_be_used_in_TypeScript_files_8003"), String::from("'export =' can only be used in TypeScript files."), None, None, None) }
    pub fn type_parameter_declarations_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8004, DiagnosticCategory::Error, String::from("Type_parameter_declarations_can_only_be_used_in_TypeScript_files_8004"), String::from("Type parameter declarations can only be used in TypeScript files."), None, None, None) }
    pub fn implements_clauses_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8005, DiagnosticCategory::Error, String::from("implements_clauses_can_only_be_used_in_TypeScript_files_8005"), String::from("'implements' clauses can only be used in TypeScript files."), None, None, None) }
    pub fn _0_declarations_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8006, DiagnosticCategory::Error, String::from("_0_declarations_can_only_be_used_in_TypeScript_files_8006"), String::from("'{0}' declarations can only be used in TypeScript files."), None, None, None) }
    pub fn type_aliases_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8008, DiagnosticCategory::Error, String::from("Type_aliases_can_only_be_used_in_TypeScript_files_8008"), String::from("Type aliases can only be used in TypeScript files."), None, None, None) }
    pub fn the_0_modifier_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8009, DiagnosticCategory::Error, String::from("The_0_modifier_can_only_be_used_in_TypeScript_files_8009"), String::from("The '{0}' modifier can only be used in TypeScript files."), None, None, None) }
    pub fn type_annotations_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8010, DiagnosticCategory::Error, String::from("Type_annotations_can_only_be_used_in_TypeScript_files_8010"), String::from("Type annotations can only be used in TypeScript files."), None, None, None) }
    pub fn type_arguments_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8011, DiagnosticCategory::Error, String::from("Type_arguments_can_only_be_used_in_TypeScript_files_8011"), String::from("Type arguments can only be used in TypeScript files."), None, None, None) }
    pub fn parameter_modifiers_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8012, DiagnosticCategory::Error, String::from("Parameter_modifiers_can_only_be_used_in_TypeScript_files_8012"), String::from("Parameter modifiers can only be used in TypeScript files."), None, None, None) }
    pub fn non_null_assertions_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8013, DiagnosticCategory::Error, String::from("Non_null_assertions_can_only_be_used_in_TypeScript_files_8013"), String::from("Non-null assertions can only be used in TypeScript files."), None, None, None) }
    pub fn type_assertion_expressions_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8016, DiagnosticCategory::Error, String::from("Type_assertion_expressions_can_only_be_used_in_TypeScript_files_8016"), String::from("Type assertion expressions can only be used in TypeScript files."), None, None, None) }
    pub fn signature_declarations_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8017, DiagnosticCategory::Error, String::from("Signature_declarations_can_only_be_used_in_TypeScript_files_8017"), String::from("Signature declarations can only be used in TypeScript files."), None, None, None) }
    pub fn report_errors_in_js_files() -> DiagnosticMessage { diag(8019, DiagnosticCategory::Message, String::from("Report_errors_in_js_files_8019"), String::from("Report errors in .js files."), None, None, None) }
    pub fn jsdoc_types_can_only_be_used_inside_documentation_comments() -> DiagnosticMessage { diag(8020, DiagnosticCategory::Error, String::from("JSDoc_types_can_only_be_used_inside_documentation_comments_8020"), String::from("JSDoc types can only be used inside documentation comments."), None, None, None) }
    pub fn jsdoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags() -> DiagnosticMessage { diag(8021, DiagnosticCategory::Error, String::from("JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021"), String::from("JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags."), None, None, None) }
    pub fn jsdoc_0_is_not_attached_to_a_class() -> DiagnosticMessage { diag(8022, DiagnosticCategory::Error, String::from("JSDoc_0_is_not_attached_to_a_class_8022"), String::from("JSDoc '@{0}' is not attached to a class."), None, None, None) }
    pub fn jsdoc_0_1_does_not_match_the_extends_2_clause() -> DiagnosticMessage { diag(8023, DiagnosticCategory::Error, String::from("JSDoc_0_1_does_not_match_the_extends_2_clause_8023"), String::from("JSDoc '@{0} {1}' does not match the 'extends {2}' clause."), None, None, None) }
    pub fn jsdoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name() -> DiagnosticMessage { diag(8024, DiagnosticCategory::Error, String::from("JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024"), String::from("JSDoc '@param' tag has name '{0}', but there is no parameter with that name."), None, None, None) }
    pub fn class_declarations_cannot_have_more_than_one_augments_or_extends_tag() -> DiagnosticMessage { diag(8025, DiagnosticCategory::Error, String::from("Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025"), String::from("Class declarations cannot have more than one '@augments' or '@extends' tag."), None, None, None) }
    pub fn expected_0_type_arguments_provide_these_with_an_extends_tag() -> DiagnosticMessage { diag(8026, DiagnosticCategory::Error, String::from("Expected_0_type_arguments_provide_these_with_an_extends_tag_8026"), String::from("Expected {0} type arguments; provide these with an '@extends' tag."), None, None, None) }
    pub fn expected_0_1_type_arguments_provide_these_with_an_extends_tag() -> DiagnosticMessage { diag(8027, DiagnosticCategory::Error, String::from("Expected_0_1_type_arguments_provide_these_with_an_extends_tag_8027"), String::from("Expected {0}-{1} type arguments; provide these with an '@extends' tag."), None, None, None) }
    pub fn jsdoc_may_only_appear_in_the_last_parameter_of_a_signature() -> DiagnosticMessage { diag(8028, DiagnosticCategory::Error, String::from("JSDoc_may_only_appear_in_the_last_parameter_of_a_signature_8028"), String::from("JSDoc '...' may only appear in the last parameter of a signature."), None, None, None) }
    pub fn jsdoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_it_would_match_arguments_if_it_had_an_array_type() -> DiagnosticMessage { diag(8029, DiagnosticCategory::Error, String::from("JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_h_8029"), String::from("JSDoc '@param' tag has name '{0}', but there is no parameter with that name. It would match 'arguments' if it had an array type."), None, None, None) }
    pub fn the_type_of_a_function_declaration_must_match_the_function_s_signature() -> DiagnosticMessage { diag(8030, DiagnosticCategory::Error, String::from("The_type_of_a_function_declaration_must_match_the_function_s_signature_8030"), String::from("The type of a function declaration must match the function's signature."), None, None, None) }
    pub fn you_cannot_rename_a_module_via_a_global_import() -> DiagnosticMessage { diag(8031, DiagnosticCategory::Error, String::from("You_cannot_rename_a_module_via_a_global_import_8031"), String::from("You cannot rename a module via a global import."), None, None, None) }
    pub fn qualified_name_0_is_not_allowed_without_a_leading_param_object_1() -> DiagnosticMessage { diag(8032, DiagnosticCategory::Error, String::from("Qualified_name_0_is_not_allowed_without_a_leading_param_object_1_8032"), String::from("Qualified name '{0}' is not allowed without a leading '@param {object} {1}'."), None, None, None) }
    pub fn a_jsdoc_typedef_comment_may_not_contain_multiple_type_tags() -> DiagnosticMessage { diag(8033, DiagnosticCategory::Error, String::from("A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags_8033"), String::from("A JSDoc '@typedef' comment may not contain multiple '@type' tags."), None, None, None) }
    pub fn the_tag_was_first_specified_here() -> DiagnosticMessage { diag(8034, DiagnosticCategory::Error, String::from("The_tag_was_first_specified_here_8034"), String::from("The tag was first specified here."), None, None, None) }
    pub fn you_cannot_rename_elements_that_are_defined_in_a_node_modules_folder() -> DiagnosticMessage { diag(8035, DiagnosticCategory::Error, String::from("You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder_8035"), String::from("You cannot rename elements that are defined in a 'node_modules' folder."), None, None, None) }
    pub fn you_cannot_rename_elements_that_are_defined_in_another_node_modules_folder() -> DiagnosticMessage { diag(8036, DiagnosticCategory::Error, String::from("You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder_8036"), String::from("You cannot rename elements that are defined in another 'node_modules' folder."), None, None, None) }
    pub fn type_satisfaction_expressions_can_only_be_used_in_typescript_files() -> DiagnosticMessage { diag(8037, DiagnosticCategory::Error, String::from("Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files_8037"), String::from("Type satisfaction expressions can only be used in TypeScript files."), None, None, None) }
    pub fn decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export() -> DiagnosticMessage { diag(8038, DiagnosticCategory::Error, String::from("Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export_8038"), String::from("Decorators may not appear after 'export' or 'export default' if they also appear before 'export'."), None, None, None) }
    pub fn a_jsdoc_template_tag_may_not_follow_a_typedef_callback_or_overload_tag() -> DiagnosticMessage { diag(8039, DiagnosticCategory::Error, String::from("A_JSDoc_template_tag_may_not_follow_a_typedef_callback_or_overload_tag_8039"), String::from("A JSDoc '@template' tag may not follow a '@typedef', '@callback', or '@overload' tag"), None, None, None) }
    pub fn declaration_emit_for_this_file_requires_using_private_name_0_an_explicit_type_annotation_may_unblock_declaration_emit() -> DiagnosticMessage { diag(9005, DiagnosticCategory::Error, String::from("Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_9005"), String::from("Declaration emit for this file requires using private name '{0}'. An explicit type annotation may unblock declaration emit."), None, None, None) }
    pub fn declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_an_explicit_type_annotation_may_unblock_declaration_emit() -> DiagnosticMessage { diag(9006, DiagnosticCategory::Error, String::from("Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotati_9006"), String::from("Declaration emit for this file requires using private name '{0}' from module '{1}'. An explicit type annotation may unblock declaration emit."), None, None, None) }
    pub fn function_must_have_an_explicit_return_type_annotation_with_isolateddeclarations() -> DiagnosticMessage { diag(9007, DiagnosticCategory::Error, String::from("Function_must_have_an_explicit_return_type_annotation_with_isolatedDeclarations_9007"), String::from("Function must have an explicit return type annotation with --isolatedDeclarations."), None, None, None) }
    pub fn method_must_have_an_explicit_return_type_annotation_with_isolateddeclarations() -> DiagnosticMessage { diag(9008, DiagnosticCategory::Error, String::from("Method_must_have_an_explicit_return_type_annotation_with_isolatedDeclarations_9008"), String::from("Method must have an explicit return type annotation with --isolatedDeclarations."), None, None, None) }
    pub fn at_least_one_accessor_must_have_an_explicit_return_type_annotation_with_isolateddeclarations() -> DiagnosticMessage { diag(9009, DiagnosticCategory::Error, String::from("At_least_one_accessor_must_have_an_explicit_return_type_annotation_with_isolatedDeclarations_9009"), String::from("At least one accessor must have an explicit return type annotation with --isolatedDeclarations."), None, None, None) }
    pub fn variable_must_have_an_explicit_type_annotation_with_isolateddeclarations() -> DiagnosticMessage { diag(9010, DiagnosticCategory::Error, String::from("Variable_must_have_an_explicit_type_annotation_with_isolatedDeclarations_9010"), String::from("Variable must have an explicit type annotation with --isolatedDeclarations."), None, None, None) }
    pub fn parameter_must_have_an_explicit_type_annotation_with_isolateddeclarations() -> DiagnosticMessage { diag(9011, DiagnosticCategory::Error, String::from("Parameter_must_have_an_explicit_type_annotation_with_isolatedDeclarations_9011"), String::from("Parameter must have an explicit type annotation with --isolatedDeclarations."), None, None, None) }
    pub fn property_must_have_an_explicit_type_annotation_with_isolateddeclarations() -> DiagnosticMessage { diag(9012, DiagnosticCategory::Error, String::from("Property_must_have_an_explicit_type_annotation_with_isolatedDeclarations_9012"), String::from("Property must have an explicit type annotation with --isolatedDeclarations."), None, None, None) }
    pub fn expression_type_can_t_be_inferred_with_isolateddeclarations() -> DiagnosticMessage { diag(9013, DiagnosticCategory::Error, String::from("Expression_type_can_t_be_inferred_with_isolatedDeclarations_9013"), String::from("Expression type can't be inferred with --isolatedDeclarations."), None, None, None) }
    pub fn computed_properties_must_be_number_or_string_literals_variables_or_dotted_expressions_with_isolateddeclarations() -> DiagnosticMessage { diag(9014, DiagnosticCategory::Error, String::from("Computed_properties_must_be_number_or_string_literals_variables_or_dotted_expressions_with_isolatedD_9014"), String::from("Computed properties must be number or string literals, variables or dotted expressions with --isolatedDeclarations."), None, None, None) }
    pub fn objects_that_contain_spread_assignments_can_t_be_inferred_with_isolateddeclarations() -> DiagnosticMessage { diag(9015, DiagnosticCategory::Error, String::from("Objects_that_contain_spread_assignments_can_t_be_inferred_with_isolatedDeclarations_9015"), String::from("Objects that contain spread assignments can't be inferred with --isolatedDeclarations."), None, None, None) }
    pub fn objects_that_contain_shorthand_properties_can_t_be_inferred_with_isolateddeclarations() -> DiagnosticMessage { diag(9016, DiagnosticCategory::Error, String::from("Objects_that_contain_shorthand_properties_can_t_be_inferred_with_isolatedDeclarations_9016"), String::from("Objects that contain shorthand properties can't be inferred with --isolatedDeclarations."), None, None, None) }
    pub fn only_const_arrays_can_be_inferred_with_isolateddeclarations() -> DiagnosticMessage { diag(9017, DiagnosticCategory::Error, String::from("Only_const_arrays_can_be_inferred_with_isolatedDeclarations_9017"), String::from("Only const arrays can be inferred with --isolatedDeclarations."), None, None, None) }
    pub fn arrays_with_spread_elements_can_t_inferred_with_isolateddeclarations() -> DiagnosticMessage { diag(9018, DiagnosticCategory::Error, String::from("Arrays_with_spread_elements_can_t_inferred_with_isolatedDeclarations_9018"), String::from("Arrays with spread elements can't inferred with --isolatedDeclarations."), None, None, None) }
    pub fn binding_elements_can_t_be_exported_directly_with_isolateddeclarations() -> DiagnosticMessage { diag(9019, DiagnosticCategory::Error, String::from("Binding_elements_can_t_be_exported_directly_with_isolatedDeclarations_9019"), String::from("Binding elements can't be exported directly with --isolatedDeclarations."), None, None, None) }
    pub fn enum_member_initializers_must_be_computable_without_references_to_external_symbols_with_isolateddeclarations() -> DiagnosticMessage { diag(9020, DiagnosticCategory::Error, String::from("Enum_member_initializers_must_be_computable_without_references_to_external_symbols_with_isolatedDecl_9020"), String::from("Enum member initializers must be computable without references to external symbols with --isolatedDeclarations."), None, None, None) }
    pub fn extends_clause_can_t_contain_an_expression_with_isolateddeclarations() -> DiagnosticMessage { diag(9021, DiagnosticCategory::Error, String::from("Extends_clause_can_t_contain_an_expression_with_isolatedDeclarations_9021"), String::from("Extends clause can't contain an expression with --isolatedDeclarations."), None, None, None) }
    pub fn inference_from_class_expressions_is_not_supported_with_isolateddeclarations() -> DiagnosticMessage { diag(9022, DiagnosticCategory::Error, String::from("Inference_from_class_expressions_is_not_supported_with_isolatedDeclarations_9022"), String::from("Inference from class expressions is not supported with --isolatedDeclarations."), None, None, None) }
    pub fn assigning_properties_to_functions_without_declaring_them_is_not_supported_with_isolateddeclarations_add_an_explicit_declaration_for_the_properties_assigned_to_this_function() -> DiagnosticMessage { diag(9023, DiagnosticCategory::Error, String::from("Assigning_properties_to_functions_without_declaring_them_is_not_supported_with_isolatedDeclarations__9023"), String::from("Assigning properties to functions without declaring them is not supported with --isolatedDeclarations. Add an explicit declaration for the properties assigned to this function."), None, None, None) }
    pub fn declaration_emit_for_this_parameter_requires_implicitly_adding_undefined_to_it_s_type_this_is_not_supported_with_isolateddeclarations() -> DiagnosticMessage { diag(9025, DiagnosticCategory::Error, String::from("Declaration_emit_for_this_parameter_requires_implicitly_adding_undefined_to_it_s_type_This_is_not_su_9025"), String::from("Declaration emit for this parameter requires implicitly adding undefined to it's type. This is not supported with --isolatedDeclarations."), None, None, None) }
    pub fn declaration_emit_for_this_file_requires_preserving_this_import_for_augmentations_this_is_not_supported_with_isolateddeclarations() -> DiagnosticMessage { diag(9026, DiagnosticCategory::Error, String::from("Declaration_emit_for_this_file_requires_preserving_this_import_for_augmentations_This_is_not_support_9026"), String::from("Declaration emit for this file requires preserving this import for augmentations. This is not supported with --isolatedDeclarations."), None, None, None) }
    pub fn add_a_type_annotation_to_the_variable_0() -> DiagnosticMessage { diag(9027, DiagnosticCategory::Error, String::from("Add_a_type_annotation_to_the_variable_0_9027"), String::from("Add a type annotation to the variable {0}."), None, None, None) }
    pub fn add_a_type_annotation_to_the_parameter_0() -> DiagnosticMessage { diag(9028, DiagnosticCategory::Error, String::from("Add_a_type_annotation_to_the_parameter_0_9028"), String::from("Add a type annotation to the parameter {0}."), None, None, None) }
    pub fn add_a_type_annotation_to_the_property_0() -> DiagnosticMessage { diag(9029, DiagnosticCategory::Error, String::from("Add_a_type_annotation_to_the_property_0_9029"), String::from("Add a type annotation to the property {0}."), None, None, None) }
    pub fn add_a_return_type_to_the_function_expression() -> DiagnosticMessage { diag(9030, DiagnosticCategory::Error, String::from("Add_a_return_type_to_the_function_expression_9030"), String::from("Add a return type to the function expression."), None, None, None) }
    pub fn add_a_return_type_to_the_function_declaration() -> DiagnosticMessage { diag(9031, DiagnosticCategory::Error, String::from("Add_a_return_type_to_the_function_declaration_9031"), String::from("Add a return type to the function declaration."), None, None, None) }
    pub fn add_a_return_type_to_the_get_accessor_declaration() -> DiagnosticMessage { diag(9032, DiagnosticCategory::Error, String::from("Add_a_return_type_to_the_get_accessor_declaration_9032"), String::from("Add a return type to the get accessor declaration."), None, None, None) }
    pub fn add_a_type_to_parameter_of_the_set_accessor_declaration() -> DiagnosticMessage { diag(9033, DiagnosticCategory::Error, String::from("Add_a_type_to_parameter_of_the_set_accessor_declaration_9033"), String::from("Add a type to parameter of the set accessor declaration."), None, None, None) }
    pub fn add_a_return_type_to_the_method() -> DiagnosticMessage { diag(9034, DiagnosticCategory::Error, String::from("Add_a_return_type_to_the_method_9034"), String::from("Add a return type to the method"), None, None, None) }
    pub fn add_satisfies_and_a_type_assertion_to_this_expression_satisfies_t_as_t_to_make_the_type_explicit() -> DiagnosticMessage { diag(9035, DiagnosticCategory::Error, String::from("Add_satisfies_and_a_type_assertion_to_this_expression_satisfies_T_as_T_to_make_the_type_explicit_9035"), String::from("Add satisfies and a type assertion to this expression (satisfies T as T) to make the type explicit."), None, None, None) }
    pub fn move_the_expression_in_default_export_to_a_variable_and_add_a_type_annotation_to_it() -> DiagnosticMessage { diag(9036, DiagnosticCategory::Error, String::from("Move_the_expression_in_default_export_to_a_variable_and_add_a_type_annotation_to_it_9036"), String::from("Move the expression in default export to a variable and add a type annotation to it."), None, None, None) }
    pub fn default_exports_can_t_be_inferred_with_isolateddeclarations() -> DiagnosticMessage { diag(9037, DiagnosticCategory::Error, String::from("Default_exports_can_t_be_inferred_with_isolatedDeclarations_9037"), String::from("Default exports can't be inferred with --isolatedDeclarations."), None, None, None) }
    pub fn computed_property_names_on_class_or_object_literals_cannot_be_inferred_with_isolateddeclarations() -> DiagnosticMessage { diag(9038, DiagnosticCategory::Error, String::from("Computed_property_names_on_class_or_object_literals_cannot_be_inferred_with_isolatedDeclarations_9038"), String::from("Computed property names on class or object literals cannot be inferred with --isolatedDeclarations."), None, None, None) }
    pub fn type_containing_private_name_0_can_t_be_used_with_isolateddeclarations() -> DiagnosticMessage { diag(9039, DiagnosticCategory::Error, String::from("Type_containing_private_name_0_can_t_be_used_with_isolatedDeclarations_9039"), String::from("Type containing private name '{0}' can't be used with --isolatedDeclarations."), None, None, None) }
    pub fn jsx_attributes_must_only_be_assigned_a_non_empty_expression() -> DiagnosticMessage { diag(17000, DiagnosticCategory::Error, String::from("JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000"), String::from("JSX attributes must only be assigned a non-empty 'expression'."), None, None, None) }
    pub fn jsx_elements_cannot_have_multiple_attributes_with_the_same_name() -> DiagnosticMessage { diag(17001, DiagnosticCategory::Error, String::from("JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001"), String::from("JSX elements cannot have multiple attributes with the same name."), None, None, None) }
    pub fn expected_corresponding_jsx_closing_tag_for_0() -> DiagnosticMessage { diag(17002, DiagnosticCategory::Error, String::from("Expected_corresponding_JSX_closing_tag_for_0_17002"), String::from("Expected corresponding JSX closing tag for '{0}'."), None, None, None) }
    pub fn cannot_use_jsx_unless_the_jsx_flag_is_provided() -> DiagnosticMessage { diag(17004, DiagnosticCategory::Error, String::from("Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004"), String::from("Cannot use JSX unless the '--jsx' flag is provided."), None, None, None) }
    pub fn a_constructor_cannot_contain_a_super_call_when_its_class_extends_null() -> DiagnosticMessage { diag(17005, DiagnosticCategory::Error, String::from("A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005"), String::from("A constructor cannot contain a 'super' call when its class extends 'null'."), None, None, None) }
    pub fn an_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_consider_enclosing_the_expression_in_parentheses() -> DiagnosticMessage { diag(17006, DiagnosticCategory::Error, String::from("An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006"), String::from("An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."), None, None, None) }
    pub fn a_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_consider_enclosing_the_expression_in_parentheses() -> DiagnosticMessage { diag(17007, DiagnosticCategory::Error, String::from("A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007"), String::from("A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."), None, None, None) }
    pub fn jsx_element_0_has_no_corresponding_closing_tag() -> DiagnosticMessage { diag(17008, DiagnosticCategory::Error, String::from("JSX_element_0_has_no_corresponding_closing_tag_17008"), String::from("JSX element '{0}' has no corresponding closing tag."), None, None, None) }
    pub fn super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class() -> DiagnosticMessage { diag(17009, DiagnosticCategory::Error, String::from("super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009"), String::from("'super' must be called before accessing 'this' in the constructor of a derived class."), None, None, None) }
    pub fn unknown_type_acquisition_option_0() -> DiagnosticMessage { diag(17010, DiagnosticCategory::Error, String::from("Unknown_type_acquisition_option_0_17010"), String::from("Unknown type acquisition option '{0}'."), None, None, None) }
    pub fn super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class() -> DiagnosticMessage { diag(17011, DiagnosticCategory::Error, String::from("super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011"), String::from("'super' must be called before accessing a property of 'super' in the constructor of a derived class."), None, None, None) }
    pub fn _0_is_not_a_valid_meta_property_for_keyword_1_did_you_mean_2() -> DiagnosticMessage { diag(17012, DiagnosticCategory::Error, String::from("_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012"), String::from("'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?"), None, None, None) }
    pub fn meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor() -> DiagnosticMessage { diag(17013, DiagnosticCategory::Error, String::from("Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013"), String::from("Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor."), None, None, None) }
    pub fn jsx_fragment_has_no_corresponding_closing_tag() -> DiagnosticMessage { diag(17014, DiagnosticCategory::Error, String::from("JSX_fragment_has_no_corresponding_closing_tag_17014"), String::from("JSX fragment has no corresponding closing tag."), None, None, None) }
    pub fn expected_corresponding_closing_tag_for_jsx_fragment() -> DiagnosticMessage { diag(17015, DiagnosticCategory::Error, String::from("Expected_corresponding_closing_tag_for_JSX_fragment_17015"), String::from("Expected corresponding closing tag for JSX fragment."), None, None, None) }
    pub fn the_jsxfragmentfactory_compiler_option_must_be_provided_to_use_jsx_fragments_with_the_jsxfactory_compiler_option() -> DiagnosticMessage { diag(17016, DiagnosticCategory::Error, String::from("The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_com_17016"), String::from("The 'jsxFragmentFactory' compiler option must be provided to use JSX fragments with the 'jsxFactory' compiler option."), None, None, None) }
    pub fn an_jsxfrag_pragma_is_required_when_using_an_jsx_pragma_with_jsx_fragments() -> DiagnosticMessage { diag(17017, DiagnosticCategory::Error, String::from("An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments_17017"), String::from("An @jsxFrag pragma is required when using an @jsx pragma with JSX fragments."), None, None, None) }
    pub fn unknown_type_acquisition_option_0_did_you_mean_1() -> DiagnosticMessage { diag(17018, DiagnosticCategory::Error, String::from("Unknown_type_acquisition_option_0_Did_you_mean_1_17018"), String::from("Unknown type acquisition option '{0}'. Did you mean '{1}'?"), None, None, None) }
    pub fn _0_at_the_end_of_a_type_is_not_valid_typescript_syntax_did_you_mean_to_write_1() -> DiagnosticMessage { diag(17019, DiagnosticCategory::Error, String::from("_0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1_17019"), String::from("'{0}' at the end of a type is not valid TypeScript syntax. Did you mean to write '{1}'?"), None, None, None) }
    pub fn _0_at_the_start_of_a_type_is_not_valid_typescript_syntax_did_you_mean_to_write_1() -> DiagnosticMessage { diag(17020, DiagnosticCategory::Error, String::from("_0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1_17020"), String::from("'{0}' at the start of a type is not valid TypeScript syntax. Did you mean to write '{1}'?"), None, None, None) }
    pub fn unicode_escape_sequence_cannot_appear_here() -> DiagnosticMessage { diag(17021, DiagnosticCategory::Error, String::from("Unicode_escape_sequence_cannot_appear_here_17021"), String::from("Unicode escape sequence cannot appear here."), None, None, None) }
    pub fn circularity_detected_while_resolving_configuration_colon_0() -> DiagnosticMessage { diag(18000, DiagnosticCategory::Error, String::from("Circularity_detected_while_resolving_configuration_colon_0_18000"), String::from("Circularity detected while resolving configuration: {0}"), None, None, None) }
    pub fn the_files_list_in_config_file_0_is_empty() -> DiagnosticMessage { diag(18002, DiagnosticCategory::Error, String::from("The_files_list_in_config_file_0_is_empty_18002"), String::from("The 'files' list in config file '{0}' is empty."), None, None, None) }
    pub fn no_inputs_were_found_in_config_file_0_specified_include_paths_were_1_and_exclude_paths_were_2() -> DiagnosticMessage { diag(18003, DiagnosticCategory::Error, String::from("No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003"), String::from("No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'."), None, None, None) }
    pub fn file_is_a_commonjs_module_it_may_be_converted_to_an_es_module() -> DiagnosticMessage { diag(80001, DiagnosticCategory::Suggestion, String::from("File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module_80001"), String::from("File is a CommonJS module; it may be converted to an ES module."), None, None, None) }
    pub fn this_constructor_function_may_be_converted_to_a_class_declaration() -> DiagnosticMessage { diag(80002, DiagnosticCategory::Suggestion, String::from("This_constructor_function_may_be_converted_to_a_class_declaration_80002"), String::from("This constructor function may be converted to a class declaration."), None, None, None) }
    pub fn import_may_be_converted_to_a_default_import() -> DiagnosticMessage { diag(80003, DiagnosticCategory::Suggestion, String::from("Import_may_be_converted_to_a_default_import_80003"), String::from("Import may be converted to a default import."), None, None, None) }
    pub fn jsdoc_types_may_be_moved_to_typescript_types() -> DiagnosticMessage { diag(80004, DiagnosticCategory::Suggestion, String::from("JSDoc_types_may_be_moved_to_TypeScript_types_80004"), String::from("JSDoc types may be moved to TypeScript types."), None, None, None) }
    pub fn require_call_may_be_converted_to_an_import() -> DiagnosticMessage { diag(80005, DiagnosticCategory::Suggestion, String::from("require_call_may_be_converted_to_an_import_80005"), String::from("'require' call may be converted to an import."), None, None, None) }
    pub fn this_may_be_converted_to_an_async_function() -> DiagnosticMessage { diag(80006, DiagnosticCategory::Suggestion, String::from("This_may_be_converted_to_an_async_function_80006"), String::from("This may be converted to an async function."), None, None, None) }
    pub fn await_has_no_effect_on_the_type_of_this_expression() -> DiagnosticMessage { diag(80007, DiagnosticCategory::Suggestion, String::from("await_has_no_effect_on_the_type_of_this_expression_80007"), String::from("'await' has no effect on the type of this expression."), None, None, None) }
    pub fn numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers() -> DiagnosticMessage { diag(80008, DiagnosticCategory::Suggestion, String::from("Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accur_80008"), String::from("Numeric literals with absolute values equal to 2^53 or greater are too large to be represented accurately as integers."), None, None, None) }
    pub fn jsdoc_typedef_may_be_converted_to_typescript_type() -> DiagnosticMessage { diag(80009, DiagnosticCategory::Suggestion, String::from("JSDoc_typedef_may_be_converted_to_TypeScript_type_80009"), String::from("JSDoc typedef may be converted to TypeScript type."), None, None, None) }
    pub fn jsdoc_typedefs_may_be_converted_to_typescript_types() -> DiagnosticMessage { diag(80010, DiagnosticCategory::Suggestion, String::from("JSDoc_typedefs_may_be_converted_to_TypeScript_types_80010"), String::from("JSDoc typedefs may be converted to TypeScript types."), None, None, None) }
    pub fn add_missing_super_call() -> DiagnosticMessage { diag(90001, DiagnosticCategory::Message, String::from("Add_missing_super_call_90001"), String::from("Add missing 'super()' call"), None, None, None) }
    pub fn make_super_call_the_first_statement_in_the_constructor() -> DiagnosticMessage { diag(90002, DiagnosticCategory::Message, String::from("Make_super_call_the_first_statement_in_the_constructor_90002"), String::from("Make 'super()' call the first statement in the constructor"), None, None, None) }
    pub fn change_extends_to_implements() -> DiagnosticMessage { diag(90003, DiagnosticCategory::Message, String::from("Change_extends_to_implements_90003"), String::from("Change 'extends' to 'implements'"), None, None, None) }
    pub fn remove_unused_declaration_for_colon_0() -> DiagnosticMessage { diag(90004, DiagnosticCategory::Message, String::from("Remove_unused_declaration_for_colon_0_90004"), String::from("Remove unused declaration for: '{0}'"), None, None, None) }
    pub fn remove_import_from_0() -> DiagnosticMessage { diag(90005, DiagnosticCategory::Message, String::from("Remove_import_from_0_90005"), String::from("Remove import from '{0}'"), None, None, None) }
    pub fn implement_interface_0() -> DiagnosticMessage { diag(90006, DiagnosticCategory::Message, String::from("Implement_interface_0_90006"), String::from("Implement interface '{0}'"), None, None, None) }
    pub fn implement_inherited_abstract_class() -> DiagnosticMessage { diag(90007, DiagnosticCategory::Message, String::from("Implement_inherited_abstract_class_90007"), String::from("Implement inherited abstract class"), None, None, None) }
    pub fn add_0_to_unresolved_variable() -> DiagnosticMessage { diag(90008, DiagnosticCategory::Message, String::from("Add_0_to_unresolved_variable_90008"), String::from("Add '{0}.' to unresolved variable"), None, None, None) }
    pub fn remove_variable_statement() -> DiagnosticMessage { diag(90010, DiagnosticCategory::Message, String::from("Remove_variable_statement_90010"), String::from("Remove variable statement"), None, None, None) }
    pub fn remove_template_tag() -> DiagnosticMessage { diag(90011, DiagnosticCategory::Message, String::from("Remove_template_tag_90011"), String::from("Remove template tag"), None, None, None) }
    pub fn remove_type_parameters() -> DiagnosticMessage { diag(90012, DiagnosticCategory::Message, String::from("Remove_type_parameters_90012"), String::from("Remove type parameters"), None, None, None) }
    pub fn import_0_from_1() -> DiagnosticMessage { diag(90013, DiagnosticCategory::Message, String::from("Import_0_from_1_90013"), String::from("Import '{0}' from \"{1}\""), None, None, None) }
    pub fn change_0_to_1() -> DiagnosticMessage { diag(90014, DiagnosticCategory::Message, String::from("Change_0_to_1_90014"), String::from("Change '{0}' to '{1}'"), None, None, None) }
    pub fn declare_property_0() -> DiagnosticMessage { diag(90016, DiagnosticCategory::Message, String::from("Declare_property_0_90016"), String::from("Declare property '{0}'"), None, None, None) }
    pub fn add_index_signature_for_property_0() -> DiagnosticMessage { diag(90017, DiagnosticCategory::Message, String::from("Add_index_signature_for_property_0_90017"), String::from("Add index signature for property '{0}'"), None, None, None) }
    pub fn disable_checking_for_this_file() -> DiagnosticMessage { diag(90018, DiagnosticCategory::Message, String::from("Disable_checking_for_this_file_90018"), String::from("Disable checking for this file"), None, None, None) }
    pub fn ignore_this_error_message() -> DiagnosticMessage { diag(90019, DiagnosticCategory::Message, String::from("Ignore_this_error_message_90019"), String::from("Ignore this error message"), None, None, None) }
    pub fn initialize_property_0_in_the_constructor() -> DiagnosticMessage { diag(90020, DiagnosticCategory::Message, String::from("Initialize_property_0_in_the_constructor_90020"), String::from("Initialize property '{0}' in the constructor"), None, None, None) }
    pub fn initialize_static_property_0() -> DiagnosticMessage { diag(90021, DiagnosticCategory::Message, String::from("Initialize_static_property_0_90021"), String::from("Initialize static property '{0}'"), None, None, None) }
    pub fn change_spelling_to_0() -> DiagnosticMessage { diag(90022, DiagnosticCategory::Message, String::from("Change_spelling_to_0_90022"), String::from("Change spelling to '{0}'"), None, None, None) }
    pub fn declare_method_0() -> DiagnosticMessage { diag(90023, DiagnosticCategory::Message, String::from("Declare_method_0_90023"), String::from("Declare method '{0}'"), None, None, None) }
    pub fn declare_static_method_0() -> DiagnosticMessage { diag(90024, DiagnosticCategory::Message, String::from("Declare_static_method_0_90024"), String::from("Declare static method '{0}'"), None, None, None) }
    pub fn prefix_0_with_an_underscore() -> DiagnosticMessage { diag(90025, DiagnosticCategory::Message, String::from("Prefix_0_with_an_underscore_90025"), String::from("Prefix '{0}' with an underscore"), None, None, None) }
    pub fn rewrite_as_the_indexed_access_type_0() -> DiagnosticMessage { diag(90026, DiagnosticCategory::Message, String::from("Rewrite_as_the_indexed_access_type_0_90026"), String::from("Rewrite as the indexed access type '{0}'"), None, None, None) }
    pub fn declare_static_property_0() -> DiagnosticMessage { diag(90027, DiagnosticCategory::Message, String::from("Declare_static_property_0_90027"), String::from("Declare static property '{0}'"), None, None, None) }
    pub fn call_decorator_expression() -> DiagnosticMessage { diag(90028, DiagnosticCategory::Message, String::from("Call_decorator_expression_90028"), String::from("Call decorator expression"), None, None, None) }
    pub fn add_async_modifier_to_containing_function() -> DiagnosticMessage { diag(90029, DiagnosticCategory::Message, String::from("Add_async_modifier_to_containing_function_90029"), String::from("Add async modifier to containing function"), None, None, None) }
    pub fn replace_infer_0_with_unknown() -> DiagnosticMessage { diag(90030, DiagnosticCategory::Message, String::from("Replace_infer_0_with_unknown_90030"), String::from("Replace 'infer {0}' with 'unknown'"), None, None, None) }
    pub fn replace_all_unused_infer_with_unknown() -> DiagnosticMessage { diag(90031, DiagnosticCategory::Message, String::from("Replace_all_unused_infer_with_unknown_90031"), String::from("Replace all unused 'infer' with 'unknown'"), None, None, None) }
    pub fn add_parameter_name() -> DiagnosticMessage { diag(90034, DiagnosticCategory::Message, String::from("Add_parameter_name_90034"), String::from("Add parameter name"), None, None, None) }
    pub fn declare_private_property_0() -> DiagnosticMessage { diag(90035, DiagnosticCategory::Message, String::from("Declare_private_property_0_90035"), String::from("Declare private property '{0}'"), None, None, None) }
    pub fn replace_0_with_promise_1() -> DiagnosticMessage { diag(90036, DiagnosticCategory::Message, String::from("Replace_0_with_Promise_1_90036"), String::from("Replace '{0}' with 'Promise<{1}>'"), None, None, None) }
    pub fn fix_all_incorrect_return_type_of_an_async_functions() -> DiagnosticMessage { diag(90037, DiagnosticCategory::Message, String::from("Fix_all_incorrect_return_type_of_an_async_functions_90037"), String::from("Fix all incorrect return type of an async functions"), None, None, None) }
    pub fn declare_private_method_0() -> DiagnosticMessage { diag(90038, DiagnosticCategory::Message, String::from("Declare_private_method_0_90038"), String::from("Declare private method '{0}'"), None, None, None) }
    pub fn remove_unused_destructuring_declaration() -> DiagnosticMessage { diag(90039, DiagnosticCategory::Message, String::from("Remove_unused_destructuring_declaration_90039"), String::from("Remove unused destructuring declaration"), None, None, None) }
    pub fn remove_unused_declarations_for_colon_0() -> DiagnosticMessage { diag(90041, DiagnosticCategory::Message, String::from("Remove_unused_declarations_for_colon_0_90041"), String::from("Remove unused declarations for: '{0}'"), None, None, None) }
    pub fn declare_a_private_field_named_0() -> DiagnosticMessage { diag(90053, DiagnosticCategory::Message, String::from("Declare_a_private_field_named_0_90053"), String::from("Declare a private field named '{0}'."), None, None, None) }
    pub fn includes_imports_of_types_referenced_by_0() -> DiagnosticMessage { diag(90054, DiagnosticCategory::Message, String::from("Includes_imports_of_types_referenced_by_0_90054"), String::from("Includes imports of types referenced by '{0}'"), None, None, None) }
    pub fn remove_type_from_import_declaration_from_0() -> DiagnosticMessage { diag(90055, DiagnosticCategory::Message, String::from("Remove_type_from_import_declaration_from_0_90055"), String::from("Remove 'type' from import declaration from \"{0}\""), None, None, None) }
    pub fn remove_type_from_import_of_0_from_1() -> DiagnosticMessage { diag(90056, DiagnosticCategory::Message, String::from("Remove_type_from_import_of_0_from_1_90056"), String::from("Remove 'type' from import of '{0}' from \"{1}\""), None, None, None) }
    pub fn add_import_from_0() -> DiagnosticMessage { diag(90057, DiagnosticCategory::Message, String::from("Add_import_from_0_90057"), String::from("Add import from \"{0}\""), None, None, None) }
    pub fn update_import_from_0() -> DiagnosticMessage { diag(90058, DiagnosticCategory::Message, String::from("Update_import_from_0_90058"), String::from("Update import from \"{0}\""), None, None, None) }
    pub fn export_0_from_module_1() -> DiagnosticMessage { diag(90059, DiagnosticCategory::Message, String::from("Export_0_from_module_1_90059"), String::from("Export '{0}' from module '{1}'"), None, None, None) }
    pub fn export_all_referenced_locals() -> DiagnosticMessage { diag(90060, DiagnosticCategory::Message, String::from("Export_all_referenced_locals_90060"), String::from("Export all referenced locals"), None, None, None) }
    pub fn update_modifiers_of_0() -> DiagnosticMessage { diag(90061, DiagnosticCategory::Message, String::from("Update_modifiers_of_0_90061"), String::from("Update modifiers of '{0}'"), None, None, None) }
    pub fn add_annotation_of_type_0() -> DiagnosticMessage { diag(90062, DiagnosticCategory::Message, String::from("Add_annotation_of_type_0_90062"), String::from("Add annotation of type '{0}'"), None, None, None) }
    pub fn add_return_type_0() -> DiagnosticMessage { diag(90063, DiagnosticCategory::Message, String::from("Add_return_type_0_90063"), String::from("Add return type '{0}'"), None, None, None) }
    pub fn extract_base_class_to_variable() -> DiagnosticMessage { diag(90064, DiagnosticCategory::Message, String::from("Extract_base_class_to_variable_90064"), String::from("Extract base class to variable"), None, None, None) }
    pub fn extract_default_export_to_variable() -> DiagnosticMessage { diag(90065, DiagnosticCategory::Message, String::from("Extract_default_export_to_variable_90065"), String::from("Extract default export to variable"), None, None, None) }
    pub fn extract_binding_expressions_to_variable() -> DiagnosticMessage { diag(90066, DiagnosticCategory::Message, String::from("Extract_binding_expressions_to_variable_90066"), String::from("Extract binding expressions to variable"), None, None, None) }
    pub fn add_all_missing_type_annotations() -> DiagnosticMessage { diag(90067, DiagnosticCategory::Message, String::from("Add_all_missing_type_annotations_90067"), String::from("Add all missing type annotations"), None, None, None) }
    pub fn add_satisfies_and_an_inline_type_assertion_with_0() -> DiagnosticMessage { diag(90068, DiagnosticCategory::Message, String::from("Add_satisfies_and_an_inline_type_assertion_with_0_90068"), String::from("Add satisfies and an inline type assertion with '{0}'"), None, None, None) }
    pub fn extract_to_variable_and_replace_with_0_as_typeof_0() -> DiagnosticMessage { diag(90069, DiagnosticCategory::Message, String::from("Extract_to_variable_and_replace_with_0_as_typeof_0_90069"), String::from("Extract to variable and replace with '{0} as typeof {0}'"), None, None, None) }
    pub fn mark_array_literal_as_const() -> DiagnosticMessage { diag(90070, DiagnosticCategory::Message, String::from("Mark_array_literal_as_const_90070"), String::from("Mark array literal as const"), None, None, None) }
    pub fn annotate_types_of_properties_expando_function_in_a_namespace() -> DiagnosticMessage { diag(90071, DiagnosticCategory::Message, String::from("Annotate_types_of_properties_expando_function_in_a_namespace_90071"), String::from("Annotate types of properties expando function in a namespace"), None, None, None) }
    pub fn convert_function_to_an_es2015_class() -> DiagnosticMessage { diag(95001, DiagnosticCategory::Message, String::from("Convert_function_to_an_ES2015_class_95001"), String::from("Convert function to an ES2015 class"), None, None, None) }
    pub fn convert_0_to_1_in_0() -> DiagnosticMessage { diag(95003, DiagnosticCategory::Message, String::from("Convert_0_to_1_in_0_95003"), String::from("Convert '{0}' to '{1} in {0}'"), None, None, None) }
    pub fn extract_to_0_in_1() -> DiagnosticMessage { diag(95004, DiagnosticCategory::Message, String::from("Extract_to_0_in_1_95004"), String::from("Extract to {0} in {1}"), None, None, None) }
    pub fn extract_function() -> DiagnosticMessage { diag(95005, DiagnosticCategory::Message, String::from("Extract_function_95005"), String::from("Extract function"), None, None, None) }
    pub fn extract_constant() -> DiagnosticMessage { diag(95006, DiagnosticCategory::Message, String::from("Extract_constant_95006"), String::from("Extract constant"), None, None, None) }
    pub fn extract_to_0_in_enclosing_scope() -> DiagnosticMessage { diag(95007, DiagnosticCategory::Message, String::from("Extract_to_0_in_enclosing_scope_95007"), String::from("Extract to {0} in enclosing scope"), None, None, None) }
    pub fn extract_to_0_in_1_scope() -> DiagnosticMessage { diag(95008, DiagnosticCategory::Message, String::from("Extract_to_0_in_1_scope_95008"), String::from("Extract to {0} in {1} scope"), None, None, None) }
    pub fn annotate_with_type_from_jsdoc() -> DiagnosticMessage { diag(95009, DiagnosticCategory::Message, String::from("Annotate_with_type_from_JSDoc_95009"), String::from("Annotate with type from JSDoc"), None, None, None) }
    pub fn infer_type_of_0_from_usage() -> DiagnosticMessage { diag(95011, DiagnosticCategory::Message, String::from("Infer_type_of_0_from_usage_95011"), String::from("Infer type of '{0}' from usage"), None, None, None) }
    pub fn infer_parameter_types_from_usage() -> DiagnosticMessage { diag(95012, DiagnosticCategory::Message, String::from("Infer_parameter_types_from_usage_95012"), String::from("Infer parameter types from usage"), None, None, None) }
    pub fn convert_to_default_import() -> DiagnosticMessage { diag(95013, DiagnosticCategory::Message, String::from("Convert_to_default_import_95013"), String::from("Convert to default import"), None, None, None) }
    pub fn install_0() -> DiagnosticMessage { diag(95014, DiagnosticCategory::Message, String::from("Install_0_95014"), String::from("Install '{0}'"), None, None, None) }
    pub fn replace_import_with_0() -> DiagnosticMessage { diag(95015, DiagnosticCategory::Message, String::from("Replace_import_with_0_95015"), String::from("Replace import with '{0}'."), None, None, None) }
    pub fn use_synthetic_default_member() -> DiagnosticMessage { diag(95016, DiagnosticCategory::Message, String::from("Use_synthetic_default_member_95016"), String::from("Use synthetic 'default' member."), None, None, None) }
    pub fn convert_to_es_module() -> DiagnosticMessage { diag(95017, DiagnosticCategory::Message, String::from("Convert_to_ES_module_95017"), String::from("Convert to ES module"), None, None, None) }
    pub fn add_undefined_type_to_property_0() -> DiagnosticMessage { diag(95018, DiagnosticCategory::Message, String::from("Add_undefined_type_to_property_0_95018"), String::from("Add 'undefined' type to property '{0}'"), None, None, None) }
    pub fn add_initializer_to_property_0() -> DiagnosticMessage { diag(95019, DiagnosticCategory::Message, String::from("Add_initializer_to_property_0_95019"), String::from("Add initializer to property '{0}'"), None, None, None) }
    pub fn add_definite_assignment_assertion_to_property_0() -> DiagnosticMessage { diag(95020, DiagnosticCategory::Message, String::from("Add_definite_assignment_assertion_to_property_0_95020"), String::from("Add definite assignment assertion to property '{0}'"), None, None, None) }
    pub fn convert_all_type_literals_to_mapped_type() -> DiagnosticMessage { diag(95021, DiagnosticCategory::Message, String::from("Convert_all_type_literals_to_mapped_type_95021"), String::from("Convert all type literals to mapped type"), None, None, None) }
    pub fn add_all_missing_members() -> DiagnosticMessage { diag(95022, DiagnosticCategory::Message, String::from("Add_all_missing_members_95022"), String::from("Add all missing members"), None, None, None) }
    pub fn infer_all_types_from_usage() -> DiagnosticMessage { diag(95023, DiagnosticCategory::Message, String::from("Infer_all_types_from_usage_95023"), String::from("Infer all types from usage"), None, None, None) }
    pub fn delete_all_unused_declarations() -> DiagnosticMessage { diag(95024, DiagnosticCategory::Message, String::from("Delete_all_unused_declarations_95024"), String::from("Delete all unused declarations"), None, None, None) }
    pub fn prefix_all_unused_declarations_with_where_possible() -> DiagnosticMessage { diag(95025, DiagnosticCategory::Message, String::from("Prefix_all_unused_declarations_with_where_possible_95025"), String::from("Prefix all unused declarations with '_' where possible"), None, None, None) }
    pub fn fix_all_detected_spelling_errors() -> DiagnosticMessage { diag(95026, DiagnosticCategory::Message, String::from("Fix_all_detected_spelling_errors_95026"), String::from("Fix all detected spelling errors"), None, None, None) }
    pub fn add_initializers_to_all_uninitialized_properties() -> DiagnosticMessage { diag(95027, DiagnosticCategory::Message, String::from("Add_initializers_to_all_uninitialized_properties_95027"), String::from("Add initializers to all uninitialized properties"), None, None, None) }
    pub fn add_definite_assignment_assertions_to_all_uninitialized_properties() -> DiagnosticMessage { diag(95028, DiagnosticCategory::Message, String::from("Add_definite_assignment_assertions_to_all_uninitialized_properties_95028"), String::from("Add definite assignment assertions to all uninitialized properties"), None, None, None) }
    pub fn add_undefined_type_to_all_uninitialized_properties() -> DiagnosticMessage { diag(95029, DiagnosticCategory::Message, String::from("Add_undefined_type_to_all_uninitialized_properties_95029"), String::from("Add undefined type to all uninitialized properties"), None, None, None) }
    pub fn change_all_jsdoc_style_types_to_typescript() -> DiagnosticMessage { diag(95030, DiagnosticCategory::Message, String::from("Change_all_jsdoc_style_types_to_TypeScript_95030"), String::from("Change all jsdoc-style types to TypeScript"), None, None, None) }
    pub fn change_all_jsdoc_style_types_to_typescript_and_add_undefined_to_nullable_types() -> DiagnosticMessage { diag(95031, DiagnosticCategory::Message, String::from("Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types_95031"), String::from("Change all jsdoc-style types to TypeScript (and add '| undefined' to nullable types)"), None, None, None) }
    pub fn implement_all_unimplemented_interfaces() -> DiagnosticMessage { diag(95032, DiagnosticCategory::Message, String::from("Implement_all_unimplemented_interfaces_95032"), String::from("Implement all unimplemented interfaces"), None, None, None) }
    pub fn install_all_missing_types_packages() -> DiagnosticMessage { diag(95033, DiagnosticCategory::Message, String::from("Install_all_missing_types_packages_95033"), String::from("Install all missing types packages"), None, None, None) }
    pub fn rewrite_all_as_indexed_access_types() -> DiagnosticMessage { diag(95034, DiagnosticCategory::Message, String::from("Rewrite_all_as_indexed_access_types_95034"), String::from("Rewrite all as indexed access types"), None, None, None) }
    pub fn convert_all_to_default_imports() -> DiagnosticMessage { diag(95035, DiagnosticCategory::Message, String::from("Convert_all_to_default_imports_95035"), String::from("Convert all to default imports"), None, None, None) }
    pub fn make_all_super_calls_the_first_statement_in_their_constructor() -> DiagnosticMessage { diag(95036, DiagnosticCategory::Message, String::from("Make_all_super_calls_the_first_statement_in_their_constructor_95036"), String::from("Make all 'super()' calls the first statement in their constructor"), None, None, None) }
    pub fn add_qualifier_to_all_unresolved_variables_matching_a_member_name() -> DiagnosticMessage { diag(95037, DiagnosticCategory::Message, String::from("Add_qualifier_to_all_unresolved_variables_matching_a_member_name_95037"), String::from("Add qualifier to all unresolved variables matching a member name"), None, None, None) }
    pub fn change_all_extended_interfaces_to_implements() -> DiagnosticMessage { diag(95038, DiagnosticCategory::Message, String::from("Change_all_extended_interfaces_to_implements_95038"), String::from("Change all extended interfaces to 'implements'"), None, None, None) }
    pub fn add_all_missing_super_calls() -> DiagnosticMessage { diag(95039, DiagnosticCategory::Message, String::from("Add_all_missing_super_calls_95039"), String::from("Add all missing super calls"), None, None, None) }
    pub fn implement_all_inherited_abstract_classes() -> DiagnosticMessage { diag(95040, DiagnosticCategory::Message, String::from("Implement_all_inherited_abstract_classes_95040"), String::from("Implement all inherited abstract classes"), None, None, None) }
    pub fn add_all_missing_async_modifiers() -> DiagnosticMessage { diag(95041, DiagnosticCategory::Message, String::from("Add_all_missing_async_modifiers_95041"), String::from("Add all missing 'async' modifiers"), None, None, None) }
    pub fn add_ts_ignore_to_all_error_messages() -> DiagnosticMessage { diag(95042, DiagnosticCategory::Message, String::from("Add_ts_ignore_to_all_error_messages_95042"), String::from("Add '@ts-ignore' to all error messages"), None, None, None) }
    pub fn annotate_everything_with_types_from_jsdoc() -> DiagnosticMessage { diag(95043, DiagnosticCategory::Message, String::from("Annotate_everything_with_types_from_JSDoc_95043"), String::from("Annotate everything with types from JSDoc"), None, None, None) }
    pub fn add_to_all_uncalled_decorators() -> DiagnosticMessage { diag(95044, DiagnosticCategory::Message, String::from("Add_to_all_uncalled_decorators_95044"), String::from("Add '()' to all uncalled decorators"), None, None, None) }
    pub fn convert_all_constructor_functions_to_classes() -> DiagnosticMessage { diag(95045, DiagnosticCategory::Message, String::from("Convert_all_constructor_functions_to_classes_95045"), String::from("Convert all constructor functions to classes"), None, None, None) }
    pub fn generate_get_and_set_accessors() -> DiagnosticMessage { diag(95046, DiagnosticCategory::Message, String::from("Generate_get_and_set_accessors_95046"), String::from("Generate 'get' and 'set' accessors"), None, None, None) }
    pub fn convert_require_to_import() -> DiagnosticMessage { diag(95047, DiagnosticCategory::Message, String::from("Convert_require_to_import_95047"), String::from("Convert 'require' to 'import'"), None, None, None) }
    pub fn convert_all_require_to_import() -> DiagnosticMessage { diag(95048, DiagnosticCategory::Message, String::from("Convert_all_require_to_import_95048"), String::from("Convert all 'require' to 'import'"), None, None, None) }
    pub fn move_to_a_new_file() -> DiagnosticMessage { diag(95049, DiagnosticCategory::Message, String::from("Move_to_a_new_file_95049"), String::from("Move to a new file"), None, None, None) }
    pub fn remove_unreachable_code() -> DiagnosticMessage { diag(95050, DiagnosticCategory::Message, String::from("Remove_unreachable_code_95050"), String::from("Remove unreachable code"), None, None, None) }
    pub fn remove_all_unreachable_code() -> DiagnosticMessage { diag(95051, DiagnosticCategory::Message, String::from("Remove_all_unreachable_code_95051"), String::from("Remove all unreachable code"), None, None, None) }
    pub fn add_missing_typeof() -> DiagnosticMessage { diag(95052, DiagnosticCategory::Message, String::from("Add_missing_typeof_95052"), String::from("Add missing 'typeof'"), None, None, None) }
    pub fn remove_unused_label() -> DiagnosticMessage { diag(95053, DiagnosticCategory::Message, String::from("Remove_unused_label_95053"), String::from("Remove unused label"), None, None, None) }
    pub fn remove_all_unused_labels() -> DiagnosticMessage { diag(95054, DiagnosticCategory::Message, String::from("Remove_all_unused_labels_95054"), String::from("Remove all unused labels"), None, None, None) }
    pub fn convert_0_to_mapped_object_type() -> DiagnosticMessage { diag(95055, DiagnosticCategory::Message, String::from("Convert_0_to_mapped_object_type_95055"), String::from("Convert '{0}' to mapped object type"), None, None, None) }
    pub fn convert_namespace_import_to_named_imports() -> DiagnosticMessage { diag(95056, DiagnosticCategory::Message, String::from("Convert_namespace_import_to_named_imports_95056"), String::from("Convert namespace import to named imports"), None, None, None) }
    pub fn convert_named_imports_to_namespace_import() -> DiagnosticMessage { diag(95057, DiagnosticCategory::Message, String::from("Convert_named_imports_to_namespace_import_95057"), String::from("Convert named imports to namespace import"), None, None, None) }
    pub fn add_or_remove_braces_in_an_arrow_function() -> DiagnosticMessage { diag(95058, DiagnosticCategory::Message, String::from("Add_or_remove_braces_in_an_arrow_function_95058"), String::from("Add or remove braces in an arrow function"), None, None, None) }
    pub fn add_braces_to_arrow_function() -> DiagnosticMessage { diag(95059, DiagnosticCategory::Message, String::from("Add_braces_to_arrow_function_95059"), String::from("Add braces to arrow function"), None, None, None) }
    pub fn remove_braces_from_arrow_function() -> DiagnosticMessage { diag(95060, DiagnosticCategory::Message, String::from("Remove_braces_from_arrow_function_95060"), String::from("Remove braces from arrow function"), None, None, None) }
    pub fn convert_default_export_to_named_export() -> DiagnosticMessage { diag(95061, DiagnosticCategory::Message, String::from("Convert_default_export_to_named_export_95061"), String::from("Convert default export to named export"), None, None, None) }
    pub fn convert_named_export_to_default_export() -> DiagnosticMessage { diag(95062, DiagnosticCategory::Message, String::from("Convert_named_export_to_default_export_95062"), String::from("Convert named export to default export"), None, None, None) }
    pub fn add_missing_enum_member_0() -> DiagnosticMessage { diag(95063, DiagnosticCategory::Message, String::from("Add_missing_enum_member_0_95063"), String::from("Add missing enum member '{0}'"), None, None, None) }
    pub fn add_all_missing_imports() -> DiagnosticMessage { diag(95064, DiagnosticCategory::Message, String::from("Add_all_missing_imports_95064"), String::from("Add all missing imports"), None, None, None) }
    pub fn convert_to_async_function() -> DiagnosticMessage { diag(95065, DiagnosticCategory::Message, String::from("Convert_to_async_function_95065"), String::from("Convert to async function"), None, None, None) }
    pub fn convert_all_to_async_functions() -> DiagnosticMessage { diag(95066, DiagnosticCategory::Message, String::from("Convert_all_to_async_functions_95066"), String::from("Convert all to async functions"), None, None, None) }
    pub fn add_missing_call_parentheses() -> DiagnosticMessage { diag(95067, DiagnosticCategory::Message, String::from("Add_missing_call_parentheses_95067"), String::from("Add missing call parentheses"), None, None, None) }
    pub fn add_all_missing_call_parentheses() -> DiagnosticMessage { diag(95068, DiagnosticCategory::Message, String::from("Add_all_missing_call_parentheses_95068"), String::from("Add all missing call parentheses"), None, None, None) }
    pub fn add_unknown_conversion_for_non_overlapping_types() -> DiagnosticMessage { diag(95069, DiagnosticCategory::Message, String::from("Add_unknown_conversion_for_non_overlapping_types_95069"), String::from("Add 'unknown' conversion for non-overlapping types"), None, None, None) }
    pub fn add_unknown_to_all_conversions_of_non_overlapping_types() -> DiagnosticMessage { diag(95070, DiagnosticCategory::Message, String::from("Add_unknown_to_all_conversions_of_non_overlapping_types_95070"), String::from("Add 'unknown' to all conversions of non-overlapping types"), None, None, None) }
    pub fn add_missing_new_operator_to_call() -> DiagnosticMessage { diag(95071, DiagnosticCategory::Message, String::from("Add_missing_new_operator_to_call_95071"), String::from("Add missing 'new' operator to call"), None, None, None) }
    pub fn add_missing_new_operator_to_all_calls() -> DiagnosticMessage { diag(95072, DiagnosticCategory::Message, String::from("Add_missing_new_operator_to_all_calls_95072"), String::from("Add missing 'new' operator to all calls"), None, None, None) }
    pub fn add_names_to_all_parameters_without_names() -> DiagnosticMessage { diag(95073, DiagnosticCategory::Message, String::from("Add_names_to_all_parameters_without_names_95073"), String::from("Add names to all parameters without names"), None, None, None) }
    pub fn enable_the_experimentaldecorators_option_in_your_configuration_file() -> DiagnosticMessage { diag(95074, DiagnosticCategory::Message, String::from("Enable_the_experimentalDecorators_option_in_your_configuration_file_95074"), String::from("Enable the 'experimentalDecorators' option in your configuration file"), None, None, None) }
    pub fn convert_parameters_to_destructured_object() -> DiagnosticMessage { diag(95075, DiagnosticCategory::Message, String::from("Convert_parameters_to_destructured_object_95075"), String::from("Convert parameters to destructured object"), None, None, None) }
    pub fn extract_type() -> DiagnosticMessage { diag(95077, DiagnosticCategory::Message, String::from("Extract_type_95077"), String::from("Extract type"), None, None, None) }
    pub fn extract_to_type_alias() -> DiagnosticMessage { diag(95078, DiagnosticCategory::Message, String::from("Extract_to_type_alias_95078"), String::from("Extract to type alias"), None, None, None) }
    pub fn extract_to_typedef() -> DiagnosticMessage { diag(95079, DiagnosticCategory::Message, String::from("Extract_to_typedef_95079"), String::from("Extract to typedef"), None, None, None) }
    pub fn infer_this_type_of_0_from_usage() -> DiagnosticMessage { diag(95080, DiagnosticCategory::Message, String::from("Infer_this_type_of_0_from_usage_95080"), String::from("Infer 'this' type of '{0}' from usage"), None, None, None) }
    pub fn add_const_to_unresolved_variable() -> DiagnosticMessage { diag(95081, DiagnosticCategory::Message, String::from("Add_const_to_unresolved_variable_95081"), String::from("Add 'const' to unresolved variable"), None, None, None) }
    pub fn add_const_to_all_unresolved_variables() -> DiagnosticMessage { diag(95082, DiagnosticCategory::Message, String::from("Add_const_to_all_unresolved_variables_95082"), String::from("Add 'const' to all unresolved variables"), None, None, None) }
    pub fn add_await() -> DiagnosticMessage { diag(95083, DiagnosticCategory::Message, String::from("Add_await_95083"), String::from("Add 'await'"), None, None, None) }
    pub fn add_await_to_initializer_for_0() -> DiagnosticMessage { diag(95084, DiagnosticCategory::Message, String::from("Add_await_to_initializer_for_0_95084"), String::from("Add 'await' to initializer for '{0}'"), None, None, None) }
    pub fn fix_all_expressions_possibly_missing_await() -> DiagnosticMessage { diag(95085, DiagnosticCategory::Message, String::from("Fix_all_expressions_possibly_missing_await_95085"), String::from("Fix all expressions possibly missing 'await'"), None, None, None) }
    pub fn remove_unnecessary_await() -> DiagnosticMessage { diag(95086, DiagnosticCategory::Message, String::from("Remove_unnecessary_await_95086"), String::from("Remove unnecessary 'await'"), None, None, None) }
    pub fn remove_all_unnecessary_uses_of_await() -> DiagnosticMessage { diag(95087, DiagnosticCategory::Message, String::from("Remove_all_unnecessary_uses_of_await_95087"), String::from("Remove all unnecessary uses of 'await'"), None, None, None) }
    pub fn enable_the_jsx_flag_in_your_configuration_file() -> DiagnosticMessage { diag(95088, DiagnosticCategory::Message, String::from("Enable_the_jsx_flag_in_your_configuration_file_95088"), String::from("Enable the '--jsx' flag in your configuration file"), None, None, None) }
    pub fn add_await_to_initializers() -> DiagnosticMessage { diag(95089, DiagnosticCategory::Message, String::from("Add_await_to_initializers_95089"), String::from("Add 'await' to initializers"), None, None, None) }
    pub fn extract_to_interface() -> DiagnosticMessage { diag(95090, DiagnosticCategory::Message, String::from("Extract_to_interface_95090"), String::from("Extract to interface"), None, None, None) }
    pub fn convert_to_a_bigint_numeric_literal() -> DiagnosticMessage { diag(95091, DiagnosticCategory::Message, String::from("Convert_to_a_bigint_numeric_literal_95091"), String::from("Convert to a bigint numeric literal"), None, None, None) }
    pub fn convert_all_to_bigint_numeric_literals() -> DiagnosticMessage { diag(95092, DiagnosticCategory::Message, String::from("Convert_all_to_bigint_numeric_literals_95092"), String::from("Convert all to bigint numeric literals"), None, None, None) }
    pub fn convert_const_to_let() -> DiagnosticMessage { diag(95093, DiagnosticCategory::Message, String::from("Convert_const_to_let_95093"), String::from("Convert 'const' to 'let'"), None, None, None) }
    pub fn prefix_with_declare() -> DiagnosticMessage { diag(95094, DiagnosticCategory::Message, String::from("Prefix_with_declare_95094"), String::from("Prefix with 'declare'"), None, None, None) }
    pub fn prefix_all_incorrect_property_declarations_with_declare() -> DiagnosticMessage { diag(95095, DiagnosticCategory::Message, String::from("Prefix_all_incorrect_property_declarations_with_declare_95095"), String::from("Prefix all incorrect property declarations with 'declare'"), None, None, None) }
    pub fn convert_to_template_string() -> DiagnosticMessage { diag(95096, DiagnosticCategory::Message, String::from("Convert_to_template_string_95096"), String::from("Convert to template string"), None, None, None) }
    pub fn add_export_to_make_this_file_into_a_module() -> DiagnosticMessage { diag(95097, DiagnosticCategory::Message, String::from("Add_export_to_make_this_file_into_a_module_95097"), String::from("Add 'export {}' to make this file into a module"), None, None, None) }
    pub fn set_the_target_option_in_your_configuration_file_to_0() -> DiagnosticMessage { diag(95098, DiagnosticCategory::Message, String::from("Set_the_target_option_in_your_configuration_file_to_0_95098"), String::from("Set the 'target' option in your configuration file to '{0}'"), None, None, None) }
    pub fn set_the_module_option_in_your_configuration_file_to_0() -> DiagnosticMessage { diag(95099, DiagnosticCategory::Message, String::from("Set_the_module_option_in_your_configuration_file_to_0_95099"), String::from("Set the 'module' option in your configuration file to '{0}'"), None, None, None) }
    pub fn convert_invalid_character_to_its_html_entity_code() -> DiagnosticMessage { diag(95100, DiagnosticCategory::Message, String::from("Convert_invalid_character_to_its_html_entity_code_95100"), String::from("Convert invalid character to its html entity code"), None, None, None) }
    pub fn convert_all_invalid_characters_to_html_entity_code() -> DiagnosticMessage { diag(95101, DiagnosticCategory::Message, String::from("Convert_all_invalid_characters_to_HTML_entity_code_95101"), String::from("Convert all invalid characters to HTML entity code"), None, None, None) }
    pub fn convert_all_const_to_let() -> DiagnosticMessage { diag(95102, DiagnosticCategory::Message, String::from("Convert_all_const_to_let_95102"), String::from("Convert all 'const' to 'let'"), None, None, None) }
    pub fn convert_function_expression_0_to_arrow_function() -> DiagnosticMessage { diag(95105, DiagnosticCategory::Message, String::from("Convert_function_expression_0_to_arrow_function_95105"), String::from("Convert function expression '{0}' to arrow function"), None, None, None) }
    pub fn convert_function_declaration_0_to_arrow_function() -> DiagnosticMessage { diag(95106, DiagnosticCategory::Message, String::from("Convert_function_declaration_0_to_arrow_function_95106"), String::from("Convert function declaration '{0}' to arrow function"), None, None, None) }
    pub fn fix_all_implicit_this_errors() -> DiagnosticMessage { diag(95107, DiagnosticCategory::Message, String::from("Fix_all_implicit_this_errors_95107"), String::from("Fix all implicit-'this' errors"), None, None, None) }
    pub fn wrap_invalid_character_in_an_expression_container() -> DiagnosticMessage { diag(95108, DiagnosticCategory::Message, String::from("Wrap_invalid_character_in_an_expression_container_95108"), String::from("Wrap invalid character in an expression container"), None, None, None) }
    pub fn wrap_all_invalid_characters_in_an_expression_container() -> DiagnosticMessage { diag(95109, DiagnosticCategory::Message, String::from("Wrap_all_invalid_characters_in_an_expression_container_95109"), String::from("Wrap all invalid characters in an expression container"), None, None, None) }
    pub fn visit_https_colon_slash_slashaka_ms_slashtsconfig_to_read_more_about_this_file() -> DiagnosticMessage { diag(95110, DiagnosticCategory::Message, String::from("Visit_https_colon_slash_slashaka_ms_slashtsconfig_to_read_more_about_this_file_95110"), String::from("Visit https://aka.ms/tsconfig to read more about this file"), None, None, None) }
    pub fn add_a_return_statement() -> DiagnosticMessage { diag(95111, DiagnosticCategory::Message, String::from("Add_a_return_statement_95111"), String::from("Add a return statement"), None, None, None) }
    pub fn remove_braces_from_arrow_function_body() -> DiagnosticMessage { diag(95112, DiagnosticCategory::Message, String::from("Remove_braces_from_arrow_function_body_95112"), String::from("Remove braces from arrow function body"), None, None, None) }
    pub fn wrap_the_following_body_with_parentheses_which_should_be_an_object_literal() -> DiagnosticMessage { diag(95113, DiagnosticCategory::Message, String::from("Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113"), String::from("Wrap the following body with parentheses which should be an object literal"), None, None, None) }
    pub fn add_all_missing_return_statement() -> DiagnosticMessage { diag(95114, DiagnosticCategory::Message, String::from("Add_all_missing_return_statement_95114"), String::from("Add all missing return statement"), None, None, None) }
    pub fn remove_braces_from_all_arrow_function_bodies_with_relevant_issues() -> DiagnosticMessage { diag(95115, DiagnosticCategory::Message, String::from("Remove_braces_from_all_arrow_function_bodies_with_relevant_issues_95115"), String::from("Remove braces from all arrow function bodies with relevant issues"), None, None, None) }
    pub fn wrap_all_object_literal_with_parentheses() -> DiagnosticMessage { diag(95116, DiagnosticCategory::Message, String::from("Wrap_all_object_literal_with_parentheses_95116"), String::from("Wrap all object literal with parentheses"), None, None, None) }
    pub fn move_labeled_tuple_element_modifiers_to_labels() -> DiagnosticMessage { diag(95117, DiagnosticCategory::Message, String::from("Move_labeled_tuple_element_modifiers_to_labels_95117"), String::from("Move labeled tuple element modifiers to labels"), None, None, None) }
    pub fn convert_overload_list_to_single_signature() -> DiagnosticMessage { diag(95118, DiagnosticCategory::Message, String::from("Convert_overload_list_to_single_signature_95118"), String::from("Convert overload list to single signature"), None, None, None) }
    pub fn generate_get_and_set_accessors_for_all_overriding_properties() -> DiagnosticMessage { diag(95119, DiagnosticCategory::Message, String::from("Generate_get_and_set_accessors_for_all_overriding_properties_95119"), String::from("Generate 'get' and 'set' accessors for all overriding properties"), None, None, None) }
    pub fn wrap_in_jsx_fragment() -> DiagnosticMessage { diag(95120, DiagnosticCategory::Message, String::from("Wrap_in_JSX_fragment_95120"), String::from("Wrap in JSX fragment"), None, None, None) }
    pub fn wrap_all_unparented_jsx_in_jsx_fragment() -> DiagnosticMessage { diag(95121, DiagnosticCategory::Message, String::from("Wrap_all_unparented_JSX_in_JSX_fragment_95121"), String::from("Wrap all unparented JSX in JSX fragment"), None, None, None) }
    pub fn convert_arrow_function_or_function_expression() -> DiagnosticMessage { diag(95122, DiagnosticCategory::Message, String::from("Convert_arrow_function_or_function_expression_95122"), String::from("Convert arrow function or function expression"), None, None, None) }
    pub fn convert_to_anonymous_function() -> DiagnosticMessage { diag(95123, DiagnosticCategory::Message, String::from("Convert_to_anonymous_function_95123"), String::from("Convert to anonymous function"), None, None, None) }
    pub fn convert_to_named_function() -> DiagnosticMessage { diag(95124, DiagnosticCategory::Message, String::from("Convert_to_named_function_95124"), String::from("Convert to named function"), None, None, None) }
    pub fn convert_to_arrow_function() -> DiagnosticMessage { diag(95125, DiagnosticCategory::Message, String::from("Convert_to_arrow_function_95125"), String::from("Convert to arrow function"), None, None, None) }
    pub fn remove_parentheses() -> DiagnosticMessage { diag(95126, DiagnosticCategory::Message, String::from("Remove_parentheses_95126"), String::from("Remove parentheses"), None, None, None) }
    pub fn could_not_find_a_containing_arrow_function() -> DiagnosticMessage { diag(95127, DiagnosticCategory::Message, String::from("Could_not_find_a_containing_arrow_function_95127"), String::from("Could not find a containing arrow function"), None, None, None) }
    pub fn containing_function_is_not_an_arrow_function() -> DiagnosticMessage { diag(95128, DiagnosticCategory::Message, String::from("Containing_function_is_not_an_arrow_function_95128"), String::from("Containing function is not an arrow function"), None, None, None) }
    pub fn could_not_find_export_statement() -> DiagnosticMessage { diag(95129, DiagnosticCategory::Message, String::from("Could_not_find_export_statement_95129"), String::from("Could not find export statement"), None, None, None) }
    pub fn this_file_already_has_a_default_export() -> DiagnosticMessage { diag(95130, DiagnosticCategory::Message, String::from("This_file_already_has_a_default_export_95130"), String::from("This file already has a default export"), None, None, None) }
    pub fn could_not_find_import_clause() -> DiagnosticMessage { diag(95131, DiagnosticCategory::Message, String::from("Could_not_find_import_clause_95131"), String::from("Could not find import clause"), None, None, None) }
    pub fn could_not_find_namespace_import_or_named_imports() -> DiagnosticMessage { diag(95132, DiagnosticCategory::Message, String::from("Could_not_find_namespace_import_or_named_imports_95132"), String::from("Could not find namespace import or named imports"), None, None, None) }
    pub fn selection_is_not_a_valid_type_node() -> DiagnosticMessage { diag(95133, DiagnosticCategory::Message, String::from("Selection_is_not_a_valid_type_node_95133"), String::from("Selection is not a valid type node"), None, None, None) }
    pub fn no_type_could_be_extracted_from_this_type_node() -> DiagnosticMessage { diag(95134, DiagnosticCategory::Message, String::from("No_type_could_be_extracted_from_this_type_node_95134"), String::from("No type could be extracted from this type node"), None, None, None) }
    pub fn could_not_find_property_for_which_to_generate_accessor() -> DiagnosticMessage { diag(95135, DiagnosticCategory::Message, String::from("Could_not_find_property_for_which_to_generate_accessor_95135"), String::from("Could not find property for which to generate accessor"), None, None, None) }
    pub fn name_is_not_valid() -> DiagnosticMessage { diag(95136, DiagnosticCategory::Message, String::from("Name_is_not_valid_95136"), String::from("Name is not valid"), None, None, None) }
    pub fn can_only_convert_property_with_modifier() -> DiagnosticMessage { diag(95137, DiagnosticCategory::Message, String::from("Can_only_convert_property_with_modifier_95137"), String::from("Can only convert property with modifier"), None, None, None) }
    pub fn switch_each_misused_0_to_1() -> DiagnosticMessage { diag(95138, DiagnosticCategory::Message, String::from("Switch_each_misused_0_to_1_95138"), String::from("Switch each misused '{0}' to '{1}'"), None, None, None) }
    pub fn convert_to_optional_chain_expression() -> DiagnosticMessage { diag(95139, DiagnosticCategory::Message, String::from("Convert_to_optional_chain_expression_95139"), String::from("Convert to optional chain expression"), None, None, None) }
    pub fn could_not_find_convertible_access_expression() -> DiagnosticMessage { diag(95140, DiagnosticCategory::Message, String::from("Could_not_find_convertible_access_expression_95140"), String::from("Could not find convertible access expression"), None, None, None) }
    pub fn could_not_find_matching_access_expressions() -> DiagnosticMessage { diag(95141, DiagnosticCategory::Message, String::from("Could_not_find_matching_access_expressions_95141"), String::from("Could not find matching access expressions"), None, None, None) }
    pub fn can_only_convert_logical_and_access_chains() -> DiagnosticMessage { diag(95142, DiagnosticCategory::Message, String::from("Can_only_convert_logical_AND_access_chains_95142"), String::from("Can only convert logical AND access chains"), None, None, None) }
    pub fn add_void_to_promise_resolved_without_a_value() -> DiagnosticMessage { diag(95143, DiagnosticCategory::Message, String::from("Add_void_to_Promise_resolved_without_a_value_95143"), String::from("Add 'void' to Promise resolved without a value"), None, None, None) }
    pub fn add_void_to_all_promises_resolved_without_a_value() -> DiagnosticMessage { diag(95144, DiagnosticCategory::Message, String::from("Add_void_to_all_Promises_resolved_without_a_value_95144"), String::from("Add 'void' to all Promises resolved without a value"), None, None, None) }
    pub fn use_element_access_for_0() -> DiagnosticMessage { diag(95145, DiagnosticCategory::Message, String::from("Use_element_access_for_0_95145"), String::from("Use element access for '{0}'"), None, None, None) }
    pub fn use_element_access_for_all_undeclared_properties() -> DiagnosticMessage { diag(95146, DiagnosticCategory::Message, String::from("Use_element_access_for_all_undeclared_properties_95146"), String::from("Use element access for all undeclared properties."), None, None, None) }
    pub fn delete_all_unused_imports() -> DiagnosticMessage { diag(95147, DiagnosticCategory::Message, String::from("Delete_all_unused_imports_95147"), String::from("Delete all unused imports"), None, None, None) }
    pub fn infer_function_return_type() -> DiagnosticMessage { diag(95148, DiagnosticCategory::Message, String::from("Infer_function_return_type_95148"), String::from("Infer function return type"), None, None, None) }
    pub fn return_type_must_be_inferred_from_a_function() -> DiagnosticMessage { diag(95149, DiagnosticCategory::Message, String::from("Return_type_must_be_inferred_from_a_function_95149"), String::from("Return type must be inferred from a function"), None, None, None) }
    pub fn could_not_determine_function_return_type() -> DiagnosticMessage { diag(95150, DiagnosticCategory::Message, String::from("Could_not_determine_function_return_type_95150"), String::from("Could not determine function return type"), None, None, None) }
    pub fn could_not_convert_to_arrow_function() -> DiagnosticMessage { diag(95151, DiagnosticCategory::Message, String::from("Could_not_convert_to_arrow_function_95151"), String::from("Could not convert to arrow function"), None, None, None) }
    pub fn could_not_convert_to_named_function() -> DiagnosticMessage { diag(95152, DiagnosticCategory::Message, String::from("Could_not_convert_to_named_function_95152"), String::from("Could not convert to named function"), None, None, None) }
    pub fn could_not_convert_to_anonymous_function() -> DiagnosticMessage { diag(95153, DiagnosticCategory::Message, String::from("Could_not_convert_to_anonymous_function_95153"), String::from("Could not convert to anonymous function"), None, None, None) }
    pub fn can_only_convert_string_concatenations_and_string_literals() -> DiagnosticMessage { diag(95154, DiagnosticCategory::Message, String::from("Can_only_convert_string_concatenations_and_string_literals_95154"), String::from("Can only convert string concatenations and string literals"), None, None, None) }
    pub fn selection_is_not_a_valid_statement_or_statements() -> DiagnosticMessage { diag(95155, DiagnosticCategory::Message, String::from("Selection_is_not_a_valid_statement_or_statements_95155"), String::from("Selection is not a valid statement or statements"), None, None, None) }
    pub fn add_missing_function_declaration_0() -> DiagnosticMessage { diag(95156, DiagnosticCategory::Message, String::from("Add_missing_function_declaration_0_95156"), String::from("Add missing function declaration '{0}'"), None, None, None) }
    pub fn add_all_missing_function_declarations() -> DiagnosticMessage { diag(95157, DiagnosticCategory::Message, String::from("Add_all_missing_function_declarations_95157"), String::from("Add all missing function declarations"), None, None, None) }
    pub fn method_not_implemented() -> DiagnosticMessage { diag(95158, DiagnosticCategory::Message, String::from("Method_not_implemented_95158"), String::from("Method not implemented."), None, None, None) }
    pub fn function_not_implemented() -> DiagnosticMessage { diag(95159, DiagnosticCategory::Message, String::from("Function_not_implemented_95159"), String::from("Function not implemented."), None, None, None) }
    pub fn add_override_modifier() -> DiagnosticMessage { diag(95160, DiagnosticCategory::Message, String::from("Add_override_modifier_95160"), String::from("Add 'override' modifier"), None, None, None) }
    pub fn remove_override_modifier() -> DiagnosticMessage { diag(95161, DiagnosticCategory::Message, String::from("Remove_override_modifier_95161"), String::from("Remove 'override' modifier"), None, None, None) }
    pub fn add_all_missing_override_modifiers() -> DiagnosticMessage { diag(95162, DiagnosticCategory::Message, String::from("Add_all_missing_override_modifiers_95162"), String::from("Add all missing 'override' modifiers"), None, None, None) }
    pub fn remove_all_unnecessary_override_modifiers() -> DiagnosticMessage { diag(95163, DiagnosticCategory::Message, String::from("Remove_all_unnecessary_override_modifiers_95163"), String::from("Remove all unnecessary 'override' modifiers"), None, None, None) }
    pub fn can_only_convert_named_export() -> DiagnosticMessage { diag(95164, DiagnosticCategory::Message, String::from("Can_only_convert_named_export_95164"), String::from("Can only convert named export"), None, None, None) }
    pub fn add_missing_properties() -> DiagnosticMessage { diag(95165, DiagnosticCategory::Message, String::from("Add_missing_properties_95165"), String::from("Add missing properties"), None, None, None) }
    pub fn add_all_missing_properties() -> DiagnosticMessage { diag(95166, DiagnosticCategory::Message, String::from("Add_all_missing_properties_95166"), String::from("Add all missing properties"), None, None, None) }
    pub fn add_missing_attributes() -> DiagnosticMessage { diag(95167, DiagnosticCategory::Message, String::from("Add_missing_attributes_95167"), String::from("Add missing attributes"), None, None, None) }
    pub fn add_all_missing_attributes() -> DiagnosticMessage { diag(95168, DiagnosticCategory::Message, String::from("Add_all_missing_attributes_95168"), String::from("Add all missing attributes"), None, None, None) }
    pub fn add_undefined_to_optional_property_type() -> DiagnosticMessage { diag(95169, DiagnosticCategory::Message, String::from("Add_undefined_to_optional_property_type_95169"), String::from("Add 'undefined' to optional property type"), None, None, None) }
    pub fn convert_named_imports_to_default_import() -> DiagnosticMessage { diag(95170, DiagnosticCategory::Message, String::from("Convert_named_imports_to_default_import_95170"), String::from("Convert named imports to default import"), None, None, None) }
    pub fn delete_unused_param_tag_0() -> DiagnosticMessage { diag(95171, DiagnosticCategory::Message, String::from("Delete_unused_param_tag_0_95171"), String::from("Delete unused '@param' tag '{0}'"), None, None, None) }
    pub fn delete_all_unused_param_tags() -> DiagnosticMessage { diag(95172, DiagnosticCategory::Message, String::from("Delete_all_unused_param_tags_95172"), String::from("Delete all unused '@param' tags"), None, None, None) }
    pub fn rename_param_tag_name_0_to_1() -> DiagnosticMessage { diag(95173, DiagnosticCategory::Message, String::from("Rename_param_tag_name_0_to_1_95173"), String::from("Rename '@param' tag name '{0}' to '{1}'"), None, None, None) }
    pub fn use_0() -> DiagnosticMessage { diag(95174, DiagnosticCategory::Message, String::from("Use_0_95174"), String::from("Use `{0}`."), None, None, None) }
    pub fn use_number_isnan_in_all_conditions() -> DiagnosticMessage { diag(95175, DiagnosticCategory::Message, String::from("Use_Number_isNaN_in_all_conditions_95175"), String::from("Use `Number.isNaN` in all conditions."), None, None, None) }
    pub fn convert_typedef_to_typescript_type() -> DiagnosticMessage { diag(95176, DiagnosticCategory::Message, String::from("Convert_typedef_to_TypeScript_type_95176"), String::from("Convert typedef to TypeScript type."), None, None, None) }
    pub fn convert_all_typedef_to_typescript_types() -> DiagnosticMessage { diag(95177, DiagnosticCategory::Message, String::from("Convert_all_typedef_to_TypeScript_types_95177"), String::from("Convert all typedef to TypeScript types."), None, None, None) }
    pub fn move_to_file() -> DiagnosticMessage { diag(95178, DiagnosticCategory::Message, String::from("Move_to_file_95178"), String::from("Move to file"), None, None, None) }
    pub fn cannot_move_to_file_selected_file_is_invalid() -> DiagnosticMessage { diag(95179, DiagnosticCategory::Message, String::from("Cannot_move_to_file_selected_file_is_invalid_95179"), String::from("Cannot move to file, selected file is invalid"), None, None, None) }
    pub fn use_import_type() -> DiagnosticMessage { diag(95180, DiagnosticCategory::Message, String::from("Use_import_type_95180"), String::from("Use 'import type'"), None, None, None) }
    pub fn use_type_0() -> DiagnosticMessage { diag(95181, DiagnosticCategory::Message, String::from("Use_type_0_95181"), String::from("Use 'type {0}'"), None, None, None) }
    pub fn fix_all_with_type_only_imports() -> DiagnosticMessage { diag(95182, DiagnosticCategory::Message, String::from("Fix_all_with_type_only_imports_95182"), String::from("Fix all with type-only imports"), None, None, None) }
    pub fn cannot_move_statements_to_the_selected_file() -> DiagnosticMessage { diag(95183, DiagnosticCategory::Message, String::from("Cannot_move_statements_to_the_selected_file_95183"), String::from("Cannot move statements to the selected file"), None, None, None) }
    pub fn inline_variable() -> DiagnosticMessage { diag(95184, DiagnosticCategory::Message, String::from("Inline_variable_95184"), String::from("Inline variable"), None, None, None) }
    pub fn could_not_find_variable_to_inline() -> DiagnosticMessage { diag(95185, DiagnosticCategory::Message, String::from("Could_not_find_variable_to_inline_95185"), String::from("Could not find variable to inline."), None, None, None) }
    pub fn variables_with_multiple_declarations_cannot_be_inlined() -> DiagnosticMessage { diag(95186, DiagnosticCategory::Message, String::from("Variables_with_multiple_declarations_cannot_be_inlined_95186"), String::from("Variables with multiple declarations cannot be inlined."), None, None, None) }
    pub fn add_missing_comma_for_object_member_completion_0() -> DiagnosticMessage { diag(95187, DiagnosticCategory::Message, String::from("Add_missing_comma_for_object_member_completion_0_95187"), String::from("Add missing comma for object member completion '{0}'."), None, None, None) }
    pub fn add_missing_parameter_to_0() -> DiagnosticMessage { diag(95188, DiagnosticCategory::Message, String::from("Add_missing_parameter_to_0_95188"), String::from("Add missing parameter to '{0}'"), None, None, None) }
    pub fn add_missing_parameters_to_0() -> DiagnosticMessage { diag(95189, DiagnosticCategory::Message, String::from("Add_missing_parameters_to_0_95189"), String::from("Add missing parameters to '{0}'"), None, None, None) }
    pub fn add_all_missing_parameters() -> DiagnosticMessage { diag(95190, DiagnosticCategory::Message, String::from("Add_all_missing_parameters_95190"), String::from("Add all missing parameters"), None, None, None) }
    pub fn add_optional_parameter_to_0() -> DiagnosticMessage { diag(95191, DiagnosticCategory::Message, String::from("Add_optional_parameter_to_0_95191"), String::from("Add optional parameter to '{0}'"), None, None, None) }
    pub fn add_optional_parameters_to_0() -> DiagnosticMessage { diag(95192, DiagnosticCategory::Message, String::from("Add_optional_parameters_to_0_95192"), String::from("Add optional parameters to '{0}'"), None, None, None) }
    pub fn add_all_optional_parameters() -> DiagnosticMessage { diag(95193, DiagnosticCategory::Message, String::from("Add_all_optional_parameters_95193"), String::from("Add all optional parameters"), None, None, None) }
    pub fn wrap_in_parentheses() -> DiagnosticMessage { diag(95194, DiagnosticCategory::Message, String::from("Wrap_in_parentheses_95194"), String::from("Wrap in parentheses"), None, None, None) }
    pub fn wrap_all_invalid_decorator_expressions_in_parentheses() -> DiagnosticMessage { diag(95195, DiagnosticCategory::Message, String::from("Wrap_all_invalid_decorator_expressions_in_parentheses_95195"), String::from("Wrap all invalid decorator expressions in parentheses"), None, None, None) }
    pub fn no_value_exists_in_scope_for_the_shorthand_property_0_either_declare_one_or_provide_an_initializer() -> DiagnosticMessage { diag(18004, DiagnosticCategory::Error, String::from("No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer_18004"), String::from("No value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer."), None, None, None) }
    pub fn classes_may_not_have_a_field_named_constructor() -> DiagnosticMessage { diag(18006, DiagnosticCategory::Error, String::from("Classes_may_not_have_a_field_named_constructor_18006"), String::from("Classes may not have a field named 'constructor'."), None, None, None) }
    pub fn jsx_expressions_may_not_use_the_comma_operator_did_you_mean_to_write_an_array() -> DiagnosticMessage { diag(18007, DiagnosticCategory::Error, String::from("JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array_18007"), String::from("JSX expressions may not use the comma operator. Did you mean to write an array?"), None, None, None) }
    pub fn private_identifiers_cannot_be_used_as_parameters() -> DiagnosticMessage { diag(18009, DiagnosticCategory::Error, String::from("Private_identifiers_cannot_be_used_as_parameters_18009"), String::from("Private identifiers cannot be used as parameters."), None, None, None) }
    pub fn an_accessibility_modifier_cannot_be_used_with_a_private_identifier() -> DiagnosticMessage { diag(18010, DiagnosticCategory::Error, String::from("An_accessibility_modifier_cannot_be_used_with_a_private_identifier_18010"), String::from("An accessibility modifier cannot be used with a private identifier."), None, None, None) }
    pub fn the_operand_of_a_delete_operator_cannot_be_a_private_identifier() -> DiagnosticMessage { diag(18011, DiagnosticCategory::Error, String::from("The_operand_of_a_delete_operator_cannot_be_a_private_identifier_18011"), String::from("The operand of a 'delete' operator cannot be a private identifier."), None, None, None) }
    pub fn constructor_is_a_reserved_word() -> DiagnosticMessage { diag(18012, DiagnosticCategory::Error, String::from("constructor_is_a_reserved_word_18012"), String::from("'#constructor' is a reserved word."), None, None, None) }
    pub fn property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier() -> DiagnosticMessage { diag(18013, DiagnosticCategory::Error, String::from("Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier_18013"), String::from("Property '{0}' is not accessible outside class '{1}' because it has a private identifier."), None, None, None) }
    pub fn the_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling() -> DiagnosticMessage { diag(18014, DiagnosticCategory::Error, String::from("The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_priv_18014"), String::from("The property '{0}' cannot be accessed on type '{1}' within this class because it is shadowed by another private identifier with the same spelling."), None, None, None) }
    pub fn property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2() -> DiagnosticMessage { diag(18015, DiagnosticCategory::Error, String::from("Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2_18015"), String::from("Property '{0}' in type '{1}' refers to a different member that cannot be accessed from within type '{2}'."), None, None, None) }
    pub fn private_identifiers_are_not_allowed_outside_class_bodies() -> DiagnosticMessage { diag(18016, DiagnosticCategory::Error, String::from("Private_identifiers_are_not_allowed_outside_class_bodies_18016"), String::from("Private identifiers are not allowed outside class bodies."), None, None, None) }
    pub fn the_shadowing_declaration_of_0_is_defined_here() -> DiagnosticMessage { diag(18017, DiagnosticCategory::Error, String::from("The_shadowing_declaration_of_0_is_defined_here_18017"), String::from("The shadowing declaration of '{0}' is defined here"), None, None, None) }
    pub fn the_declaration_of_0_that_you_probably_intended_to_use_is_defined_here() -> DiagnosticMessage { diag(18018, DiagnosticCategory::Error, String::from("The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here_18018"), String::from("The declaration of '{0}' that you probably intended to use is defined here"), None, None, None) }
    pub fn _0_modifier_cannot_be_used_with_a_private_identifier() -> DiagnosticMessage { diag(18019, DiagnosticCategory::Error, String::from("_0_modifier_cannot_be_used_with_a_private_identifier_18019"), String::from("'{0}' modifier cannot be used with a private identifier."), None, None, None) }
    pub fn an_enum_member_cannot_be_named_with_a_private_identifier() -> DiagnosticMessage { diag(18024, DiagnosticCategory::Error, String::from("An_enum_member_cannot_be_named_with_a_private_identifier_18024"), String::from("An enum member cannot be named with a private identifier."), None, None, None) }
    pub fn can_only_be_used_at_the_start_of_a_file() -> DiagnosticMessage { diag(18026, DiagnosticCategory::Error, String::from("can_only_be_used_at_the_start_of_a_file_18026"), String::from("'#!' can only be used at the start of a file."), None, None, None) }
    pub fn compiler_reserves_name_0_when_emitting_private_identifier_downlevel() -> DiagnosticMessage { diag(18027, DiagnosticCategory::Error, String::from("Compiler_reserves_name_0_when_emitting_private_identifier_downlevel_18027"), String::from("Compiler reserves name '{0}' when emitting private identifier downlevel."), None, None, None) }
    pub fn private_identifiers_are_only_available_when_targeting_ecmascript_2015_and_higher() -> DiagnosticMessage { diag(18028, DiagnosticCategory::Error, String::from("Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher_18028"), String::from("Private identifiers are only available when targeting ECMAScript 2015 and higher."), None, None, None) }
    pub fn private_identifiers_are_not_allowed_in_variable_declarations() -> DiagnosticMessage { diag(18029, DiagnosticCategory::Error, String::from("Private_identifiers_are_not_allowed_in_variable_declarations_18029"), String::from("Private identifiers are not allowed in variable declarations."), None, None, None) }
    pub fn an_optional_chain_cannot_contain_private_identifiers() -> DiagnosticMessage { diag(18030, DiagnosticCategory::Error, String::from("An_optional_chain_cannot_contain_private_identifiers_18030"), String::from("An optional chain cannot contain private identifiers."), None, None, None) }
    pub fn the_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents() -> DiagnosticMessage { diag(18031, DiagnosticCategory::Error, String::from("The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituent_18031"), String::from("The intersection '{0}' was reduced to 'never' because property '{1}' has conflicting types in some constituents."), None, None, None) }
    pub fn the_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some() -> DiagnosticMessage { diag(18032, DiagnosticCategory::Error, String::from("The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_pr_18032"), String::from("The intersection '{0}' was reduced to 'never' because property '{1}' exists in multiple constituents and is private in some."), None, None, None) }
    pub fn type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values() -> DiagnosticMessage { diag(18033, DiagnosticCategory::Error, String::from("Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values_18033"), String::from("Type '{0}' is not assignable to type '{1}' as required for computed enum member values."), None, None, None) }
    pub fn specify_the_jsx_fragment_factory_function_to_use_when_targeting_react_jsx_emit_with_jsxfactory_compiler_option_is_specified_e_g_fragment() -> DiagnosticMessage { diag(18034, DiagnosticCategory::Message, String::from("Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compi_18034"), String::from("Specify the JSX fragment factory function to use when targeting 'react' JSX emit with 'jsxFactory' compiler option is specified, e.g. 'Fragment'."), None, None, None) }
    pub fn invalid_value_for_jsxfragmentfactory_0_is_not_a_valid_identifier_or_qualified_name() -> DiagnosticMessage { diag(18035, DiagnosticCategory::Error, String::from("Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name_18035"), String::from("Invalid value for 'jsxFragmentFactory'. '{0}' is not a valid identifier or qualified-name."), None, None, None) }
    pub fn class_decorators_can_t_be_used_with_static_private_identifier_consider_removing_the_experimental_decorator() -> DiagnosticMessage { diag(18036, DiagnosticCategory::Error, String::from("Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_dec_18036"), String::from("Class decorators can't be used with static private identifier. Consider removing the experimental decorator."), None, None, None) }
    pub fn await_expression_cannot_be_used_inside_a_class_static_block() -> DiagnosticMessage { diag(18037, DiagnosticCategory::Error, String::from("await_expression_cannot_be_used_inside_a_class_static_block_18037"), String::from("'await' expression cannot be used inside a class static block."), None, None, None) }
    pub fn for_await_loops_cannot_be_used_inside_a_class_static_block() -> DiagnosticMessage { diag(18038, DiagnosticCategory::Error, String::from("for_await_loops_cannot_be_used_inside_a_class_static_block_18038"), String::from("'for await' loops cannot be used inside a class static block."), None, None, None) }
    pub fn invalid_use_of_0_it_cannot_be_used_inside_a_class_static_block() -> DiagnosticMessage { diag(18039, DiagnosticCategory::Error, String::from("Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block_18039"), String::from("Invalid use of '{0}'. It cannot be used inside a class static block."), None, None, None) }
    pub fn a_return_statement_cannot_be_used_inside_a_class_static_block() -> DiagnosticMessage { diag(18041, DiagnosticCategory::Error, String::from("A_return_statement_cannot_be_used_inside_a_class_static_block_18041"), String::from("A 'return' statement cannot be used inside a class static block."), None, None, None) }
    pub fn _0_is_a_type_and_cannot_be_imported_in_javascript_files_use_1_in_a_jsdoc_type_annotation() -> DiagnosticMessage { diag(18042, DiagnosticCategory::Error, String::from("_0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation_18042"), String::from("'{0}' is a type and cannot be imported in JavaScript files. Use '{1}' in a JSDoc type annotation."), None, None, None) }
    pub fn types_cannot_appear_in_export_declarations_in_javascript_files() -> DiagnosticMessage { diag(18043, DiagnosticCategory::Error, String::from("Types_cannot_appear_in_export_declarations_in_JavaScript_files_18043"), String::from("Types cannot appear in export declarations in JavaScript files."), None, None, None) }
    pub fn _0_is_automatically_exported_here() -> DiagnosticMessage { diag(18044, DiagnosticCategory::Message, String::from("_0_is_automatically_exported_here_18044"), String::from("'{0}' is automatically exported here."), None, None, None) }
    pub fn properties_with_the_accessor_modifier_are_only_available_when_targeting_ecmascript_2015_and_higher() -> DiagnosticMessage { diag(18045, DiagnosticCategory::Error, String::from("Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher_18045"), String::from("Properties with the 'accessor' modifier are only available when targeting ECMAScript 2015 and higher."), None, None, None) }
    pub fn _0_is_of_type_unknown() -> DiagnosticMessage { diag(18046, DiagnosticCategory::Error, String::from("_0_is_of_type_unknown_18046"), String::from("'{0}' is of type 'unknown'."), None, None, None) }
    pub fn _0_is_possibly_null() -> DiagnosticMessage { diag(18047, DiagnosticCategory::Error, String::from("_0_is_possibly_null_18047"), String::from("'{0}' is possibly 'null'."), None, None, None) }
    pub fn _0_is_possibly_undefined() -> DiagnosticMessage { diag(18048, DiagnosticCategory::Error, String::from("_0_is_possibly_undefined_18048"), String::from("'{0}' is possibly 'undefined'."), None, None, None) }
    pub fn _0_is_possibly_null_or_undefined() -> DiagnosticMessage { diag(18049, DiagnosticCategory::Error, String::from("_0_is_possibly_null_or_undefined_18049"), String::from("'{0}' is possibly 'null' or 'undefined'."), None, None, None) }
    pub fn the_value_0_cannot_be_used_here() -> DiagnosticMessage { diag(18050, DiagnosticCategory::Error, String::from("The_value_0_cannot_be_used_here_18050"), String::from("The value '{0}' cannot be used here."), None, None, None) }
    pub fn compiler_option_0_cannot_be_given_an_empty_string() -> DiagnosticMessage { diag(18051, DiagnosticCategory::Error, String::from("Compiler_option_0_cannot_be_given_an_empty_string_18051"), String::from("Compiler option '{0}' cannot be given an empty string."), None, None, None) }
    pub fn its_type_0_is_not_a_valid_jsx_element_type() -> DiagnosticMessage { diag(18053, DiagnosticCategory::Error, String::from("Its_type_0_is_not_a_valid_JSX_element_type_18053"), String::from("Its type '{0}' is not a valid JSX element type."), None, None, None) }
    pub fn await_using_statements_cannot_be_used_inside_a_class_static_block() -> DiagnosticMessage { diag(18054, DiagnosticCategory::Error, String::from("await_using_statements_cannot_be_used_inside_a_class_static_block_18054"), String::from("'await using' statements cannot be used inside a class static block."), None, None, None) }
    pub fn _0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedmodules_is_enabled() -> DiagnosticMessage { diag(18055, DiagnosticCategory::Error, String::from("_0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is__18055"), String::from("'{0}' has a string type, but must have syntactically recognizable string syntax when 'isolatedModules' is enabled."), None, None, None) }
    pub fn enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedmodules_is_enabled() -> DiagnosticMessage { diag(18056, DiagnosticCategory::Error, String::from("Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is__18056"), String::from("Enum member following a non-literal numeric member must have an initializer when 'isolatedModules' is enabled."), None, None, None) }
    pub fn string_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020() -> DiagnosticMessage { diag(18057, DiagnosticCategory::Error, String::from("String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es_18057"), String::from("String literal import and export names are not supported when the '--module' flag is set to 'es2015' or 'es2020'."), None, None, None) }
}